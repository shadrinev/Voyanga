/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function( window, undefined ) {
var
	// A central reference to the root jQuery(document)
	rootjQuery,

	// The deferred used on DOM ready
	readyList,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

	// Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// The ready event handler and self cleanup method
	DOMContentLoaded = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			jQuery.ready();
		} else if ( document.readyState === "complete" ) {
			// we're here because readyState === "complete" in oldIE
			// which is good enough for us to call the dom ready!
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	},

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context && context.nodeType ? context.ownerDocument || context : document );

					// scripts is true for back-compat
					selector = jQuery.parseHTML( match[1], doc, true );
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						this.attr.call( selector, context, true );
					}

					return jQuery.merge( this, selector );

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.8.3",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
			"slice", core_slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ core_toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// scripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			scripts = context;
			context = 0;
		}
		context = context || document;

		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && core_rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction( obj );

		if ( args ) {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.apply( obj[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( obj[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var type,
			ret = results || [];

		if ( arr != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			type = jQuery.type( arr );

			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
				core_push.call( ret, arr );
			} else {
				jQuery.merge( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key,
			ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready, 1 );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Support tests won't run in some limited or non-browser environments
	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !all || !a || !all.length ) {
		return {};
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";
	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form (#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: ( document.compatMode === "CSS1Compat" ),

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", clickFn = function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent("onclick");
		div.detachEvent( "onclick", clickFn );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	input.setAttribute( "checked", "checked" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: true,
			change: true,
			focusin: true
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, div, tds, marginDiv,
			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// NOTE: To any future maintainer, we've window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. For more
			// info see bug #3333
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = document.createElement("div");
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			container.style.zoom = 1;
		}

		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	fragment.removeChild( div );
	all = a = select = opt = input = fragment = div = null;

	return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	deletedIds: [],

	// Remove at next major release (1.9/2.0)
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( !name.indexOf( "data-" ) ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				// Only convert to a number if it doesn't change the string
				+data + "" === data ? +data :
				rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery.removeData( elem, type + "queue", true );
				jQuery.removeData( elem, key, true );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
			removes = ( value || "" ).split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 && elem.className ) {

					className = (" " + elem.className + " ").replace( rclass, " " );

					// loop over each item in the removal list
					for ( c = 0, cl = removes.length; c < cl; c++ ) {
						// Remove until there is nothing to remove,
						while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
							className = className.replace( " " + removes[ c ] + " " , " " );
						}
					}
					elem.className = value ? jQuery.trim( className ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( core_rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
	attrFn: {},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {

			attrNames = value.split( core_rspace );

			for ( ; i < attrNames.length; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.value = value + "" );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, "events", true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			for ( old = elem; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old === (elem.ownerDocument || document) ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = core_slice.call( arguments ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [];

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					selMatch = {};
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === "undefined" ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "_submit_attached" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "_submit_attached", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "_change_attached", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,
	outermostContext,

	baseHasDuplicate = true,
	strundefined = "undefined",

	expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

	Token = String,
	document = window.document,
	docElem = document.documentElement,
	dirruns = 0,
	done = 0,
	pop = [].pop,
	push = [].push,
	slice = [].slice,
	// Use a stripped-down indexOf if a native one is unavailable
	indexOf = [].indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	// Augment a function for special use by Sizzle
	markFunction = function( fn, value ) {
		fn[ expando ] = value == null || value;
		return fn;
	},

	createCache = function() {
		var cache = {},
			keys = [];

		return markFunction(function( key, value ) {
			// Only keep the most recent entries
			if ( keys.push( key ) > Expr.cacheLength ) {
				delete cache[ keys.shift() ];
			}

			// Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
			return (cache[ key + " " ] = value);
		}, cache );
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments not in parens/brackets,
	//   then attribute selectors and non-pseudos (denoted by :),
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

	// For matchExpr.POS and matchExpr.needsContext
	pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
		"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"POS": new RegExp( pos, "i" ),
		"CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
	},

	// Support

	// Used for testing something on an element
	assert = function( fn ) {
		var div = document.createElement("div");

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	},

	// Check if getElementsByTagName("*") returns only elements
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = document.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			document.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			document.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !document.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( nodeType !== 1 && nodeType !== 9 ) {
		return [];
	}

	xml = isXML( context );

	if ( !xml && !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;
		return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
		return b && !!( a.compareDocumentPosition( b ) & 16 );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

Sizzle.attr = function( elem, name ) {
	var val,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( xml || assertAttributes ) {
		return elem.getAttribute( name );
	}
	val = elem.getAttributeNode( name );
	return val ?
		typeof elem[ name ] === "boolean" ?
			elem[ name ] ? name : null :
			val.specified ? val.value : null :
		null;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		},

	find: {
		"ID": assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			},

		"TAG": assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			},

		"NAME": assertUsableName && function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		},

		"CLASS": assertUsableClassName && function( className, context, xml ) {
			if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( rbackslash, "" );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === "nth" ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var unquoted, excess;
			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			if ( match[3] ) {
				match[2] = match[3];
			} else if ( (unquoted = match[4]) ) {
				// Only check arguments that contain a pseudo
				if ( rpseudo.test(unquoted) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					unquoted = unquoted.slice( 0, excess );
					match[0] = match[0].slice( 0, excess );
				}
				match[2] = unquoted;
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		"ID": assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					return elem.getAttribute("id") === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === id;
				};
			},

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ expando ][ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem, context ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.substr( result.length - check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, argument, first, last ) {

			if ( type === "nth" ) {
				return function( elem ) {
					var node, diff,
						parent = elem.parentNode;

					if ( first === 1 && last === 0 ) {
						return true;
					}

					if ( parent ) {
						diff = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								diff++;
								if ( elem === node ) {
									break;
								}
							}
						}
					}

					// Incorporate the offset (or cast to NaN), then check against cycle size
					diff -= last;
					return diff === first || ( diff % first === 0 && diff / first >= 0 );
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case "only":
					case "first":
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === "first" ) {
							return true;
						}

						node = elem;

						/* falls through */
					case "last":
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"text": function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
		},

		// Input types
		"radio": createInputPseudo("radio"),
		"checkbox": createInputPseudo("checkbox"),
		"file": createInputPseudo("file"),
		"password": createInputPseudo("password"),
		"image": createInputPseudo("image"),

		"submit": createButtonPseudo("submit"),
		"reset": createButtonPseudo("reset"),

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"focus": function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		"active": function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		},

		// Positional types
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			for ( var i = 0; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			for ( var i = 1; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

function siblingCheck( a, b, ret ) {
	if ( a === b ) {
		return ret;
	}

	var cur = a.nextSibling;

	while ( cur ) {
		if ( cur === b ) {
			return -1;
		}

		cur = cur.nextSibling;
	}

	return 1;
}

sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	} :
	function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		i = 1,
		j = 0;

	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ expando ][ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			tokens.push( matched = new Token( match.shift() ) );
			soFar = soFar.slice( matched.length );

			// Cast descendant combinators to space
			matched.type = match[0].replace( rtrim, " " );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {

				tokens.push( matched = new Token( match.shift() ) );
				soFar = soFar.slice( matched.length );
				matched.type = type;
				matched.matches = match;
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && combinator.dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( checkNonElements || elem.nodeType === 1  ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( !xml ) {
				var cache,
					dirkey = dirruns + " " + doneName + " ",
					cachedkey = dirkey + cachedruns;
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( (cache = elem[ expando ]) === cachedkey ) {
							return elem.sizset;
						} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
							if ( elem.sizset ) {
								return elem;
							}
						} else {
							elem[ expando ] = cachedkey;
							if ( matcher( elem, context, xml ) ) {
								elem.sizset = true;
								return elem;
							}
							elem.sizset = false;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( matcher( elem, context, xml ) ) {
							return elem;
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && tokens.join("")
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Nested matchers should use non-integer dirruns
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = superMatcher.el;
			}

			// Add elements passing elementMatchers directly to results
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++superMatcher.el;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				for ( j = 0; (matcher = setMatchers[j]); j++ ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	superMatcher.el = 0;
	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ expando ][ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed, xml ) {
	var i, tokens, token, type, find,
		match = tokenize( selector ),
		j = match.length;

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !xml &&
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().length );
			}

			// Fetch a seed set for right-to-left matching
			for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( rbackslash, "" ),
						rsibling.test( tokens[0].type ) && context.parentNode || context,
						xml
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && tokens.join("");
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		xml,
		results,
		rsibling.test( selector )
	);
	return results;
}

if ( document.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

			// qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
			// A support test would require too much code (would include document ready)
			rbuggyQSA = [ ":focus" ],

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [ ":active" ],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<p test=''></p>";
			if ( div.querySelectorAll("[test^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = "<input type='hidden'/>";
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push(":enabled", ":disabled");
			}
		});

		// rbuggyQSA always contains :focus, so no need for a length check
		rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed && !xml && !rbuggyQSA.test( selector ) ) {
				var groups, i,
					old = true,
					nid = expando,
					newContext = context,
					newSelector = context.nodeType === 9 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + groups[i].join("");
					}
					newContext = rsibling.test( selector ) && context.parentNode || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, "[test!='']:sizzle" );
					rbuggyMatches.push( "!=", pseudos );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active and :focus, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && !rbuggyQSA.test( expr ) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length > 0;
			};
		}
	})();
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, l, length, n, r, ret,
			self = this;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		ret = this.pushStack( "", "find", selector );

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rcheckableType = /^(?:checkbox|radio)$/,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
		}
	},

	after: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( !isDisconnected( this[0] ) ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		}

		return this.length ?
			this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
			this;
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = [].concat.apply( [], args );

		var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call( this, i, table ? self.html() : undefined );
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			results = jQuery.buildFragment( args, this, scripts );
			fragment = results.fragment;
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				// Fragments from the fragment cache must always be cloned and never used in place.
				for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone( fragment, true, true )
					);
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						if ( jQuery.ajax ) {
							jQuery.ajax({
								url: elem.src,
								type: "GET",
								dataType: "script",
								async: false,
								global: false,
								"throws": true
							});
						} else {
							jQuery.error("no ajax");
						}
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	if ( nodeName === "object" ) {
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
	var fragment, cacheable, cachehit,
		first = args[ 0 ];

	// Set context from what may come in as undefined or a jQuery collection or a node
	// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
	// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
	context = context || document;
	context = !context.nodeType && context[0] || context;
	context = context.ownerDocument || context;

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		// Mark cacheable and look for a hit
		cacheable = true;
		fragment = jQuery.fragments[ first ];
		cachehit = fragment !== undefined;
	}

	if ( !fragment ) {
		fragment = context.createDocumentFragment();
		jQuery.clean( args, context, fragment, scripts );

		// Update the cache, but only store false
		// unless this is a second parsing of the same content
		if ( cacheable ) {
			jQuery.fragments[ first ] = cachehit && fragment;
		}
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			l = insert.length,
			parent = this.length === 1 && this[0].parentNode;

		if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( ; i < l; i++ ) {
				elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone;

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document && safeFragment,
			ret = [];

		// Ensure that context is a document
		if ( !context || typeof context.createDocumentFragment === "undefined" ) {
			context = document;
		}

		// Use the already-created safe fragment if context permits
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Ensure a safe container in which to render the html
					safe = safe || createSafeFragment( context );
					div = context.createElement("div");
					safe.appendChild( div );

					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Go to html and back, then peel off extra wrappers
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					depth = wrap[0];
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						hasBody = rtbody.test(elem);
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Take out of fragment container (we need a fresh div each time)
					div.parentNode.removeChild( div );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				jQuery.merge( ret, elem );
			}
		}

		// Fix #11356: Clear elements from safeFragment
		if ( div ) {
			elem = div = safe = null;
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					fixDefaultChecked( elem );
				} else if ( typeof elem.getElementsByTagName !== "undefined" ) {
					jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
				}
			}
		}

		// Append elements to a provided document fragment
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( elem.removeAttribute ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						jQuery.deletedIds.push( id );
					}
				}
			}
		}
	}
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

	eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var elem, display,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		values[ index ] = jQuery._data( elem, "olddisplay" );
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && elem.style.display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {
			display = curCSS( elem, "display" );

			if ( !values[ index ] && display !== "none" ) {
				jQuery._data( elem, "olddisplay", display );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state, fn2 ) {
		var bool = typeof state === "boolean";

		if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
			return eventsToggle.apply( this, arguments );
		}

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, numeric, extra ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( numeric || extra !== undefined ) {
			num = parseFloat( val );
			return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	curCSS = function( elem, name ) {
		var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle( elem, null ),
			style = elem.style;

		if ( computed ) {

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			// we use jQuery.css instead of curCSS here
			// because of the reliableMarginRight CSS hook!
			val += jQuery.css( elem, extra + cssExpand[ i ], true );
		}

		// From this point on we use curCSS for maximum performance (relevant in animations)
		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox
		)
	) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	if ( elemdisplay[ nodeName ] ) {
		return elemdisplay[ nodeName ];
	}

	var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
		display = elem.css("display");
	elem.remove();

	// If the simple way fails,
	// get element's real default display by attaching it to a temp iframe
	if ( display === "none" || display === "" ) {
		// Use the already-created iframe if possible
		iframe = document.body.appendChild(
			iframe || jQuery.extend( document.createElement("iframe"), {
				frameBorder: 0,
				width: 0,
				height: 0
			})
		);

		// Create a cacheable copy of the iframe document on first call.
		// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
		// document to it; WebKit & Firefox won't allow reusing the iframe document.
		if ( !iframeDoc || !iframe.createElement ) {
			iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
			iframeDoc.write("<!doctype html><html><body>");
			iframeDoc.close();
		}

		elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

		display = curCSS( elem, "display" );
		document.body.removeChild( iframe );
	}

	// Store the correct default display
	elemdisplay[ nodeName ] = display;

	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				} else {
					return getWidthOrHeight( elem, name, extra );
				}
			}
		},

		set: function( elem, value, extra ) {
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
				style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "marginRight" );
					}
				});
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						var ret = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	// Don't do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// Request the remote document
	jQuery.ajax({
		url: url,

		// if "type" variable is undefined, then "GET" method will be used
		type: type,
		dataType: "html",
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {

		// Save response for use in complete callback
		response = arguments;

		// See if a selector was specified
		self.html( selector ?

			// Create a dummy div to hold the results
			jQuery("<div>")

				// inject the contents of the document in, removing the scripts
				// to avoid any 'Permission Denied' errors in IE
				.append( responseText.replace( rscript, "" ) )

				// Locate the specified elements
				.find( selector ) :

			// If not, just inject the full result
			responseText );

	});

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // ifModified key
			ifModifiedKey,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || strAbort;
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader("Etag");
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.always( tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();

		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	var conv, conv2, current, tmp,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ],
		converters = {},
		i = 0;

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&|$)|\?\?/,
	nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback && rjsonp.test( url ),
		replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
			!( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
			rjsonp.test( data );

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
		overwritten = window[ callbackName ];

		// Insert callback into url or form data
		if ( replaceInUrl ) {
			s.url = url.replace( rjsonp, "$1" + callbackName );
		} else if ( replaceInData ) {
			s.data = data.replace( rjsonp, "$1" + callbackName );
		} else if ( hasCallback ) {
			s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var xhrCallbacks,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( e ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback, 0 );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	}, 0 );
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end, easing ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			anim: animation,
			queue: animation.opts.queue,
			elem: elem
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.done(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( "hidden" in dataShow ) {
			hidden = dataShow.hidden;
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery.removeData( elem, "fxshow", true );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing any value as a 4th parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, false, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ||
			// special check for .toggle( handler, handler, ... )
			( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations resolve immediately
				if ( empty ) {
					anim.stop( true );
				}
			};

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	if ( (body = doc.body) === elem ) {
		return jQuery.offset.bodyOffset( elem );
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== "undefined" ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	clientTop  = docElem.clientTop  || body.clientTop  || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;
	scrollTop  = win.pageYOffset || docElem.scrollTop;
	scrollLeft = win.pageXOffset || docElem.scrollLeft;
	return {
		top: box.top  + scrollTop  - clientTop,
		left: box.left + scrollLeft - clientLeft
	};
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.body;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, value, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}

})( window );
if ($.browser.msie) (function() {

    var __console, Console;

    Console = function() {
        var check = setInterval(function() {
            var f;
            if (window.console && console.log && !console.__buffer) {
                clearInterval(check);
                f = (Function.prototype.bind) ? Function.prototype.bind.call(console.log, console) : console.log;
                for (var i = 0; i < __console.__buffer.length; i++) f.apply(console, __console.__buffer[i]);
            }
        }, 1000);

        function log() {
            this.__buffer.push(arguments);
        }

        this.log = log;
        this.error = log;
        this.warn = log;
        this.info = log;
        this.time = log;
        this.timeEnd = log;
        this.__buffer = [];
    };

    __console = window.console = new Console();
})();var var_widthMAX = 1390;
var var_widthMID = 1290;
var var_widthMIN = 1000;

var var_valueMAX = var_widthMAX - var_widthMID;
var var_valueMIN = var_widthMID - var_widthMIN;

var var_widthLeftBlockMAX = 295;
var var_widthLeftBlockMID = 295;
var var_widthLeftBlockMIN = 255;

var var_widthMiddleBlockOneMAX = 935;
var var_widthMiddleBlockMAX = 855;
var var_widthMiddleBlockMID = 755;
var var_widthMiddleBlockMIN = 585;

var var_widthFilterMAX = 240;
var var_widthFilterMID = 240;
var var_widthFilterMIN = 200;

var var_paddingLeftMAX = 12;
var var_paddingLeftMID = 12;
var var_paddingLeftMIN = 12;

var var_paddingRightSlideMAX = 305;
var var_paddingRightSlideMID = 305;
var var_paddingRightSlideMIN = 65;

var var_paddingLeftTelefonMAX = 250;
var var_paddingLeftTelefonMID = 250;
var var_paddingLeftTelefonMIN = 220;

var var_widthMainBlockMAX = 695;
var var_widthMainBlockMIN = 530;
var var_iphone = 0;

window.hotelsScrollCallback = function(){}

function ResizeCenterBlock() {
	var block = $('.center-block');
	var isset = block.length;
	if (isset) {
        //console.log('!!!==== 0 ====!!!');
		var var_leftBlock = $('.left-block');
		var var_head = $('.head');
		var var_mainBlock = block.find('.main-block');
		var var_content = block.find('.main-block').find('#content');
		var var_filterBlock = block.find('.filter-block');
		var var_logoBlock = block.find('.logo');
		var var_aboutBlock = block.find('.about');
		var var_slideBlock = $('.slide-turn-mode');
		var var_telefonBlock = $('.telefon');
		var var_ticketsItems = $('.ticket-content');
		var var_recomendedItems = $('.head-content');
		var var_hotelItems = $('.hotels-tickets');
		var var_calendarGridVoyanga = $('.calenderWindow');
		var var_allTripInfo = $('.allTrip .info');
		var var_descrItems = $('#descr');
		var widthLeftBlock,
			widthMainBlock,
			widthFilterBlock,
			paddingLeftLogo = 32,
			leftTopPadding,
			paddingRightSlide,
			paddingLeftTel,
			marginLeftMain,
			marginLeftFilter,
			marginLeftMainBlock,
			marginRightMainBlock,
			marginRightFilterBlock,
			marginLeftLeftBlock,
			var_margin,
			marginRightContent,
			marginLeftContent,
			widthContent,
			var_widthDescrLeft,
			var_widthStreet,
			widthAllTripInfo,
			paddingLeftInfo,
			widthLogin;

		var widthBlock = block.width();
		var var_leftBlockIsset = var_leftBlock.length > 0 && var_leftBlock.is(':visible');
		var var_mainBlockIsset = var_mainBlock.length > 0 && var_mainBlock.is(':visible');
		var var_filterBlockIsset = var_filterBlock.length > 0 && var_filterBlock.is(':visible');
		var var_calendarGridVoyangaIsset = var_calendarGridVoyanga.length > 0 && var_calendarGridVoyanga.is(':visible');

		var var_descrIsset = var_descrItems.length > 0 && var_descrItems.is(':visible');
		
		
		if (! var_leftBlockIsset &&  ! var_filterBlockIsset && var_mainBlockIsset) {
			if (widthBlock >= var_widthMAX) {
				widthMainBlock = var_widthMiddleBlockOneMAX;
				marginLeftMainBlock = 'auto';
				marginRightMainBlock = 'auto';

				paddingLeftLogo = var_paddingLeftMAX;
				paddingRightSlide = var_paddingRightSlideMAX;
				paddingLeftTel = var_paddingLeftTelefonMAX;
				
				widthContent = widthMainBlock;
				
				paddingRightSlide += 165;
			}
			else if (widthBlock < var_widthMAX && widthBlock >= var_widthMID) {
				widthMainBlock = var_widthMiddleBlockOneMAX;
				marginLeftMainBlock = 'auto';
				marginRightMainBlock = 'auto';

				paddingLeftLogo = var_paddingLeftMID;
				paddingRightSlide = var_paddingRightSlideMID;
				paddingLeftTel = var_paddingLeftTelefonMID;
				
				widthContent = widthMainBlock;
				
				paddingRightSlide += 165;
			}
			else if (widthBlock < var_widthMID && widthBlock >= var_widthMIN) {
				widthMainBlock = var_widthMiddleBlockOneMAX;
				marginLeftMainBlock = 'auto';
				marginRightMainBlock = 'auto';

				paddingLeftLogo = Math.floor(var_paddingLeftMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftMID - var_paddingLeftMIN))) );
				paddingRightSlide = Math.floor(var_paddingRightSlideMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingRightSlideMID - var_paddingRightSlideMIN))) );
				paddingLeftTel = Math.floor(var_paddingLeftTelefonMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftTelefonMID - var_paddingLeftTelefonMIN))) );
				
				widthContent = widthMainBlock;
				
				paddingRightSlide += 100;
			}
		}
		else if (! var_leftBlockIsset &&  var_filterBlockIsset && var_mainBlockIsset) {
			if (widthBlock >= var_widthMAX) {
				widthMainBlock = var_widthMiddleBlockMAX;
				widthFilterBlock = var_widthFilterMAX;
				var_margin = Math.floor((widthBlock - (widthMainBlock + widthFilterBlock)) / 2)
				marginLeftMainBlock = var_margin;
				marginRightMainBlock = widthFilterBlock + var_margin;
				marginRightFilterBlock = var_margin;

				paddingLeftLogo = var_paddingLeftMAX;
				paddingRightSlide = var_paddingRightSlideMAX;
				paddingLeftTel = var_paddingLeftTelefonMAX;

				widthContent = var_widthMainBlockMAX;
				marginLeftContent = 'auto';
				marginRightContent = 'auto';
				
				paddingRightSlide += 165;
			}
			else if (widthBlock < var_widthMAX && widthBlock >= var_widthMID) {
				widthMainBlock = Math.floor(var_widthMiddleBlockMID + ((widthBlock - var_widthMID) / 1));
				widthFilterBlock = var_widthFilterMID;
				var_margin = Math.floor((widthBlock - (widthMainBlock + widthFilterBlock)) / 2)
				marginLeftMainBlock = var_margin;
				marginRightMainBlock = widthFilterBlock + var_margin;
				marginRightFilterBlock = var_margin;

				paddingLeftLogo = var_paddingLeftMID;
				paddingRightSlide = var_paddingRightSlideMID;
				paddingLeftTel = var_paddingLeftTelefonMID;

				widthContent = var_widthMainBlockMAX;
				marginLeftContent = 'auto';
				marginRightContent = 'auto';
				
				paddingRightSlide += 165;
			}
			else if (widthBlock < var_widthMID && widthBlock >= var_widthMIN) {
				widthFilterBlock = Math.floor(220 + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_widthFilterMID - 220))) );
				var_margin = 20;
				widthMainBlock = Math.floor((widthBlock  - widthFilterBlock) - (var_margin * 2));
				if (widthMainBlock > var_widthMiddleBlockMID) {
					widthMainBlock = var_widthMiddleBlockMID
				}
				var_margin = Math.floor((widthBlock - (widthMainBlock + widthFilterBlock)) / 2)
				marginLeftMainBlock = var_margin;
				marginRightMainBlock = widthFilterBlock + var_margin;
				marginRightFilterBlock = var_margin;

				paddingLeftLogo = Math.floor(var_paddingLeftMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftMID - var_paddingLeftMIN))) );
				paddingRightSlide = Math.floor(var_paddingRightSlideMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingRightSlideMID - var_paddingRightSlideMIN))) );
				paddingLeftTel = Math.floor(var_paddingLeftTelefonMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftTelefonMID - var_paddingLeftTelefonMIN))) );

				widthContent = var_widthMainBlockMAX;
				marginLeftContent = 'auto';
				marginRightContent = 'auto';
				
				paddingRightSlide += 100;
			}
		}

		else if (var_leftBlockIsset &&  var_filterBlockIsset && var_mainBlockIsset) {
			if (widthBlock >= var_widthMAX) {
				widthLeftBlock = var_widthLeftBlockMAX;
				widthMainBlock = var_widthMiddleBlockMAX;
				widthFilterBlock = var_widthFilterMAX;
				var_margin = Math.floor((widthBlock - (widthMainBlock + widthFilterBlock + widthLeftBlock)) / 2);
				marginLeftMainBlock = widthLeftBlock;
				marginRightMainBlock = widthFilterBlock;
				marginRightFilterBlock = 0;
				marginLeftLeftBlock = 0;

				paddingLeftLogo = var_paddingLeftMAX;
				paddingRightSlide = var_paddingRightSlideMAX;
				paddingLeftTel = var_paddingLeftTelefonMAX;

				widthContent = var_widthMainBlockMAX;
				
				paddingRightSlide += 165;
			}
			else if (widthBlock < var_widthMAX && widthBlock >= var_widthMID) {
				widthLeftBlock = var_widthLeftBlockMID;
				widthMainBlock = Math.floor(var_widthMiddleBlockMID + ((widthBlock - var_widthMID) / 1));
				widthFilterBlock = var_widthFilterMID;
				marginLeftMainBlock = widthLeftBlock;
				marginRightMainBlock = widthFilterBlock;
				marginRightFilterBlock = 0;
				marginLeftLeftBlock = 0;

				paddingLeftLogo = var_paddingLeftMID;
				paddingRightSlide = var_paddingRightSlideMID;
				paddingLeftTel = var_paddingLeftTelefonMID;

				widthContent = var_widthMainBlockMAX;
				
				paddingRightSlide += 165;
			}
			else if (widthBlock < var_widthMID && widthBlock >= var_widthMIN) {
				widthLeftBlock = Math.floor(220 + ( (widthBlock - var_widthMIN) / (var_valueMIN / (var_widthLeftBlockMID - 220))) );
				widthMainBlock = Math.floor(var_widthMiddleBlockMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_widthMiddleBlockMID - var_widthMiddleBlockMIN))) );
				widthFilterBlock = Math.floor(var_widthFilterMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_widthFilterMID - var_widthFilterMIN))) );

				paddingLeftLogo = Math.floor(var_paddingLeftMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftMID - var_paddingLeftMIN))) );
				paddingRightSlide = Math.floor(var_paddingRightSlideMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingRightSlideMID - var_paddingRightSlideMIN))) );
				paddingLeftTel = Math.floor(var_paddingLeftTelefonMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftTelefonMID - var_paddingLeftTelefonMIN))) );

				marginLeftMainBlock = widthLeftBlock;
				marginRightMainBlock = widthFilterBlock;
				marginRightFilterBlock = 0;
				marginLeftLeftBlock = 0;

				widthContent = Math.floor(var_widthMainBlockMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_widthMainBlockMAX - var_widthMainBlockMIN))) );
				
				paddingRightSlide += 100;
			}
		}

		else if (var_leftBlockIsset && var_mainBlockIsset &&  ! var_filterBlockIsset ) {
			if (widthBlock >= var_widthMAX) {
				widthLeftBlock = var_widthLeftBlockMAX;
				widthMainBlock = var_widthMiddleBlockOneMAX;
				var_margin = 80;
				marginRightMainBlock = var_margin;
				marginLeftMainBlock = widthLeftBlock + var_margin;
				marginLeftLeftBlock = 0;

				paddingLeftLogo = var_paddingLeftMAX;
				paddingRightSlide = var_paddingRightSlideMAX;
				paddingLeftTel = var_paddingLeftTelefonMAX;

				marginLeftContent = 0;
				widthContent = widthMainBlock - marginLeftContent;
				marginRightContent = 0;
				var_widthDescrLeft = 587;
				var_widthStreet = 'auto'
				
				paddingRightSlide += 165;

				widthAllTripInfo = 'auto';
				paddingLeftInfo = '112px';
			}
			else if (widthBlock < var_widthMAX && widthBlock >= var_widthMID) {
				widthMainBlock = Math.floor(910 + ( (widthBlock - var_widthMID) / (var_valueMAX / (935 - 910))) );
				widthLeftBlock = var_widthLeftBlockMID;
				var_margin = Math.floor(30 + ( (widthBlock - var_widthMID) / (var_valueMAX / (80 - 30))) );
				marginRightMainBlock = var_margin;
				marginLeftMainBlock = widthLeftBlock + var_margin;
				marginLeftLeftBlock = 0;

				paddingLeftLogo = var_paddingLeftMID;
				paddingRightSlide = var_paddingRightSlideMID;
				paddingLeftTel = var_paddingLeftTelefonMID;

				marginLeftContent = 0;
				widthContent = widthMainBlock - marginLeftContent;

				marginRightContent = 0;
				var_widthDescrLeft = Math.floor(557 + ((widthBlock - var_widthMID) / (var_valueMAX / (587 - 557))) );
				var_widthStreet = 'auto'
				
				paddingRightSlide += 165;
				
				//=== THERE ===//
				//widthAllTripInfo = Math.floor(var_widthMiddleBlockMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_widthMiddleBlockMID - var_widthMiddleBlockMIN))) );
				widthAllTripInfo = 'auto';
				paddingLeftInfo = '112px';
			}
			else if (widthBlock < var_widthMID && widthBlock >= var_widthMIN) {
			
				widthLeftBlock = Math.floor( (220 + ( (widthBlock - var_widthMIN) / (var_valueMIN / (var_widthLeftBlockMID - 220)))) - 3 );

				widthMainBlock = Math.floor(685 + ( (widthBlock - var_widthMIN) / (var_valueMIN / (910 - 685))) );

				var_margin = 39;
				marginRightMainBlock = var_margin;
				marginLeftMainBlock = widthLeftBlock + var_margin;
				marginLeftLeftBlock = 0;

				paddingLeftLogo = Math.floor(var_paddingLeftMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftMID - var_paddingLeftMIN))) );
				paddingRightSlide = Math.floor(var_paddingRightSlideMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingRightSlideMID - var_paddingRightSlideMIN))) );
				paddingLeftTel = Math.floor(var_paddingLeftTelefonMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftTelefonMID - var_paddingLeftTelefonMIN))) );

				marginLeftContent = 0;
				widthContent = widthMainBlock - marginLeftContent;
				marginRightContent = 0;

				var_widthDescrLeft = Math.floor(335 + ((widthBlock - var_widthMIN) / (var_valueMIN / (557 - 335))) );

				var_widthStreet = '210px';
				
				paddingRightSlide += 100;
				
				//=== THERE ===//
				widthAllTripInfo = Math.floor(585 + ((widthBlock - var_widthMIN) / (var_valueMIN / (734 - 585))) );
				widthAllTripInfo = widthAllTripInfo+'px';
				paddingLeftInfo = Math.floor(36 + ((widthBlock - var_widthMIN) / (var_valueMIN / (112 - 36))) );
			}
		}
		else {
			if (widthBlock >= var_widthMAX) {


				paddingLeftLogo = var_paddingLeftMAX;
				paddingRightSlide = var_paddingRightSlideMAX;
				paddingLeftTel = var_paddingLeftTelefonMAX;
				
				paddingRightSlide += 165;

			}
			else if (widthBlock < var_widthMAX && widthBlock >= var_widthMID) {


				paddingLeftLogo = var_paddingLeftMID;
				paddingRightSlide = var_paddingRightSlideMID;
				paddingLeftTel = var_paddingLeftTelefonMID;

				paddingRightSlide += 165;	
			}
			else if (widthBlock < var_widthMID && widthBlock >= var_widthMIN) {
				paddingLeftLogo = Math.floor(var_paddingLeftMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftMID - var_paddingLeftMIN))) );
				paddingRightSlide = Math.floor(var_paddingRightSlideMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingRightSlideMID - var_paddingRightSlideMIN))) );
				paddingLeftTel = Math.floor(var_paddingLeftTelefonMIN + ((widthBlock - var_widthMIN) / (var_valueMIN / (var_paddingLeftTelefonMID - var_paddingLeftTelefonMIN))) );
				
				paddingRightSlide += 100;
			}
		}
		if (marginLeftMainBlock != 'auto') {
				marginLeftMainBlock = marginLeftMainBlock+'px';
		}
		if (marginRightMainBlock != 'auto') {
			marginRightMainBlock = marginRightMainBlock+'px';
		}
		if (marginLeftContent != 'auto') {
			marginLeftContent = marginLeftContent +'px';
		}
		if (marginRightContent != 'auto') {
			marginRightContent = marginRightContent +'px';
		}
		if (marginRightFilterBlock != 'auto') {
			marginRightFilterBlock = marginRightFilterBlock +'px';
		}
		if (marginLeftLeftBlock != 'auto') {
			marginLeftLeftBlock = marginLeftLeftBlock +'px';
		}
		/*===*/
		if (var_mainBlockIsset) {
			
			var_mainBlock.css('width', widthMainBlock+'px').css('margin-left', marginLeftMainBlock).css('margin-right', marginRightMainBlock);
			var_content.css('width', widthContent+'px').css('margin-left', marginLeftContent).css('margin-right', marginRightContent);
			var_allTripInfo.css('width', widthAllTripInfo);
			$('.costItAll').css('padding-right', paddingLeftInfo);	
			$('.calToursInner').css('padding-right', paddingLeftInfo);		
		}
		if (var_filterBlockIsset) {
			var_filterBlock.css('width', widthFilterBlock+'px').css('margin-right', marginRightFilterBlock);			
		}
		if (var_leftBlockIsset) {
			var_leftBlock.css('width', widthLeftBlock+'px').css('margin-left', marginLeftLeftBlock);
		}
		/* CALENDARE RESIZE */
		if (var_calendarGridVoyangaIsset) {
			$('.innerCalendar, #voyanga-calendar').css('width', widthBlock+'px')
			//var_calendarGridVoyanga.css('width', (widthBlock+16)+'px');
			//$('.weekDaysVoyangaInner').css('width', (widthBlock+16)+'px');
		}
		/* END CALENDARE RESIZE */
		if (var_descrIsset) {
			//$('#descr').find('.photo-slide-hotel').css('width', var_widthDescrLeft+'px');
			$('#descr').find('.left').find(".descr-text .text").dotdotdot({watch: 'window'});
			$('#content .place-buy .street').css('width', var_widthStreet);

		}
		if ($('.description .text').length > 0 && $('.description .text').is(':visible')) {
			$(".description .text").dotdotdot({watch: 'window'});
		}
		/*===*/
		var_logoBlock.css('left', paddingLeftLogo+'px');
		var_aboutBlock.css('left', (122 + paddingLeftLogo)+'px');
		var_slideBlock.css('right', paddingRightSlide +'px');
		var_leftBlock.find('.left-content').css('margin-left', paddingLeftLogo+'px');
		var_telefonBlock.css('left', paddingLeftTel+'px');

		if (widthContent < 690) {
			var mathWidthRicket = Math.floor(253 + ((widthBlock - var_widthMIN) / (var_valueMIN / (318 - 253))) );
			$('.recommended-ticket').css('width', mathWidthRicket+'px');
			$('.recommended-ticket').find('.ticket-items').addClass('small');
			var_content.find('h1').find('.hideTitle').hide();
			var_ticketsItems.find('.ticket-items').addClass('small');
			$('.block').find('.ticket-items').addClass('small');
			var_hotelItems.addClass('small');
		}
		else {
			$('.recommended-ticket').find('.ticket-items').removeClass('small');
			$('.recommended-ticket').css('width', '318px');
			var_ticketsItems.find('.ticket-items').removeClass('small');
			$('.block').find('.ticket-items').removeClass('small');
			var_hotelItems.removeClass('small');
			var_content.find('h1').find('.hideTitle').show();
		}
        if ($('body').width() < 1000) {
            $('body').addClass('scrollYes');
        }
        else {
            $('body').removeClass('scrollYes');
        }
		resizeLeftStage();
		resizeMainStage();
	}
	$(".second-path").focus(function () {
        $(this).select();
    }).mouseup(function(e){
        e.preventDefault();
    });
    
    $('.voyasha td').hover(function() {
		$('.ico-voyasha').addClass('active');
	}, function() {
		$('.ico-voyasha').removeClass('active');
	});
}
function smallTicketHeight() {
    if ($('.recommended-ticket').length > 0 && $('.recommended-ticket').is(':visible')) {
        //console.log('!!!==== 4 ====!!!');
        var var_recomendedContent = $('.recomended-content');
        var var_recomendedItems = var_recomendedContent.find('.recommended-ticket .ticket-items .content');
        var var_oneHeight = var_recomendedItems.height();

        var heightTwoTicket= 0;
        if ($('.two-way').css('display')!=='none') {
            heightTwoTicket = (var_oneHeight - 24) / 2;
        } else {
            heightTwoTicket = (var_oneHeight - 24);
        }
        heightTwoTicket = Math.floor(heightTwoTicket);
        var_recomendedContent.find('.prices-of-3days .ticket .schedule-of-prices').css('height', heightTwoTicket +'px');
        var heightGraf = heightTwoTicket - 65;
        // fixme bzv this method itself called twice on avia result
        var scheduleElement = $('.prices-of-3days .ticket  .schedule-of-prices')[0];
        if(scheduleElement) {
            var siblings = ko.contextFor($('.prices-of-3days .ticket  .schedule-of-prices')[0]);

            siblings = siblings['$data'];
            if(siblings.graphHeight) {
            siblings.graphHeight(heightGraf);
            }
        }
    }
}

function resizeLeftStage() {
	var leftStage = $('.left-block');
	var leftWidth = leftStage.width();
	var leftDate = leftStage.find('.date');
	var startPosition = 170;
	var leftPaddingDate = 215;
	leftPaddingDate = (leftWidth - leftPaddingDate);
	if (leftPaddingDate < 75) {
		var leftPadding = leftPaddingDate / 1.3;
		leftPadding = leftPadding + 100;
	}
	else {
		leftPadding = startPosition;
	}
	if (leftPadding < 105) {
		leftStage.find('.path').css('width', '95px');
	}
	else {
		leftStage.find('.path').css('width', leftPadding+'px');
	}
	
	if (leftWidth < 250) {
		leftStage.addClass('smallBlock');	
	}
	else {
		leftStage.removeClass('smallBlock')
	}

}
function resizeMainStage() {
	var var_this = $('.prices-of-3days');

	var var_widthChange = $('.recommended-ticket').width();
	if (var_widthChange < 318) {
		var var_widthOneLi = var_widthChange / 7;
			var_widthOneLi = Math.floor(var_widthOneLi);
		var_widthChange = var_widthOneLi * 7;
		var_this.find('.schedule-of-prices').css('width', var_widthChange+'px');
		var_this.find('.schedule-of-prices li').css('width', var_widthOneLi+'px');
		var_this.css('width', var_widthChange+'px');
		var_this.find('.total-td .text').hide();
		var_this.find('.total-td').css('margin-left','-15px');
		var_this.find('.look-td').css('margin-right','-15px');
	}
	else {
		var_this.find('.schedule-of-prices').css('width', '318px');
		var_this.find('.schedule-of-prices li').css('width', '45px');
		var_this.css('width', '318px');
		var_this.find('.total-td').css('margin-left','0px');
		var_this.find('.look-td').css('margin-right','0px');
		var_this.find('.total-td .text').show();
	}

	if (var_widthChange < 290 && var_widthChange > 280) {
		var_this.find('.schedule-of-prices li').find('.price').css('left','-1px');
	}
	else if (var_widthChange < 280 && var_widthChange > 270) {
		var_this.find('.schedule-of-prices li').find('.price').css('left','-2px');
	}
	else if (var_widthChange < 270 && var_widthChange > 260) {
		var_this.find('.schedule-of-prices li').find('.price').css('left','-3px');
	}
	else if (var_widthChange < 260 && var_widthChange > 255) {
		var_this.find('.schedule-of-prices li').find('.price').css('left','-4px');
	}
	else if (var_widthChange < 255) {
		var_this.find('.schedule-of-prices li').find('.price').css('left','-5px');
	}
	else {
		var_this.find('.schedule-of-prices li').find('.price').css('left','0px');
	}
}

function ResizeAvia() {
    if(window.resizeAviaThrottle) {
	clearTimeout(window.resizeAviaThrottle);
	window.resizeAviaThrottle = null;
    }
    window.resizeAviaThrottle = setTimeout(ResizeAviaClb, 1000/30);
}

function ResizeAviaClb() {

//    if (DetectMobileQuick() )
        ResizeCenterBlock();
        inTheTwoLines();
        smallTicketHeight();
        CenterIMGResize();
        slideToursSlide();
        smallIMGresizeIndex();
        mapAllPageView();
        gradientResize();
        resizePanel();

        startIE();
}

function ResizeFun() {
    ResizeAvia();
}

$(window).load(function() {
	$(window).scroll(function(e) {
        scrollValue('avia', e);
        scrollValue('hotel', e);
        window.hotelsScrollCallback();
	});
});

function readMoreService(obj) {
	if (! $(obj).hasClass('active')) {
		$('.hideService').animate({'height':'100%'}, 300);
		$(obj).text('');
		$(obj).addClass('active');
	}
	else {
		$('.hideService').animate({'height':'34px'}, 300);
		$(obj).text('');
		$(obj).removeClass('active') 
	}
}

function mapAllPageView() {
	var _map = $('#all-hotels-map');

    if (_map.length > 0 && _map.is(':visible')) {
        //console.log('!!!==== 6 ====!!!');

        var _isset = _map.length > 0 && _map.is(':visible');
        if (_isset) {
            var _contentWidth = $('#content').width();
            var _contentHeight = $('#content').height();
            var _mainWidth = $('.main-block').width();
            var _leftBlockIsset = $('.left-block').length > 0 && $('.left-block').is(':visible');

            if (_leftBlockIsset) {
                var _marginLeftMap = ((_mainWidth - _contentWidth) / 2);

                if ($(window).height() < 670) {
                    var _windowWidth = 670;
                }
                else {
                    var _windowWidth = $(window).height();
                }
                var offset = $('#content').offset();
                $('#content').css('height', (_windowWidth - 70)+'px');
                _map.css('height', (_windowWidth - 123)+'px');
                _map.css('width', _mainWidth+'px').css('margin-left', '-'+ _marginLeftMap +'px');
            }
            else {
                if ($(window).height() < 670) {
                    var _windowWidth = 670;
                }
                else {
                    var _windowWidth = $(window).height();
                }
                var offset = $('#content').offset();
                $('#content').css('height', (_windowWidth - 70)+'px');
                _map.css('height', (_windowWidth - 123)+'px');
                _map.css('width', $(window).width()+'px').css('margin-left', '-'+ offset.left +'px');
            }

        }
    }
}

var _GoOnScroll = true;
var _jScrollingBootom = false;
var _jScrollNonBottomInitted = false;

function jsPaneScrollHeight() {
	
	var _issetMaps = $('#all-hotels-map').length > 0 && $('#all-hotels-map').is(':visible');
	var _issetLeftBlock = $('.left-block').length > 0 && $('.left-block').is(':visible');
	if (_issetMaps && ! _issetLeftBlock) {
	
	}
	else {
	
	var _content = $('#content');
	_content.css('height','auto');
	var _windowHeight = $(window).height();
	if (_windowHeight > 670) {
		_windowHeight = ($(window).height() - 132);
	}
	else {
		_windowHeight = (670 - 132);
	}
	var _contentHeight = _content.innerHeight();
	var _scrollPaneHeight = 0;
	$('.scrollBlock').find('.div-filter').each(function(e) {
		_scrollPaneHeight += $(this).innerHeight();
	});
	if (_scrollPaneHeight	> _contentHeight  &&
		_contentHeight		> _windowHeight && 
		_scrollPaneHeight 	> _windowHeight) {
		_content.css('height', _scrollPaneHeight + 'px');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = false;
	}
	else if 
		(_scrollPaneHeight	< _contentHeight  && 
		_contentHeight		> _windowHeight && 
		_scrollPaneHeight 	> _windowHeight) {
		//console.log('=== 2 ===');
		_content.css('height', 'auto');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = true;
	}
	else if 
		(_scrollPaneHeight	> _contentHeight  && 
		_contentHeight		< _windowHeight && 
		_scrollPaneHeight 	> _windowHeight) {
		//console.log('=== 3 ===');
		_content.css('height', _scrollPaneHeight + 'px');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = false;
	}
	else if 
		(_scrollPaneHeight	> _contentHeight  && 
		_contentHeight		> _windowHeight && 
		_scrollPaneHeight 	< _windowHeight) {	
		//console.log('=== 4 ===');	
		_content.css('height', _scrollPaneHeight + 'px');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = false;
	}
	else if 
		(_scrollPaneHeight	< _contentHeight  && 
		_contentHeight		< _windowHeight && 
		_scrollPaneHeight 	> _windowHeight) {	
		//console.log('=== 5 ===');
		_content.css('height', (_windowHeight - 70) + 'px');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = false;
	}
	else if 
		(_scrollPaneHeight	> _contentHeight  && 
		_contentHeight		< _windowHeight && 
		_scrollPaneHeight 	< _windowHeight) {	
		//console.log('=== 6 ===');	
		_content.css('height', (_windowHeight - 70) + 'px');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = false;
	}
	else if 
		(_scrollPaneHeight	< _contentHeight  && 
		_contentHeight		> _windowHeight && 
		_scrollPaneHeight 	< _windowHeight) {	
		//console.log('=== 7 ===');
		_content.css('height', 'auto');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = true;
	}
	else if 
		(_scrollPaneHeight	< _contentHeight  && 
		_contentHeight		< _windowHeight && 
		_scrollPaneHeight 	< _windowHeight) {	
		//console.log('=== 8 ===');
		_content.css('height', (_windowHeight - 70) + 'px');
		$('.filter-content').css('position','relative').css('top','auto').css('bottom','auto');
		$('.innerFilter').css('height', _scrollPaneHeight +'px');
		_GoOnScroll = false;	
	}
	else {
		//console.log('=== 9 ===');
		$('.innerFilter').css('height', '100%');
		_GoOnScroll = true;
	}
	//console.log("==== * * * * ====");
	
	}
}

function scrollValue(what, event) {
    if (DetectMobileQuick() || DetectTierTablet()) {
        return;
    }
    else {
        var filterContent = $('.filter-content.'+ what);
        var isScrollPane;
        if(event.target == document)
            isScrollPane = false;
        else
            isScrollPane = $(event.target).is('#scroll-pane');
        if (filterContent.length > 0 && filterContent.is(':visible') && !isScrollPane) {
            var innerFilter = filterContent.find('.innerFilter');
            var var_marginTopSubHead = $('.sub-head').css('margin-top');
            var var_scrollValueTop = $(window).scrollTop();
            var var_heightWindow = $(window).height();
            var var_heightContent = $('#content').height();

            if (what == 'avia') {
                var var_topFilterContent = 73;
                if ($('.sub-head').css('margin-top') != '-67px') {
                    var diffrentScrollTop = 173;
                }
                else {
                    var diffrentScrollTop = 110;
                }
            }
            else {
                var var_topFilterContent = 23;
                if ($('.sub-head').css('margin-top') != '-67px') {
                    var diffrentScrollTop = 125;
                }
                else {
                    var diffrentScrollTop = 61 ;
                }
            }
            if (_GoOnScroll) {
                var needDel = false;
                if (var_scrollValueTop == 0) {
                    //is del
                    needDel = true;
                    filterContent.css('position','relative').css('top','auto').css('bottom','auto');
                }
                else if (var_scrollValueTop > 0 && var_scrollValueTop < diffrentScrollTop ) {
                    needDel = true;
                    filterContent.css('position','relative').css('top','auto').css('bottom','auto');
                }
                else if (var_scrollValueTop > diffrentScrollTop) {
                    if (var_scrollValueTop > (($('.wrapper').height() - var_heightWindow) - 30)) {
                        var var_minHeightBottom;
                        filterContent.css('position','fixed').css('top','-'+var_topFilterContent+'px').css('bottom','auto');
                        if ((var_scrollValueTop - (($('.wrapper').height() - var_heightWindow) - 30)) < 30) {
                            var_minHeightBottom = (var_scrollValueTop - (($('.wrapper').height() - var_heightWindow) - 30));
                        }
                        else {
                            var_minHeightBottom = 30;
                        }
                        innerFilter.css('height', (var_heightWindow - var_minHeightBottom) +'px');
                        if(!$('#scroll-pane').data('jsp')){
                            $('#scroll-pane').jScrollPane({contentWidth: innerFilter.width()});

                        }
                        $('#scroll-pane').jScrollPane({contentWidth: innerFilter.width()});
                        if(!_jScrollingBootom && var_scrollValueTop == ($('.wrapper').height() - $('body').height())){
                            _jScrollingBootom = true;
                            window.setTimeout(function(){
                                    $('#scroll-pane').data('jsp').scrollToBottom();
                                },
                                50
                            );

                            window.setTimeout(
                                function(){
                                    _jScrollingBootom = false;
                                    _jScrollNonBottomInitted = false;
                                    //scrollValue(what, event)
                                }
                                , 500
                            );

                        }
                        //
                    }
                    else {
                        filterContent.css('position','fixed').css('top','-'+var_topFilterContent+'px').css('bottom','auto');
                        innerFilter.css('height', var_heightWindow +'px');
                        if(!$('#scroll-pane').data('jsp')){
                            $('#scroll-pane').jScrollPane({contentWidth: innerFilter.width()});
                        }
                        if(!_jScrollNonBottomInitted){
                            _jScrollNonBottomInitted = true;
                            $('#scroll-pane').jScrollPane({contentWidth: innerFilter.width()});
                            //$('#scroll-pane').data('jsp').scrollToBottom();
                        }
                    }

                }
                if(needDel){
                    if($('#scroll-pane').data('jsp')){
                        $('#scroll-pane').data('jsp').destroy();
                    }
                }
            }
            else {
                var _issetMaps = $('#all-hotels-map').length > 0 && $('#all-hotels-map').is(':visible');
                var _issetLeftBlock = $('.left-block').length > 0 && $('.left-block').is(':visible');
                if (_issetMaps && ! _issetLeftBlock) {

                }
                else {
                    if($('#scroll-pane').data('jsp')){
                        $('#scroll-pane').data('jsp').destroy();
                    }

                }
                return false;
            }
        }
        else {
            return false;
        }
    }
}

function reInitJScrollPane(){
    if($('#scroll-pane').data('jsp')){
        $('#scroll-pane').data('jsp').reinitialise();
    }
}

function minimizeFilter() {
	var _issetMaps = $('#all-hotels-map').length > 0 && $('#all-hotels-map').is(':visible');
	var _issetLeftBlock = $('.left-block').length > 0 && $('.left-block').is(':visible');
	if (_issetMaps && ! _issetLeftBlock) {
		
		$('.innerFilter').find('.div-filter').each(function(index) {
			if (index > 1) {
				$(this).hide();
			}
		});
		$('.innerFilter').css('height', '162px');
		$('.filter-block').css('height','185px');
		if ($('.filter-minimize').length > 0 && $('.filter-minimize').is(':visible')) {
			$('.filter-minimize').removeClass('hide').attr('onclick','filterShow()');
			if($('#scroll-pane').data('jsp')){
				$('#scroll-pane').data('jsp').destroy();
			}
		}
		else {
			$('.filter-content').append('<div class="filter-minimize" onclick="filterShow()"></div>');
		}
		_GoOnScroll = false;
	}
	else {
		return false;
	}
}

function filterShow() {
	$('.filter-block').css('height','100%');
	$('.innerFilter').css('height', ($('.wrapper').height() - 175)+'px');
	$('.innerFilter').find('.div-filter').show();
	_GoOnScroll = false;
	if(!$('#scroll-pane').data('jsp')){
		$('#scroll-pane').jScrollPane({contentWidth: $('.innerFilter').width()});
	}
	$('.filter-minimize').addClass('hide').attr('onclick','minimizeFilter()');
}

function removeFilterShow() {
	$('.filter-minimize').remove();
	$('.filter-block').css('height','100%');
	$('.innerFilter').css('height','100%');
	$('.innerFilter').find('.div-filter').show();
	$(window).load(function(e) {
		scrollValue('hotel', e);
	});
}

function loadPayFly() {
	var _loadPayFly = $('#loadPayFly');
    if (_loadPayFly.length > 0 && _loadPayFly.is(':visible')) {
        var offsetPayBlock = _loadPayFly.offset();
        var _widthLoadPayFly = _loadPayFly.width() - (230 + 60);
        var _loadJet = $('.loadJet');
        var _Jet = _loadJet.find('.jetFly');

        _loadJet.css('margin-left', '-'+offsetPayBlock.left+'px').css('width', (offsetPayBlock.left + _widthLoadPayFly)+'px');
        _loadJet.find('.overflowBlock').css('width', (offsetPayBlock.left + _widthLoadPayFly)+'px');
        _loadJet.find('.pathBlock').clone().prependTo('.loadJet').addClass('blue');
        _loadJet.find('.pathBlock').eq(1).attr('id','grey');

        function startFlyJet() {
            _Jet.animate({'right' : '0%'}, 20000, 'linear', function() {
                $(this).animate({'right' : '-241px'}, 4000, 'linear', function() {
                    $(this).css('right', '100%');
                });
            });
            setTimeout(function() {
                _loadJet.find('#grey').animate({'width' : '0%'}, 20000, 'linear', function() {
                    _loadJet.find('#grey').css('opacity','0').css('width', '100%');
                    setTimeout(function() {
                        _loadJet.find('#grey').animate({'opacity':'1'}, 1000, function() {
                            startFlyJet();
                        });
                    }, 4500);
                });
            }, 500);

        }

        startFlyJet();
    }
}

var clickYes = false;

function closeAllPopup() {
    closePopUpProj();
    closePopUpContact();
}

function openPopUpProj() {
    clickYes = true;
    $('.mainWrapBg').show();
    $('body').css('overflow', 'hidden');
    var _textSlideProj = $('.textSlideProj');
    var _centerImg = $('.mainWrapBg').find('.centerImg');
    var _itemsProj = $('.mainWrapBg').find('.itemsProj');
    var lenSlideProj = _textSlideProj.find('li').length;
    _centerImg.empty();
    _textSlideProj.find('li').each(function(index) {
        _centerImg.append('<img src="'+ $(this).attr('rel') +'">');
    });
    var _imgProjEq0 = _textSlideProj.find('li').eq(0).attr('rel');
    var _textProjEq0 = _textSlideProj.find('li').eq(0).html();
    $('.bgCount').empty().append('<span>1</span>/'+lenSlideProj);
    $('.mainWrapBg').find('.centerImg').find('img').hide().eq(0).show();
    _itemsProj.empty().append(_textProjEq0);
    $('.naviProj').find('.left').addClass('inactive');
    //     
    var mouseHover = true;
    $('.projectPopUp').hover(function() {
        mouseHover = false;
    },
        function() {
            mouseHover = true;
        }
    );
    $('.naviProj').hover(function() {
            mouseHover = false;
        },
        function() {
            mouseHover = true;
        }
    );
    $('.mainWrapBg').mouseup(function() {
        if (mouseHover) {
            closeAllPopup();
        }
        else {
            return;
        }
    });
    $(window).on('keydown', function(e){
        if (clickYes) {
            if (e.which == 27) {
                closeAllPopup();
            }
            else if (e.which == 39) {
                ClikRightProj();
            }
            else if (e.which == 37) {
                ClikLeftProj();
            }
            else {
                return true;
            }
        }
    });
    $('.mainWrapBg').find('.centerImg').click(function() {
        ClikRightProj();
    });
}

function closePopUpProj() {
    $('.mainWrapBg').hide();
    $('body').css('overflow', 'auto');
    clickYes = false;
}

function ClikRightProj() {

    var lenSlideProj = $('.textSlideProj').find('li').length;
    var _countSlide = $('.bgCount').find('span').text();
    if (_countSlide >= lenSlideProj) {
        return false;
    }
    else {
        _countSlide++;
        $('.naviProj').find('.left').removeClass('inactive');
        $('.naviProj').find('.right').removeClass('inactive');
    }
    $('.mainWrapBg').find('.centerImg').find('img').hide().eq(_countSlide - 1).show();
    var _textProjEq = $('.textSlideProj').find('li').eq(_countSlide - 1).html();
    $('.mainWrapBg').find('.itemsProj').empty().append(_textProjEq);
    $('.bgCount').find('span').text(_countSlide);
    if (_countSlide == lenSlideProj) {
        $('.naviProj').find('.right').addClass('inactive');
    }
}

function ClikLeftProj() {

    var _countSlide = $('.bgCount').find('span').text();
    if (_countSlide <= 1) {
        return false;
    }
    else {
        _countSlide--;
        $('.naviProj').find('.left').removeClass('inactive');
        $('.naviProj').find('.right').removeClass('inactive');
    }
    $('.mainWrapBg').find('.centerImg').find('img').hide().eq(_countSlide - 1).show();
    var _textProjEq = $('.textSlideProj').find('li').eq(_countSlide - 1).html();
    $('.mainWrapBg').find('.itemsProj').empty().append(_textProjEq);
    $('.bgCount').find('span').text(_countSlide);
    if (_countSlide == 1) {
        $('.naviProj').find('.left').addClass('inactive');
    }
}

function PopUpInfoPath() {
    $(document).on('mousemove', '.tooltip', function(e) {
        var _text = $(this).attr('rel');
        if ($('.PopUpInfoPath').length > 0 && $('.PopUpInfoPath').is(':visible')) {
            $('.PopUpInfoPath').css('left', e.pageX+'px').css('top', (e.pageY + 5)+'px');
        }
        else {
            $('body').prepend('<div class="PopUpInfoPath">'+ _text +'</div> ');
            $('.PopUpInfoPath').css('left', e.pageX+'px').css('top', (e.pageY + 5)+'px');
        }
    });
    $(document).on('mouseout', '.tooltip', function() {
        $('.PopUpInfoPath').remove();
    });
    $(document).on('mouseout', '.close', function() {
        $('.PopUpInfoPath').remove();
    });
}

$(window).load(PopUpInfoPath);

function PopUpInfo() {
    var _this = $('.tooltipClose');
    var _onHovePopUp = true;
    $(_this).click(function(e) {
        var _text = $(this).attr('rel');
        if ($('.PopUpInfo').length > 0 && $('.PopUpInfoPath').is(':visible')) {
            $('.PopUpInfo').remove();
            _onHovePopUp = true;
        }
        else {
            $('body').prepend('<div class="PopUpInfo">'+ _text +'<div class="close"></div></div> ');
            var _leftPadding;
            if (e.pageX < $('.PopUpInfo').width()) {
                _leftPadding = 5;
            }
            else {
                _leftPadding = e.pageX - 300;
            }
            $('.PopUpInfo').css('left', _leftPadding +'px').css('top', (e.pageY - 10)+'px');

        }
        $('.PopUpInfo').hover(function() {
            _onHovePopUp = false;
        }, function() {
            _onHovePopUp = true;
        });
        $('body').mouseup(function() {
            if (_onHovePopUp) {
                $('.PopUpInfo').remove();
                _onHovePopUp = true;
            }
            else {
                return false;
            }
        });
        $('.PopUpInfo').find('.close').click(function() {
            $('.PopUpInfo').remove();
            _onHovePopUp = true;
        });
        $(window).on('keydown', function(e){
            if (e.which == 27) {
                $('.PopUpInfo').remove();
                _onHovePopUp = true;
            }
        });
    });
}

$(window).load(PopUpInfo);

function openPopUpContact() {
    clickYes = true;
    $('.contentWrapBg').show();
    $('body').css('overflow', 'hidden');
    //     
    var mouseHover = true;
    $('.wrapDiv').hover(function() {
            mouseHover = false;
        },
        function() {
            mouseHover = true;
        }
    );
    $('.contentWrapBg').mouseup(function() {
        if (mouseHover) {
            closeAllPopup();
        }
        else {
            return;
        }
    });
    var scrollTopCount = $('.contentWrapBg').scrollTop();
    var heightWinAll = $(window).height();
    var heightPopAll = $('.contentWrapBg .wrapDiv').innerHeight();
    var offset = $('.contentWrapBg .wrapDiv').offset();
    var scrollMean = (heightPopAll + offset.top) - heightWinAll;
    $(window).on('keydown', function(e){
        if (clickYes) {
            if (e.which == 27) {
                closeAllPopup();
            }
            else if (e.which == 38) {
                scrollTopCount -= 15;
                if (scrollTopCount > -14) {
                    $('.contentWrapBg').scrollTop(scrollTopCount);
                }
                else {
                    scrollTopCount = 0;
                    return;
                }
            }
            else if (e.which == 40) {
                scrollTopCount += 15;
                if ((scrollMean + 15) > scrollTopCount) {
                    $('.contentWrapBg').scrollTop(scrollTopCount);
                }
                else {
                    scrollTopCount = scrollMean;
                    return;
                }
            }
            else {
                return true;
            }
        }
    });
}

function closePopUpContact() {
    $('.contentWrapBg').hide();
    $('body').css('overflow', 'auto');
    clickYes = false;
}

var scrollTrue = true;

function resizeFAQ() {
    var _marginLeftWrapFAQ;
    if ($(window).width() <= 1000) {
        _marginLeftWrapFAQ = 10;
    }
    else if ($(window).width() > 1000) {
        _marginLeftWrapFAQ = ($(window).width() - 977) / 2.615;
    }
    $('.wrapFAQ').css('margin-left', _marginLeftWrapFAQ+'px');

    $('.tableFAQ').each(function(index) {
        $('.listFAQ').find('li').eq(index).attr('rel', $(this).offset().top);
    });
    scrollFAQ();
    $('.listFAQ').find('li').find('a').click(function() {
        scrollTrue = false;
        $('.listFAQ').find('li').removeClass('active');
        $(this).parent().addClass('active');
        setTimeout(function() { scrollTrue = true; }, 650);
    });
}

function scrollFAQ() {
    if ($(window).scrollTop() > 64) {
        $('.listFAQ').css('position', 'fixed').css('top', '4px');
    }
    else {
        $('.listFAQ').css('position','absolute');
    }

    // ScrollMenu
    $('.listFAQ').find('li').each(function(index) {
       if (scrollTrue && ($(window).scrollTop() + 68) >= $(this).attr('rel')) {
           $('.listFAQ').find('li').removeClass('active');
           $(this).addClass('active');
       }
    });
}

$(window).load(resizeFAQ);
$(window).resize(resizeFAQ);
$(window).scroll(scrollFAQ);

function gradientResize() {
    if (DetectMobileQuick() || DetectTierTablet()) {
        return
    }
    else {
        if ($('.wrapper .main-block').find('#content').length > 0 && $('.wrapper .main-block').find('#content').is(':visible')) {
            var _content = $('.wrapper .main-block').find('#content');
            var offset = _content.offset();
            var _leftContent = $(window).width() - offset.left;
            var _rightContent = offset.left + _content.width();
            $('.gShR').show().css('left', (_rightContent - 180) +'px').css('width', ($(window).width() - (_rightContent - 180)) +'px');;
            $('.gShL').show().css('right', (_leftContent - 40) +'px').css('width', (offset.left + 40) +'px');
        }
        else {
            return
        }
    }
}

function openPopUpLogIn(what) {
    var _this = what;

    clickYes = true;
    if ($('.loginWrapBg').length > 0 && $('.loginWrapBg').is(':visible')) {
        $('.loginWrapBg').find('.wrapContent > div:not(.boxClose)').hide();
        $('.loginWrapBg').find('.wrapContent > div.'+_this).show();

    }
    else {
        $('.loginWrapBg').show();
        $('body').css('overflow', 'hidden');
        $('.loginWrapBg').find('.wrapContent > div:not(.boxClose)').hide();
        $('.loginWrapBg').find('.wrapContent > div.'+_this).show();
    }
    //     
    var mouseHover = true;
    $('.wrapDiv').hover(function() {
            mouseHover = false;
        },
        function() {
            mouseHover = true;
        }
    );
    $('.loginWrapBg').mouseup(function() {
        if (mouseHover) {
            closePopUpLogIn();
        }
        else {
            return;
        }
    });
    $('div.'+_this).find('input').eq(0).focus();
    var heightWinAll = $(window).height();
    var heightPopAll = $('.contentWrapBg .wrapDiv').innerHeight();
    var offset = $('.contentWrapBg .wrapDiv').offset();
    var scrollMean = (heightPopAll + offset.top) - heightWinAll;
    $(window).on('keydown', function(e){
        if (clickYes) {
            if (e.which == 27) {
                closePopUpLogIn();
            }
        }
    });

    $('.registerOpen').click(function() {
        $('.enter').fadeOut();
        $('.fogoten').fadeOut();
        $('.reapetPass').fadeOut();
        $('.registrate').fadeIn();
    });
    $('.enterOpen').click(function() {
        $('.registrate').fadeOut();
        $('.fogoten').fadeOut();
        $('.reapetPass').fadeOut();
        $('.enter').fadeIn();

    });
    $('.fogotenOpen').click(function() {
        $('.registrate').fadeOut();
        $('.enter').fadeOut();
        $('.reapetPass').fadeOut();
        $('.fogoten').fadeIn();
    });
}

function closePopUpLogIn() {
    $('.loginWrapBg').hide();
    $('body').css('overflow', 'auto');
    clickYes = false;
}

function hoverPayCard() {
    $('.paycard > div').hover(function() {
        $(this).find('.black').animate({'opacity': 0},400);
        $(this).find('.color').animate({'opacity': 1},400);
    }, function() {
        $(this).find('.black').animate({'opacity': 1},300);
        $(this).find('.color').animate({'opacity': 0},300);
    });
}

$(window).load(hoverPayCard);

//functions for private space popups
$(function(){
    $('.btnEnterLogin').on('click', function(){
        $('#login-errors').html('').hide();
        $.ajax({
            url: '/user/validate',
            dataType: 'json',
            data: $('#login-form').serialize(),
            type: 'POST'
        })
            .done(function(response){
                if (response.status != 'ok')
                {
                    $('#login-errors').html(' /').show();
                }
                else
                {
                    $('#login-form').submit();
                }
            })
            .error(function(){
                $('#login-errors').html('   /.').show()
            });
        return false;
    });
});

$(function(){
    $('.btnFogLogin').on('click', function(){
        $('#forget-errors').html('').hide();
        $.ajax({
            url: '/user/validateForgetPassword',
            dataType: 'json',
            data: $('#forget-pwd-form').serialize(),
            type: 'POST'
        })
            .done(function(response){
                if (response.status != 'ok')
                {
                    $('#forget-errors').html(response.errors).show();
                }
                else
                {
                    $.ajax({
                        url: '/user/newPassword',
                        data: $('#forget-pwd-form').serialize(),
                        type: 'POST'
                    })
                        .done(function(){
                            $('#forget-pwd-form')
                                .html('       e-mail');
                        })
                        .error(function(){
                            $('#forget-errors').html('   .').show()
                        });
                }
            })
            .error(function(){
                $('#forget-errors').html('   .').show()
            });
        return false;
    });
})

$(function(){
    $('.btnRegLogin').on('click', function(){
        $('#signup-errors').html('').hide();
        $.ajax({
            url: '/user/signup',
            dataType: 'json',
            data: $('#signup-form').serialize(),
            type: 'POST'
        })
            .done(function(response){
                if (response.status != 'ok')
                {
                    $('#signup-errors').html(response.error).show();
                }
                else
                {
                    $('#signup-form')
                        .html('           ');
                }
            })
            .error(function(){
                $('#signup-errors').html('  .').show()
            });
        return false;
    });
})

$(function(){
    $('.btnNewPwd').on('click', function(){
        $('#new-pwd-errors').html('').hide();
        $.ajax({
            url: '/user/newPassword/key/' + window.pwdKey,
            dataType: 'json',
            data: $('#new-pwd-form').serialize(),
            type: 'POST'
        })
            .done(function(response){
                if (response.status != 'ok')
                {
                    $('#new-pwd-errors').html(response.errors).show();
                }
                else
                {
                    $('#new-pwd-form')
                        .html('  ');
                }
            })
            .error(function(){
                $('#new-pwd-form').html('    ').show()
            });
        return false;
    });
});

function resizePanel(arg) {

        //console.log('!!!==== 7 ====!!!');
        $('.panelTable').each(function(index){

            var _panelTable = $(this);//$('.panel').last().find('.panelTable');
            var _classThis;
            var _midWidth = 1130;
            var _minWidth = 1000;
            var _newMean;

            var _allWidthPanel, _midWidthPanel, _maxWidthPanel;
            //_panelTable.find('.tdPeople').css('width', 'auto');

            if (_panelTable.hasClass('avia')) {
                _classThis = 'avia';
                var _meanPanel = 850;
                var _standartData = 290;
                var _widthTdTumblr = _panelTable.find('.tdTumblr').innerWidth();
                var _widthTdPeople = _panelTable.find('.tdPeople').innerWidth();
                var _widthTdButton = _panelTable.find('.tdButton').innerWidth();
                var _widthTdCityStart = _panelTable.find('.tdCityStart').innerWidth();;
                var _widthTdAddTour = 0;
                var _howManyInput = 2;
            }  else if (_panelTable.hasClass('constructorTable')) {
                _classThis = 'constructorTable';
                if ($(this).find('.tdPeople').hasClass('notFinal')) {
                    $(this).find('.tdPeople.notFinal').css('width', $('.tdPeople.final').width()+'px');
                }
                else if ($(this).find('.tdPeople').hasClass('final')) {
                    //$(this).find('.tdPeople.final').css('width', 'auto');
                }
                var _meanPanel = 692;
                var _widthTdTumblr = 0;
                var _widthTdPeople = _panelTable.find('.tdPeople').innerWidth();
                var _widthTdButton = _panelTable.find('.tdButton').innerWidth();
                var _widthTdCityStart = _panelTable.find('.tdCityStart').innerWidth();
                var _widthTdAddTour = _panelTable.find('.tdAddTour').innerWidth();
                var _howManyInput = 1;
            }  else if (_panelTable.hasClass('hotel')) {
                _classThis = 'hotel';
                var _meanPanel = 692;
                var _widthTdTumblr = 0;
                var _widthTdPeople = _panelTable.find('.tdPeople').innerWidth();
                var _widthTdButton = _panelTable.find('.tdButton').innerWidth();
                var _widthTdCityStart = _panelTable.find('.tdCityStart').innerWidth();
                var _widthTdAddTour = 117;
                var _howManyInput = 1;
            }

            var _windowWidth = $(window).width();
            var _widthPanelTable = _panelTable.innerWidth();

            var _dataDiv = _panelTable.find('.tdCity').find('.data');
            var _dataInput = _panelTable.find('.tdCity').find('.data').find('input');

            if (_windowWidth <= _midWidth && _windowWidth >= _minWidth) {
                _allWidthPanel = _windowWidth - 230;
            }
            else if (_windowWidth < _minWidth) {
                _allWidthPanel = 1000 - 230;
            }
            else {
                _allWidthPanel = 900;
            }

            if (_widthPanelTable >= _allWidthPanel) {
                _newMean = (_allWidthPanel - _widthTdTumblr - _widthTdPeople - _widthTdButton - _widthTdCityStart - _widthTdAddTour) / _howManyInput;
            }
            else if (_widthPanelTable < _allWidthPanel) {
                _newMean = (_allWidthPanel - _widthTdTumblr - _widthTdPeople - _widthTdButton - _widthTdCityStart - _widthTdAddTour) / _howManyInput;
            }
            else {
                _newMean = (_widthPanelTable - _widthTdTumblr - _widthTdPeople - _widthTdButton - _widthTdCityStart - _widthTdAddTour) / _howManyInput;
            }

            _panelTable.find('.tdCity').find('.data').css('width', _newMean +'px');
            _panelTable.find('.tdCity').find('.data').find('input').css('width', (_newMean-20) +'px');
            _widthPanelTable = _panelTable.innerWidth();
        });
}

function startIE() {
    if($.browser.msie)
    {
        $(document).on('click', '.data', function() {
            $(this).find('.second-path').focus();
        });
    }
}/**
 * Created with JetBrains PhpStorm.
 * User: oleg
 * Date: 29.08.12
 * Time: 20:13
 * To change this template use File | Settings | File Templates.
 */
/*!
 * jQuery Color Animations v@VERSION
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: @DATE
 */
(function( jQuery, undefined ) {

    var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

    // plusequals test for += 100 -= 100
        rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
    // a set of RE's that can match strings and generate color tuples.
        stringParsers = [{
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            parse: function( execResult ) {
                return [
                    execResult[ 1 ],
                    execResult[ 2 ],
                    execResult[ 3 ],
                    execResult[ 4 ]
                ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            parse: function( execResult ) {
                return [
                    execResult[ 1 ] * 2.55,
                    execResult[ 2 ] * 2.55,
                    execResult[ 3 ] * 2.55,
                    execResult[ 4 ]
                ];
            }
        }, {
            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function( execResult ) {
                return [
                    parseInt( execResult[ 1 ], 16 ),
                    parseInt( execResult[ 2 ], 16 ),
                    parseInt( execResult[ 3 ], 16 )
                ];
            }
        }, {
            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function( execResult ) {
                return [
                    parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
                    parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
                    parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
                ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function( execResult ) {
                return [
                    execResult[ 1 ],
                    execResult[ 2 ] / 100,
                    execResult[ 3 ] / 100,
                    execResult[ 4 ]
                ];
            }
        }],

    // jQuery.Color( )
        color = jQuery.Color = function( color, green, blue, alpha ) {
            return new jQuery.Color.fn.parse( color, green, blue, alpha );
        },
        spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },

            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        },
        propTypes = {
            "byte": {
                floor: true,
                max: 255
            },
            "percent": {
                max: 1
            },
            "degrees": {
                mod: 360,
                floor: true
            }
        },
        support = color.support = {},

    // element for support tests
        supportElem = jQuery( "<p>" )[ 0 ],

    // colors = jQuery.Color.names
        colors,

    // local aliases of functions called often
        each = jQuery.each;

// determine rgba support immediately
    supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
    support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
    each( spaces, function( spaceName, space ) {
        space.cache = "_" + spaceName;
        space.props.alpha = {
            idx: 3,
            type: "percent",
            def: 1
        };
    });

    function clamp( value, prop, allowEmpty ) {
        var type = propTypes[ prop.type ] || {};

        if ( value == null ) {
            return (allowEmpty || !prop.def) ? null : prop.def;
        }

        // ~~ is an short way of doing floor for positive numbers
        value = type.floor ? ~~value : parseFloat( value );

        // IE will pass in empty strings as value for alpha,
        // which will hit this case
        if ( isNaN( value ) ) {
            return prop.def;
        }

        if ( type.mod ) {
            // we add mod before modding to make sure that negatives values
            // get converted properly: -10 -> 350
            return (value + type.mod) % type.mod;
        }

        // for now all property types without mod have min and max
        return 0 > value ? 0 : type.max < value ? type.max : value;
    }

    function stringParse( string ) {
        var inst = color(),
            rgba = inst._rgba = [];

        string = string.toLowerCase();

        each( stringParsers, function( i, parser ) {
            var parsed,
                match = parser.re.exec( string ),
                values = match && parser.parse( match ),
                spaceName = parser.space || "rgba";

            if ( values ) {
                parsed = inst[ spaceName ]( values );

                // if this was an rgba parse the assignment might happen twice
                // oh well....
                inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
                rgba = inst._rgba = parsed._rgba;

                // exit each( stringParsers ) here because we matched
                return false;
            }
        });

        // Found a stringParser that handled it
        if ( rgba.length ) {

            // if this came from a parsed string, force "transparent" when alpha is 0
            // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
            if ( rgba.join() === "0,0,0,0" ) {
                jQuery.extend( rgba, colors.transparent );
            }
            return inst;
        }

        // named colors
        return colors[ string ];
    }

    color.fn = jQuery.extend( color.prototype, {
        parse: function( red, green, blue, alpha ) {
            if ( red === undefined ) {
                this._rgba = [ null, null, null, null ];
                return this;
            }
            if ( red.jquery || red.nodeType ) {
                red = jQuery( red ).css( green );
                green = undefined;
            }

            var inst = this,
                type = jQuery.type( red ),
                rgba = this._rgba = [],
                source;

            // more than 1 argument specified - assume ( red, green, blue, alpha )
            if ( green !== undefined ) {
                red = [ red, green, blue, alpha ];
                type = "array";
            }

            if ( type === "string" ) {
                return this.parse( stringParse( red ) || colors._default );
            }

            if ( type === "array" ) {
                each( spaces.rgba.props, function( key, prop ) {
                    rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
                });
                return this;
            }

            if ( type === "object" ) {
                if ( red instanceof color ) {
                    each( spaces, function( spaceName, space ) {
                        if ( red[ space.cache ] ) {
                            inst[ space.cache ] = red[ space.cache ].slice();
                        }
                    });
                } else {
                    each( spaces, function( spaceName, space ) {
                        var cache = space.cache;
                        each( space.props, function( key, prop ) {

                            // if the cache doesn't exist, and we know how to convert
                            if ( !inst[ cache ] && space.to ) {

                                // if the value was null, we don't need to copy it
                                // if the key was alpha, we don't need to copy it either
                                if ( key === "alpha" || red[ key ] == null ) {
                                    return;
                                }
                                inst[ cache ] = space.to( inst._rgba );
                            }

                            // this is the only case where we allow nulls for ALL properties.
                            // call clamp with alwaysAllowEmpty
                            inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
                        });

                        // everything defined but alpha?
                        if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
                            // use the default of 1
                            inst[ cache ][ 3 ] = 1;
                            if ( space.from ) {
                                inst._rgba = space.from( inst[ cache ] );
                            }
                        }
                    });
                }
                return this;
            }
        },
        is: function( compare ) {
            var is = color( compare ),
                same = true,
                inst = this;

            each( spaces, function( _, space ) {
                var localCache,
                    isCache = is[ space.cache ];
                if (isCache) {
                    localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
                    each( space.props, function( _, prop ) {
                        if ( isCache[ prop.idx ] != null ) {
                            same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
                            return same;
                        }
                    });
                }
                return same;
            });
            return same;
        },
        _space: function() {
            var used = [],
                inst = this;
            each( spaces, function( spaceName, space ) {
                if ( inst[ space.cache ] ) {
                    used.push( spaceName );
                }
            });
            return used.pop();
        },
        transition: function( other, distance ) {
            var end = color( other ),
                spaceName = end._space(),
                space = spaces[ spaceName ],
                startColor = this.alpha() === 0 ? color( "transparent" ) : this,
                start = startColor[ space.cache ] || space.to( startColor._rgba ),
                result = start.slice();

            end = end[ space.cache ];
            each( space.props, function( key, prop ) {
                var index = prop.idx,
                    startValue = start[ index ],
                    endValue = end[ index ],
                    type = propTypes[ prop.type ] || {};

                // if null, don't override start value
                if ( endValue === null ) {
                    return;
                }
                // if null - use end
                if ( startValue === null ) {
                    result[ index ] = endValue;
                } else {
                    if ( type.mod ) {
                        if ( endValue - startValue > type.mod / 2 ) {
                            startValue += type.mod;
                        } else if ( startValue - endValue > type.mod / 2 ) {
                            startValue -= type.mod;
                        }
                    }
                    result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
                }
            });
            return this[ spaceName ]( result );
        },
        blend: function( opaque ) {
            // if we are already opaque - return ourself
            if ( this._rgba[ 3 ] === 1 ) {
                return this;
            }

            var rgb = this._rgba.slice(),
                a = rgb.pop(),
                blend = color( opaque )._rgba;

            return color( jQuery.map( rgb, function( v, i ) {
                return ( 1 - a ) * blend[ i ] + a * v;
            }));
        },
        toRgbaString: function() {
            var prefix = "rgba(",
                rgba = jQuery.map( this._rgba, function( v, i ) {
                    return v == null ? ( i > 2 ? 1 : 0 ) : v;
                });

            if ( rgba[ 3 ] === 1 ) {
                rgba.pop();
                prefix = "rgb(";
            }

            return prefix + rgba.join() + ")";
        },
        toHslaString: function() {
            var prefix = "hsla(",
                hsla = jQuery.map( this.hsla(), function( v, i ) {
                    if ( v == null ) {
                        v = i > 2 ? 1 : 0;
                    }

                    // catch 1 and 2
                    if ( i && i < 3 ) {
                        v = Math.round( v * 100 ) + "%";
                    }
                    return v;
                });

            if ( hsla[ 3 ] === 1 ) {
                hsla.pop();
                prefix = "hsl(";
            }
            return prefix + hsla.join() + ")";
        },
        toHexString: function( includeAlpha ) {
            var rgba = this._rgba.slice(),
                alpha = rgba.pop();

            if ( includeAlpha ) {
                rgba.push( ~~( alpha * 255 ) );
            }

            return "#" + jQuery.map( rgba, function( v, i ) {

                // default to 0 when nulls exist
                v = ( v || 0 ).toString( 16 );
                return v.length === 1 ? "0" + v : v;
            }).join("");
        },
        toString: function() {
            return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
        }
    });
    color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

    function hue2rgb( p, q, h ) {
        h = ( h + 1 ) % 1;
        if ( h * 6 < 1 ) {
            return p + (q - p) * h * 6;
        }
        if ( h * 2 < 1) {
            return q;
        }
        if ( h * 3 < 2 ) {
            return p + (q - p) * ((2/3) - h) * 6;
        }
        return p;
    }

    spaces.hsla.to = function ( rgba ) {
        if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
            return [ null, null, null, rgba[ 3 ] ];
        }
        var r = rgba[ 0 ] / 255,
            g = rgba[ 1 ] / 255,
            b = rgba[ 2 ] / 255,
            a = rgba[ 3 ],
            max = Math.max( r, g, b ),
            min = Math.min( r, g, b ),
            diff = max - min,
            add = max + min,
            l = add * 0.5,
            h, s;

        if ( min === max ) {
            h = 0;
        } else if ( r === max ) {
            h = ( 60 * ( g - b ) / diff ) + 360;
        } else if ( g === max ) {
            h = ( 60 * ( b - r ) / diff ) + 120;
        } else {
            h = ( 60 * ( r - g ) / diff ) + 240;
        }

        if ( l === 0 || l === 1 ) {
            s = l;
        } else if ( l <= 0.5 ) {
            s = diff / add;
        } else {
            s = diff / ( 2 - add );
        }
        return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
    };

    spaces.hsla.from = function ( hsla ) {
        if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
            return [ null, null, null, hsla[ 3 ] ];
        }
        var h = hsla[ 0 ] / 360,
            s = hsla[ 1 ],
            l = hsla[ 2 ],
            a = hsla[ 3 ],
            q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
            p = 2 * l - q,
            r, g, b;

        return [
            Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
            Math.round( hue2rgb( p, q, h ) * 255 ),
            Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
            a
        ];
    };


    each( spaces, function( spaceName, space ) {
        var props = space.props,
            cache = space.cache,
            to = space.to,
            from = space.from;

        // makes rgba() and hsla()
        color.fn[ spaceName ] = function( value ) {

            // generate a cache for this space if it doesn't exist
            if ( to && !this[ cache ] ) {
                this[ cache ] = to( this._rgba );
            }
            if ( value === undefined ) {
                return this[ cache ].slice();
            }

            var ret,
                type = jQuery.type( value ),
                arr = ( type === "array" || type === "object" ) ? value : arguments,
                local = this[ cache ].slice();

            each( props, function( key, prop ) {
                var val = arr[ type === "object" ? key : prop.idx ];
                if ( val == null ) {
                    val = local[ prop.idx ];
                }
                local[ prop.idx ] = clamp( val, prop );
            });

            if ( from ) {
                ret = color( from( local ) );
                ret[ cache ] = local;
                return ret;
            } else {
                return color( local );
            }
        };

        // makes red() green() blue() alpha() hue() saturation() lightness()
        each( props, function( key, prop ) {
            // alpha is included in more than one space
            if ( color.fn[ key ] ) {
                return;
            }
            color.fn[ key ] = function( value ) {
                var vtype = jQuery.type( value ),
                    fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
                    local = this[ fn ](),
                    cur = local[ prop.idx ],
                    match;

                if ( vtype === "undefined" ) {
                    return cur;
                }

                if ( vtype === "function" ) {
                    value = value.call( this, cur );
                    vtype = jQuery.type( value );
                }
                if ( value == null && prop.empty ) {
                    return this;
                }
                if ( vtype === "string" ) {
                    match = rplusequals.exec( value );
                    if ( match ) {
                        value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
                    }
                }
                local[ prop.idx ] = value;
                return this[ fn ]( local );
            };
        });
    });

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
    color.hook = function( hook ) {
        var hooks = hook.split( " " );
        each( hooks, function( i, hook ) {
            jQuery.cssHooks[ hook ] = {
                set: function( elem, value ) {
                    var parsed, curElem,
                        backgroundColor = "";

                    if ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) {
                        value = color( parsed || value );
                        if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
                            curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                            while (
                                (backgroundColor === "" || backgroundColor === "transparent") &&
                                    curElem && curElem.style
                                ) {
                                try {
                                    backgroundColor = jQuery.css( curElem, "backgroundColor" );
                                    curElem = curElem.parentNode;
                                } catch ( e ) {
                                }
                            }

                            value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
                                backgroundColor :
                                "_default" );
                        }

                        value = value.toRgbaString();
                    }
                    try {
                        elem.style[ hook ] = value;
                    } catch( value ) {
                        // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                    }
                }
            };
            jQuery.fx.step[ hook ] = function( fx ) {
                if ( !fx.colorInit ) {
                    fx.start = color( fx.elem, hook );
                    fx.end = color( fx.end );
                    fx.colorInit = true;
                }
                jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
            };
        });

    };

    color.hook( stepHooks );

    jQuery.cssHooks.borderColor = {
        expand: function( value ) {
            var expanded = {};

            each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
                expanded[ "border" + part + "Color" ] = value;
            });
            return expanded;
        }
    };

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
    colors = jQuery.Color.names = {
        // 4.1. Basic color keywords
        aqua: "#00ffff",
        black: "#000000",
        blue: "#0000ff",
        fuchsia: "#ff00ff",
        gray: "#808080",
        green: "#008000",
        lime: "#00ff00",
        maroon: "#800000",
        navy: "#000080",
        olive: "#808000",
        purple: "#800080",
        red: "#ff0000",
        silver: "#c0c0c0",
        teal: "#008080",
        white: "#ffffff",
        yellow: "#ffff00",

        // 4.2.3. transparent color keyword
        transparent: [ null, null, null, 0 ],

        _default: "#ffffff"
    };

})( jQuery );function SizeBox(id) {
	var popup = $('#' + id);
	if ($('#' + id).length > 0 && $('#' + id).is(':visible')) {
		$('body').css('overflow','hidden');
	}
}

function ResizeBox(id) {
	var popup = $('#'+id);
	var layer = popup.find('#layer');
	
	var winWidth = $(window).width();
	var winHeight = $(window).height()
	var pvCont = popup.find('.pv_cont');
	var pvContHeight = pvCont.height();
	var paddingTopPopUp = (winHeight - pvContHeight) / 2;
	if (paddingTopPopUp <= 10) {
		paddingTopPopUp = 10;
	}	
	popup.css('width', winWidth+'px');
	layer.css('width', (winWidth-16)+'px');
	pvCont.css('padding-top', paddingTopPopUp+'px');
	
	$(window).resize(function() {
		var winWidth = $(window).width();
		var winHeight = $(window).height()
		var pvCont = popup.find('.pv_cont');
		var pvContHeight = pvCont.height();
		var paddingTopPopUp = (winHeight - pvContHeight) / 2;
		if (paddingTopPopUp <= 10) {
			paddingTopPopUp = 10;
		}	
		popup.css('width', winWidth+'px');
		layer.css('width', (winWidth-16)+'px');
		pvCont.css('padding-top', paddingTopPopUp+'px');
	});
}
function btnClosePopUp() {
	$('body').css('overflow','auto');
}

$(document).ready(function() {
    return;
	var text4 = $('#popup').html();


	$('a#popuphotel').click(function(e) {
		e.preventDefault();
		LinkDone();
		$('a.photo').click(function(e) {
			e.preventDefault();
			createPhotoBox(this);
		});
	});
});
function resizePhotoWinHandler() {
    console.log('kk');
    var var_height = $('#imgContent').height();
    var var_width = $('#imgContent img').innerWidth();
    var var_allWinWidth = $(window).width();
    var var_allWinHeight = $(window).height();
    var paddingLeft = (var_allWinWidth - var_width) / 2;
    var paddingTop = ((var_allWinHeight - (var_height + 84)) - 78) / 2;
    if (paddingTop < 0) {
        paddingTop = 0;
    }
    paddingTop = Math.round(paddingTop);
    
    $('.countAndClose').css('width', var_width+'px');
        //$('#imgContent').css('margin-top', paddingTop+'px');
        //$('#titleNamePhoto').css('height', (paddingTop+50)+'px');
        //$('#photoBox').animate({'width':'100%'},10);
    //console.log('pddingtop:',paddingTop,' allwin:',var_allWinHeight,'h:',var_height);
}

function resizePhotoWin() {
    console.log('try start');
    var src = $('#body-popup-Photo img').attr('src');
    var img = new Image;
 
    //$(img).bind('load error',resizePhotoWinHandler);
    //resizePhotoWinHandler();
    img.src = src;
}

function resizeLoad() {
    var var_width = $('#hotel-img-load').width();
    var var_height = $('#hotel-img-load').height();
    var var_allWinWidth = $(window).width();
    var var_allWinHeight = $(window).height();
    var paddingLeft = (var_allWinWidth - var_width) / 2;
    var paddingTop = (var_allWinHeight - var_height) / 2;
    if (paddingTop < 0) {
	paddingTop = 0;
    }
    $('#hotel-img-load').css('left', (paddingLeft-20)+'px').css('top', (paddingTop - 20)+'px');
}

$(window).resize(function() {
	//resizePhotoWin();
    resizeLoad();
});var var_marginHowLong = 20;
var var_marginHowLongSmall = 5;
var var_paddingDateTime = 15;

var MAX_BIG_CITY_NAME_SMALL_TICKET = 16;
var MAX_BIG_CITY_NAME = 16;
var MAX_BIG_AIRPORT_NAME_SMALL_TICKET = 16;
var MAX_BIG_AIRPORT_NAME = 16;

var MIN_BIG_CITY_NAME_SMALL_TICKET = 12;
var MIN_BIG_CITY_NAME = 12;
var MIN_BIG_AIRPORT_NAME_SMALL_TICKET = 12;
var MIN_BIG_AIRPORT_NAME = 12;

function minimizeListTime() {

}

//      !
function inTheTwoLines() {
	var var_otherTime = $('.recommended-ticket .ticket-items .other-time');

    if (var_otherTime.length > 0 && var_otherTime.is(':visible')) {
//        if (DetectMobileQuick() && var_iphone < 3) {
            //console.log('!!!==== 1 ====!!!');
            var_otherTime.each(function() {
                var var_lengthLI = $(this).find('ul.minimize li').length;
                var var_heightUL = $(this).find('ul.minimize').height();
                if (var_heightUL > 30 && var_heightUL < 40) {
                    $(this).find('.variation').css('margin-top', '0px');
                }
                else if (var_heightUL > 40) {
                    $(this).find('.variation').css('margin-top', '0px');
                    var var_paddingTop = ($(this).height() - 40) / 2;

                    $(this).find('.left').css('top', var_paddingTop+'px');
                    $(this).find('.right').css('top', var_paddingTop+'px');
                }
                else {
                    $(this).find('.variation').css('margin-top', '10px');
                }
                for (i = 0; i < var_lengthLI; i++) {
                    var var_LI = $(this).find('ul.minimize li').eq(i);
                    if (var_LI.hasClass('active') == true && i == 1) {
                        $(this).find('.left').addClass('none');
                        }
                    else if (var_LI.hasClass('active') == true && i == (var_lengthLI - 1)) {
                        $(this).find('.right').addClass('none');
                    }
                }
            });
//            var_iphone++;
//        }
    }
}


function hideRecomendedBlockTicket() {
    if (!$(this).hasClass('show')) {
        $('.recomended-content').slideUp(function () {
            jsPaneScrollHeight();
        });
        $(this).addClass('show');
    }
    else {
        $(this).removeClass('show');
        $('.recomended-content').slideDown(function () {
            jsPaneScrollHeight();
        });

        $(window).load(inTheTwoLines);
        setTimeout(smallTicketHeight, 100);

    }
}
$(function () {
    bindActions = function () {
        $('.minimize-rcomended .btn-minimizeRecomended').click(function () {
        });
        $('.order-show').click(function () {
            $('.recomended-content').slideDown();
            $('.minimize-rcomended .btn-minimizeRecomended').animate({top: '-19px'}, 500);
            $(window).load(inTheTwoLines);

            otherTimeSlide();
            widthHowLong();
            setTimeout(smallTicketHeight, 100);
        });
        $('.descr').eq(1).hide();
        $('.place-buy .tmblr li a').click(function (e) {
            e.preventDefault();
            if (!$(this).hasClass('active')) {
                var var_nameBlock = $(this).attr('href');
                var_nameBlock = var_nameBlock.slice(1);
                $('.place-buy .tmblr li').removeClass('active');
                $(this).parent().addClass('active');
                $('.descr').hide();
                $('#' + var_nameBlock).show();
            }
        });
        $('.read-more').click(function () {
            if (!$(this).hasClass('active')) {
                $(this).prev().css('height', 'auto');
                $('#descr').find('.left').find(".descr-text .text").dotdotdot({watch: 'window'});
                $(this).addClass('active').text('');
            }
            else {
                $(this).prev().css('height', '54px');
                $('#descr').find('.left').find(".descr-text .text").dotdotdot({watch: 'window'});
                $(this).removeClass('active').text('');
            }
        });
        $('.stars-li input').each(function () {
            if ($(this).attr('checked') == 'checked') {
                $(this).next().addClass('active');
            }
        });
        $('.stars-li label').click(function () {
            if (!$(this).hasClass('active')) {
                $(this).addClass('active');
            }
            else {
                $(this).removeClass('active');
            }
        });
        var heCal = $('.calendarSlide').height();
        $('.calendarSlide').css('top', '-' + heCal + 'px');

        $('.input-path').click(function () {
            $('.calendarSlide').animate({'top': '0px'}, 400);
        });

        /*          ! */
        $('.cityStart .to a').click(function () {
            var var_parent = $(this).parent().parent();
            var var_parentUp = var_parent.parent();
            var_parentUp.find('.from').addClass('overflow').animate({'width': '125px'}, 300);
            var_parent.find('.startInputTo').show();
            var_parent.animate({'width': '261px'}, 300, function () {
                var_parent.find('.startInputTo').find('input').focus();
            });
        });
        $('.board-content .from input').click(function () {
            if ($(this).parent().hasClass('overflow')) {
                $(this).parent().animate({'width': '271px'}, 300, function () {
                    $(this).removeClass('overflow');
                });
                $('.cityStart').animate({'width': '115px'}, 300);
                $('.cityStart').find('.startInputTo').animate({'opacity': '1'}, 300, function () {
                    $(this).hide();
                });
            }
        });
    }
});

function deletePopUp(obj) {
    var _this = $(obj);
    var pos = _this.offset();
    $('body').prepend('<div class="deletePopUp">?</div>');
    $('.deletePopUp').css('top', (pos.top - 28) + 'px').css('left', (pos.left - 6) + 'px');
}
function deletePopUpHide() {
    $('.deletePopUp').remove();
}

function telefonLoad() {
    if ($('#contactPhone').length > 0 && $('#contactPhone').is(':visible')) {
        $('#contactPhone').mask('+7 (999) 999-99-99');
    }
    else {
        return
    }

    if ($('.allTicketsDIV .ticketBox').length > 0 && $('.allTicketsDIV .ticketBox').is(':visible')) {
        var _ticketBoxLen = $('.allTicketsDIV .ticketBox').length;
        if (_ticketBoxLen == 1) {
            $('.allTicketsDIV .ticketBox').addClass('first-child').addClass('last-child');
        }
        else {
            for (i = 0; i < _ticketBoxLen; i++) {
                if (i == 0) {
                    $('.allTicketsDIV .ticketBox').eq(i).addClass('first-child');
                }
                else if (i == (_ticketBoxLen - 1)) {
                    $('.allTicketsDIV .ticketBox').eq(i).addClass('last-child');
                }
                else {
                    return true;
                }
            }
        }
    }
    else {
        return;
    }

    $('.infoPassengers:eq(0) tbody .tdName:eq(0) input').focus(function () {
        Utils.scrollTo('#tableStartRun');
    });
}
$(window).load(telefonLoad);


function onFocusInput() {
    if ($('.male input').attr('checked') == 'checked') {
        $('.male input').closest('label').addClass('active');
    }
    if ($('.female input').attr('checked') == 'checked') {
        $('.female input').closest('label').addClass('active');
    }
    $('.male input').focus(function () {
        $(this).parent().addClass('focus');
        var _that = this;
        $(window).unbind('keypress');
        $(window).bind('keypress', function(e) {
            if (e.which == 9 && $(_that).attr('checked') == 'checked') {
                $(_that).parent().parent().next().find('input.dd').focus();
            }
            else if (e.which == 9 && $(_that).attr('checked') != 'checked') {
                $('.female input').focus();
            }
            else if (e.which == 32) {
                $('.male').removeClass('active error');
                $('.female').removeClass('active error');
                $(_that).parent().addClass('active');
                $(_that).parent().parent().next().find('input.dd').focus();
                $(_that).attr('checked','checked');
            }
        });
    });
    $('.male input').blur(function () {
        $(this).parent().removeClass('focus');
        $(this).removeAttr('disabled');
        $('.female input').removeAttr('disabled');
    });
    $('.male input').change(function () {
        if ($(this).attr('checked') == 'checked') {
            $(this).parent().addClass('active');
            $('.female').removeClass('active error');
        }
        else {
            $(this).parent().removeClass('active');
        }
    });
    $('.female input').focus(function () {
        $(this).parent().addClass('focus');
        var _that = this;
        $(window).unbind('keypress');
        $(window).bind('keypress', function(e) {
            if (e.which == 9 && $(_that).attr('checked') == 'checked') {
                $(_that).parent().parent().next().find('input.dd').focus();
            }
            else if (e.which == 9 && $(_that).attr('checked') != 'checked') {
                $(_that).parent().parent().next().find('input.dd').focus();
            }
            else if (e.which == 32) {
                $('.male').removeClass('active error');
                $('.female').removeClass('active error');
                $(_that).parent().addClass('active');
                $(_that).parent().parent().next().find('input.dd').focus();
                $(_that).attr('checked','checked');
            }
        });
    });
    $('.female input').blur(function () {
        $(this).parent().removeClass('focus');
        $(this).removeAttr('disabled');
        $('.male input').removeAttr('disabled');
    });
    $('.female input').change(function () {
        if ($(this).attr('checked') == 'checked') {
            $(this).parent().addClass('active');
            $('.male').removeClass('active error');
        }
        else {
            $(this).parent().removeClass('active');
        }
    });
}
$(window).load(onFocusInput);

function showUserMenu() {

    $('.popupDown').slideDown(200, function() {
        $('.login-window').attr('onclick',' ');
    });
    //     
    var mouseHover = true;

    $('.popupDown').hover(function () {
            mouseHover = false;
        },
        function () {
            mouseHover = true;
        }
    );
    $('body').mouseup(function () {
        if (mouseHover) {
            console.log(mouseHover);
            $('.popupDown').slideUp(100, function() {
                $('.login-window').attr('onclick','showUserMenu()');
            });
        }
        else {
            return false;
        }
    });
}

function hideFromCityInput(event) {
    var _targetYes = event.target;
    if (!$(_targetYes).parents('.cityStart').length > 0) {
    var elB, elem, elemB, startInput, toInput;
    if (!$('.startInputTo').is(':visible')) {
        return;
    }
    elemB = $('.cityStart').find('.second-path');
    elB = elemB.closest('.cityStart');
    elB.closest('.tdCityStart').animate({
        width: '-=130',
        300: 300
    });
    elB.closest('.tdCityStart').find('.bgInput').animate({
        width: '-=150',
        300: 300
    });
    elB.closest('.tdCityStart').next().find('.data').animate({
        width: '+=130',
        300: 300
    });
    elem = $('.startInputTo .second-path');
    startInput = $('div.startInputTo');
    toInput = $('div.overflow');
    if (startInput.is(':visible')) {
        toInput.animate({
            width: "271px"
        }, 300, function () {
            return toInput.removeClass("overflow");
        });
        $(".cityStart").animate({
            width: "115px"
        }, 300);
        return startInput.animate({
            opacity: "1"
        }, 300, function () {
            return startInput.hide();
        });
    }
    }
    else {
        return true;
    }
}

$(function () {
    $('html').on('click', function (e) {
        hideFromCityInput(e);
    });
});

function nextSlideDownRules(_this) {
    if ($(_this).hasClass('active')) {
        $(_this).next().slideUp();
    }
    else {
        $(_this).next().slideDown();
        $(_this).addClass('active')
    }

}

function getLink() {
    $('body').click(function(e) {
        if ($(e.target).parents('#followLink').length > 0) {
            $('#followLink').find('.text').hide();
            $('#followLink').find('.getLink').show();
        }
        else {
            $('#followLink').find('.text').show();
            $('#followLink').find('.getLink').hide();
        }
    });
}
$(window).load(getLink);/**
 * Created with JetBrains PhpStorm.
 * User: oleg
 * Date: 29.08.12
 * Time: 16:33
 * To change this template use File | Settings | File Templates.
 */
(function ($) {
    $.selectSlider = {
        init: function (obj,options) {
            var _this = $(obj);
            var mainClass = _this.attr('class');
            _this.data('options',options);
            _this.hide();
            var aOptions = Array();
            var selectDiv = $(
                '<div class="' + mainClass + ' jsslidecheckbox"><div class="slidecheckbox">' +
                    '<ul class="selectList" />' +
                    '<div class="switch"><i class="left"></i><i class="right"></i></div>'+
                    '<i class="left"></i><i class="right"></i>'+
                '</div></div>'
            );
            selectDiv.data('select',_this);
            _this.data('selectDiv',selectDiv);
            var elementWidth = 100/_this.find('option').length;
            selectDiv.data('elementWidth',elementWidth);
            selectDiv.find('.switch').css('width',elementWidth+'%');
            //console.log(elementWidth);
            _this.find('option').each(function (index) {
                var listElement = $('<li><a href="#" onclick="return false">' + $(this).text() + '</a></li>');
                listElement.data('original_option',$(this));
                listElement.data('ind',index);
                listElement.data('option-value', $(this).val());
                listElement.css('width',selectDiv.data('elementWidth')+'%');
                listElement.click(function () {
                    //listElement.css('width',selectDiv.data('elementWidth')+'%');
                    var oldVal = _this.val();
                    if(oldVal != listElement.data('option-value')){
                        _this.val(listElement.data('option-value'));
                        selectDiv.find('.switch').animate({'left':selectDiv.data('elementWidth')*listElement.data('ind') + '%'});
                        selectDiv.data('active').find('a').css('text-shadow','none');
                        selectDiv.data('active').find('a').animate({
                                'color': '#2e333b'//,
                                //'text-shadow': '0px 1px 0px #FFF'
                            },
                            function() {
                                //console.log('old');
                                //console.log(this);
                                $(this).css('text-shadow', '0px 1px 0px #FFF');
                            }
                        );
                        selectDiv.data('active').removeClass('active');
                        listElement.find('a').css('text-shadow','none');
                        listElement.find('a').animate({
                                'color': 'white'//,
                                //'text-shadow': '0px 1px 0px #0b5b88'
                            },
                            function() {
                                //console.log('new');
                                //console.log(this);
                                $(this).css('text-shadow', '0px 1px 0px #0b5b88');
                                $(this).parent().addClass('active');
                                _this.change();
                            }
                        );
                        //console.log(listElement);
                        selectDiv.data('active',listElement);

                    }
                });
                /*listElement.bind('mouseenter',function () {
                    $(this).addClass('hover');
                });
                listElement.bind('mouseleave',function () {
                    $(this).removeClass('hover');
                });*/
                selectDiv.find('.selectList').append(listElement);

                if(listElement.data('original_option').filter(':selected').length > 0) {
                    //$('.'+ mainClass + '.currentItem', replacement).text($(this).text());
                    listElement.addClass('active');
                    selectDiv.data('active',listElement);
                    selectDiv.find('.switch').css('left',selectDiv.data('elementWidth')*listElement.data('ind') + '%');
                }
            });
            _this.after(selectDiv);
            //console.log(options);

        },
        reSize: function (obj) {
            $(this).show();
            var thisWidth = $(this)[0].clientWidth;
            var thisHeight = $(this)[0].clientHeight;
        }
    }
    $.fn.selectSlider = function (action,options) {
        if(typeof action == 'string'){

        }else{
            options = action;
            var defaultOptions = {kg:'am'};
            options = $.extend({},defaultOptions,options);
            $(this).each(function () {
                $.selectSlider.init(this,options);
            });
        }

    }
})(jQuery);/**
 * jQuery syncTranslit plugin
 *
 * Copyright (c) 2009 Snitko Roman
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * @author 	Roman Snitko snowcore.net@gmail.com
 * @link http://snowcore.net/
 * @version 0.0.7
 */
;(function($){
    $.fn.syncTranslit = function(options) {
        var opts = $.extend({}, $.fn.syncTranslit.defaults, options);
        return this.each(function() {
            $this = $(this);
            var o = $.meta ? $.extend({}, opts, $this.data()) : opts;
            var $destination = $('#' + opts.destination);
            o.destinationObject = $destination;
            
            // IE always sucks :)
            if (!Array.indexOf) {
                Array.prototype.indexOf = function(obj) {
                    for (var i = 0; i < this.length; i++) {
                        if (this[i] == obj) {
                            return i;
                        }
                    }
                    return -1;
                }
            }
            
            $this.keyup(function(){            	
            	var str = $(this).val();
            	var result = '';
            	for (var i = 0; i < str.length; i++) {
            		result += $.fn.syncTranslit.transliterate(str.charAt(i), o);
            	}
            	var regExp = new RegExp('[' + o.urlSeparator + ']{2,}', 'g');
            	result = result.replace(regExp, o.urlSeparator);
            	$destination.val(result);              	   	
            })
        });
    };
    
    /**
     * Transliterate character
     * @param {String} character
     * @param {Object} opts
     */
    $.fn.syncTranslit.transliterate = function(character, opts) {
    	var charIsLowerCase = true, trChar;
    	if (character.toLowerCase() != character) {
    		charIsLowerCase = false;
    	}
    	
    	character = character.toLowerCase();
    	
    	var index = opts.dictOriginal.indexOf(character);
    	if (index == -1) {
    		trChar = character;
    	} else {
    		trChar = opts.dictTranslate[index];
    	}
    	
    	if (opts.type == 'url') {
	    	var code = trChar.charCodeAt(0);
	    	if (code >= 33  && code <= 47 && code != 45
	    		|| code >= 58  && code <= 64
	    		|| code >= 91  && code <= 96
	    		|| code >= 123 && code <= 126
	    		|| code >= 1072
	    	) {
	    		return '';
	    	}
	    	if (trChar == ' ' || trChar == '-') {
	    		return opts.urlSeparator;
	    	}
    	}
    	
    	if (opts.caseStyle == 'upper') {
    		return trChar.toUpperCase();
    	} else if (opts.caseStyle == 'normal') {
    		if (charIsLowerCase) {
    			return trChar.toLowerCase();
    		} else {
    			return trChar.toUpperCase();
    		}
    	}
	    return trChar;
    };
    
    /**
     * Default options
     */
    $.fn.syncTranslit.defaults = {
        /**
         * Dictionaries
         */
        dictOriginal:  ['', '', '', '', '', '',
                        '', '', '', '', '', '',
                        '', '', '', '', '', '',
                        '', '', '', '', '', '',
                        '', '', '', '', '', '',
                        '', '', '',
                        '', '', '', ''
                        ],
        dictTranslate: ['a', 'b', 'v', 'g', 'd', 'e',
                        'e', 'zh','z', 'i', 'j', 'k',
                        'l', 'm', 'n', 'o', 'p', 'r',
                        's', 't', 'u', 'f', 'h', 'ts',
                        'ch','sh','sch', '', 'y', '',
                        'e', 'ju', 'ja',
                        'i', 'je', 'ji', 'g'
                        ],
        
        /*
         * Case transformation: normal, lower, upper
         */
        caseStyle: 'lower',
        
        /*
         * Words separator in url
         */
        urlSeparator: ' ',
        
        /*
         * Transliteration type: raw or url
         *    url - used for transliterating text into url slug
         *    raw - raw transliteration (with special characters)
         */
        type: 'raw'
    };
})(jQuery);/**
 * jquery.slider - Slider ui control in jQuery
 * 
 * Written by
 * Egor Khmelev (hmelyoff@gmail.com)
 *
 * Licensed under the MIT (MIT-LICENSE.txt).
 *
 * @author Egor Khmelev
 * @version 1.1.0-RELEASE ($Id$)
 * 
 * Dependencies
 * 
 * jQuery (http://jquery.com)
 * jquery.numberformatter (http://code.google.com/p/jquery-numberformatter/)
 * tmpl (http://ejohn.org/blog/javascript-micro-templating/)
 * jquery.dependClass
 * draggable
 * 
 **/
var Hashtable=function(){function c(b){var d;if(typeof b=="string")return b;if(typeof b.hashCode==a)return d=b.hashCode(),typeof d=="string"?d:c(d);if(typeof b.toString==a)return b.toString();try{return String(b)}catch(e){return Object.prototype.toString.call(b)}}function d(a,b){return a.equals(b)}function e(b,c){return typeof c.equals==a?c.equals(b):b===c}function f(a){return function(b){if(b===null)throw new Error("null is not a valid "+a);if(typeof b=="undefined")throw new Error(a+" must not be undefined")}}function i(a,b,c,d){this[0]=a,this.entries=[],this.addEntry(b,c),d!==null&&(this.getEqualityFunction=function(){return d})}function m(a){return function(b){var c=this.entries.length,d,e=this.getEqualityFunction(b);while(c--){d=this.entries[c];if(e(b,d[0]))switch(a){case j:return!0;case k:return d;case l:return[c,d[1]]}}return!1}}function n(a){return function(b){var c=b.length;for(var d=0,e=this.entries.length;d<e;++d)b[c+d]=this.entries[d][a]}}function o(a,b){var c=a.length,d;while(c--){d=a[c];if(b===d[0])return c}return null}function p(a,b){var c=a[b];return c&&c instanceof i?c:null}function q(d,e){var f=this,j=[],k={},l=typeof d==a?d:c,m=typeof e==a?e:null;this.put=function(a,b){g(a),h(b);var c=l(a),d,e,f=null;return d=p(k,c),d?(e=d.getEntryForKey(a),e?(f=e[1],e[1]=b):d.addEntry(a,b)):(d=new i(c,a,b,m),j[j.length]=d,k[c]=d),f},this.get=function(a){g(a);var b=l(a),c=p(k,b);if(c){var d=c.getEntryForKey(a);if(d)return d[1]}return null},this.containsKey=function(a){g(a);var b=l(a),c=p(k,b);return c?c.containsKey(a):!1},this.containsValue=function(a){h(a);var b=j.length;while(b--)if(j[b].containsValue(a))return!0;return!1},this.clear=function(){j.length=0,k={}},this.isEmpty=function(){return!j.length};var n=function(a){return function(){var b=[],c=j.length;while(c--)j[c][a](b);return b}};this.keys=n("keys"),this.values=n("values"),this.entries=n("getEntries"),this.remove=function(a){g(a);var c=l(a),d,e=null,f=p(k,c);return f&&(e=f.removeEntryForKey(a),e!==null&&(f.entries.length||(d=o(j,c),b(j,d),delete k[c]))),e},this.size=function(){var a=0,b=j.length;while(b--)a+=j[b].entries.length;return a},this.each=function(a){var b=f.entries(),c=b.length,d;while(c--)d=b[c],a(d[0],d[1])},this.putAll=function(b,c){var d=b.entries(),e,g,h,i,j=d.length,k=typeof c==a;while(j--)e=d[j],g=e[0],h=e[1],k&&(i=f.get(g))&&(h=c(g,i,h)),f.put(g,h)},this.clone=function(){var a=new q(d,e);return a.putAll(f),a}}var a="function",b=typeof Array.prototype.splice==a?function(a,b){a.splice(b,1)}:function(a,b){var c,d,e;if(b===a.length-1)a.length=b;else{c=a.slice(b+1),a.length=b;for(d=0,e=c.length;d<e;++d)a[b+d]=c[d]}},g=f("key"),h=f("value"),j=0,k=1,l=2;return i.prototype={getEqualityFunction:function(b){return typeof b.equals==a?d:e},getEntryForKey:m(k),getEntryAndIndexForKey:m(l),removeEntryForKey:function(a){var c=this.getEntryAndIndexForKey(a);return c?(b(this.entries,c[0]),c[1]):null},addEntry:function(a,b){this.entries[this.entries.length]=[a,b]},keys:n(0),values:n(1),getEntries:function(a){var b=a.length;for(var c=0,d=this.entries.length;c<d;++c)a[b+c]=this.entries[c].slice(0)},containsKey:m(j),containsValue:function(a){var b=this.entries.length;while(b--)if(a===this.entries[b][1])return!0;return!1}},q}();(function(a){function i(a,b,c){this.dec=a,this.group=b,this.neg=c}function j(){for(var a=0;a<h.length;a++){localeGroup=h[a];for(var c=0;c<localeGroup.length;c++)b.put(localeGroup[c],a)}}function k(a,c){b.size()==0&&j();var d=".",e=",",f="-";c==0&&(a.indexOf("_")!=-1?a=a.split("_")[1].toLowerCase():a.indexOf("-")!=-1&&(a=a.split("-")[1].toLowerCase()));var h=b.get(a);if(h){var k=g[h];k&&(d=k[0],e=k[1])}return new i(d,e,f)}var b=new Hashtable,c=["ae","au","ca","cn","eg","gb","hk","il","in","jp","sk","th","tw","us"],d=["at","br","de","dk","es","gr","it","nl","pt","tr","vn"],e=["cz","fi","fr","ru","se","pl"],f=["ch"],g=[[".",","],[",","."],[","," "],[".","'"]],h=[c,d,e,f];a.fn.formatNumber=function(b,c,d){return this.each(function(){c==null&&(c=!0),d==null&&(d=!0);var e;a(this).is(":input")?e=new String(a(this).val()):e=new String(a(this).text());var f=a.formatNumber(e,b);c&&(a(this).is(":input")?a(this).val(f):a(this).text(f));if(d)return f})},a.formatNumber=function(b,c){var c=a.extend({},a.fn.formatNumber.defaults,c),d=k(c.locale.toLowerCase(),c.isFullLocale),e=d.dec,f=d.group,g=d.neg,h="0#-,.",i="",j=!1;for(var l=0;l<c.format.length;l++){if(h.indexOf(c.format.charAt(l))!=-1){if(l==0&&c.format.charAt(l)=="-"){j=!0;continue}break}i+=c.format.charAt(l)}var m="";for(var l=c.format.length-1;l>=0;l--){if(h.indexOf(c.format.charAt(l))!=-1)break;m=c.format.charAt(l)+m}c.format=c.format.substring(i.length),c.format=c.format.substring(0,c.format.length-m.length);var n=new Number(b);return a._formatNumber(n,c,m,i,j)},a._formatNumber=function(b,c,d,e,f){var c=a.extend({},a.fn.formatNumber.defaults,c),g=k(c.locale.toLowerCase(),c.isFullLocale),h=g.dec,i=g.group,j=g.neg,l=!1;if(isNaN(b)){if(c.nanForceZero!=1)return null;b=0,l=!0}d=="%"&&(b*=100);var m="";if(c.format.indexOf(".")>-1){var n=h,o=c.format.substring(c.format.lastIndexOf(".")+1);if(c.round==1)b=new Number(b.toFixed(o.length));else{var p=b.toString();p=p.substring(0,p.lastIndexOf(".")+o.length+1),b=new Number(p)}var q=b%1,r=new String(q.toFixed(o.length));r=r.substring(r.lastIndexOf(".")+1);for(var s=0;s<o.length;s++){if(o.charAt(s)=="#"&&r.charAt(s)!="0"){n+=r.charAt(s);continue}if(o.charAt(s)=="#"&&r.charAt(s)=="0"){var t=r.substring(s);if(t.match("[1-9]")){n+=r.charAt(s);continue}break}o.charAt(s)=="0"&&(n+=r.charAt(s))}m+=n}else b=Math.round(b);var u=Math.floor(b);b<0&&(u=Math.ceil(b));var v="";c.format.indexOf(".")==-1?v=c.format:v=c.format.substring(0,c.format.indexOf("."));var w="";if(u!=0||v.substr(v.length-1)!="#"||l){var x=new String(Math.abs(u)),y=9999;v.lastIndexOf(",")!=-1&&(y=v.length-v.lastIndexOf(",")-1);var z=0;for(var s=x.length-1;s>-1;s--)w=x.charAt(s)+w,z++,z==y&&s!=0&&(w=i+w,z=0);if(v.length>w.length){var A=v.indexOf("0");if(A!=-1){var B=v.length-A,C=v.length-w.length-1;while(w.length<B){var D=v.charAt(C);D==","&&(D=i),w=D+w,C--}}}}return!w&&v.indexOf("0",v.length-1)!==-1&&(w="0"),m=w+m,b<0&&f&&e.length>0?e=j+e:b<0&&(m=j+m),c.decimalSeparatorAlwaysShown||m.lastIndexOf(h)==m.length-1&&(m=m.substring(0,m.length-1)),m=e+m+d,m},a.fn.parseNumber=function(b,c,d){c==null&&(c=!0),d==null&&(d=!0);var e;a(this).is(":input")?e=new String(a(this).val()):e=new String(a(this).text());var f=a.parseNumber(e,b);if(f){c&&(a(this).is(":input")?a(this).val(f.toString()):a(this).text(f.toString()));if(d)return f}},a.parseNumber=function(b,c){var c=a.extend({},a.fn.parseNumber.defaults,c),d=k(c.locale.toLowerCase(),c.isFullLocale),e=d.dec,f=d.group,g=d.neg,h="1234567890.-";while(b.indexOf(f)>-1)b=b.replace(f,"");b=b.replace(e,".").replace(g,"-");var i="",j=!1;if(b.charAt(b.length-1)=="%"||c.isPercentage==1)j=!0;for(var l=0;l<b.length;l++)h.indexOf(b.charAt(l))>-1&&(i+=b.charAt(l));var m=new Number(i);if(j){m/=100;var n=i.indexOf(".");if(n!=-1){var o=i.length-n-1;m=m.toFixed(o+2)}else m=m.toFixed(i.length-1)}return m},a.fn.parseNumber.defaults={locale:"us",decimalSeparatorAlwaysShown:!1,isPercentage:!1,isFullLocale:!1},a.fn.formatNumber.defaults={format:"#,###.00",locale:"us",decimalSeparatorAlwaysShown:!1,nanForceZero:!0,round:!0,isFullLocale:!1},Number.prototype.toFixed=function(b){return a._roundNumber(this,b)},a._roundNumber=function(a,b){var c=Math.pow(10,b||0),d=String(Math.round(a*c)/c);if(b>0){var e=d.indexOf(".");e==-1?(d+=".",e=0):e=d.length-(e+1);while(e<b)d+="0",e++}return d}})(jQuery),function(){var a={};this.tmpl=function b(c,d){var e=/\W/.test(c)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+c.replace(/[\r\t\n]/g," ").split("<%").join("\t").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("\t").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):a[c]=a[c]||b(document.getElementById(c).innerHTML);return d?e(d):e}}(),function(a){a.baseClass=function(b){return b=a(b),b.get(0).className.match(/([^ ]+)/)[1]},a.fn.addDependClass=function(b,c){var d={delimiter:c?c:"-"};return this.each(function(){var c=a.baseClass(this);c&&a(this).addClass(c+d.delimiter+b)})},a.fn.removeDependClass=function(b,c){var d={delimiter:c?c:"-"};return this.each(function(){var c=a.baseClass(this);c&&a(this).removeClass(c+d.delimiter+b)})},a.fn.toggleDependClass=function(b,c){var d={delimiter:c?c:"-"};return this.each(function(){var c=a.baseClass(this);c&&(a(this).is("."+c+d.delimiter+b)?a(this).removeClass(c+d.delimiter+b):a(this).addClass(c+d.delimiter+b))})}}(jQuery),function(a){function b(){this._init.apply(this,arguments)}b.prototype.oninit=function(){},b.prototype.events=function(){},b.prototype.onmousedown=function(){this.ptr.css({position:"absolute"})},b.prototype.onmousemove=function(a,b,c){this.ptr.css({left:b,top:c})},b.prototype.onmouseup=function(){},b.prototype.isDefault={drag:!1,clicked:!1,toclick:!0,mouseup:!1},b.prototype._init=function(){if(arguments.length>0){this.ptr=a(arguments[0]),this.outer=a(".draggable-outer"),this.is={},a.extend(this.is,this.isDefault);var b=this.ptr.offset();this.d={left:b.left,top:b.top,width:this.ptr.width(),height:this.ptr.height()},this.oninit.apply(this,arguments),this._events()}},b.prototype._getPageCoords=function(a){return a.targetTouches&&a.targetTouches[0]?{x:a.targetTouches[0].pageX,y:a.targetTouches[0].pageY}:{x:a.pageX,y:a.pageY}},b.prototype._bindEvent=function(a,b,c){var d=this;this.supportTouches_?a.get(0).addEventListener(this.events_[b],c,!1):a.bind(this.events_[b],c)},b.prototype._events=function(){var b=this;this.supportTouches_=a.browser.webkit&&navigator.userAgent.indexOf("Mobile")!=-1,this.events_={click:this.supportTouches_?"touchstart":"click",down:this.supportTouches_?"touchstart":"mousedown",move:this.supportTouches_?"touchmove":"mousemove",up:this.supportTouches_?"touchend":"mouseup"},this._bindEvent(a(document),"move",function(a){b.is.drag&&(a.stopPropagation(),a.preventDefault(),b._mousemove(a))}),this._bindEvent(a(document),"down",function(a){b.is.drag&&(a.stopPropagation(),a.preventDefault())}),this._bindEvent(a(document),"up",function(a){b._mouseup(a)}),this._bindEvent(this.ptr,"down",function(a){return b._mousedown(a),!1}),this._bindEvent(this.ptr,"up",function(a){b._mouseup(a)}),this.ptr.find("a").click(function(){b.is.clicked=!0;if(!b.is.toclick)return b.is.toclick=!0,!1}).mousedown(function(a){return b._mousedown(a),!1}),this.events()},b.prototype._mousedown=function(b){this.is.drag=!0,this.is.clicked=!1,this.is.mouseup=!1;var c=this.ptr.offset(),d=this._getPageCoords(b);this.cx=d.x-c.left,this.cy=d.y-c.top,a.extend(this.d,{left:c.left,top:c.top,width:this.ptr.width(),height:this.ptr.height()}),this.outer&&this.outer.get(0)&&this.outer.css({height:Math.max(this.outer.height(),a(document.body).height()),overflow:"hidden"}),this.onmousedown(b)},b.prototype._mousemove=function(a){this.is.toclick=!1;var b=this._getPageCoords(a);this.onmousemove(a,b.x-this.cx,b.y-this.cy)},b.prototype._mouseup=function(b){var c=this;this.is.drag&&(this.is.drag=!1,this.outer&&this.outer.get(0)&&(a.browser.mozilla?this.outer.css({overflow:"hidden"}):this.outer.css({overflow:"visible"}),a.browser.msie&&a.browser.version=="6.0"?this.outer.css({height:"100%"}):this.outer.css({height:"auto"})),this.onmouseup(b))},window.Draggable=b}(jQuery),function(a){function b(a){return typeof a=="undefined"?!1:a instanceof Array||!(a instanceof Object)&&Object.prototype.toString.call(a)=="[object Array]"||typeof a.length=="number"&&typeof a.splice!="undefined"&&typeof a.propertyIsEnumerable!="undefined"&&!a.propertyIsEnumerable("splice")?!0:!1}function d(){return this.init.apply(this,arguments)}function e(){Draggable.apply(this,arguments)}a.jslider=function(b,c){var e=a(b);return e.data("jslider")||e.data("jslider",new d(b,c)),e.data("jslider")},a.fn.jslider=function(c,d){function g(a){return a!==undefined}function h(a){return a!=null}var e,f=arguments;return this.each(function(){var i=a.jslider(this,c);if(typeof c=="string")switch(c){case"value":if(g(f[1])&&g(f[2])){var j=i.getPointers();h(j[0])&&h(f[1])&&(j[0].set(f[1]),j[0].setIndexOver()),h(j[1])&&h(f[2])&&(j[1].set(f[2]),j[1].setIndexOver())}else if(g(f[1])){var j=i.getPointers();h(j[0])&&h(f[1])&&(j[0].set(f[1]),j[0].setIndexOver())}else e=i.getValue();break;case"prc":if(g(f[1])&&g(f[2])){var j=i.getPointers();h(j[0])&&h(f[1])&&(j[0]._set(f[1]),j[0].setIndexOver()),h(j[1])&&h(f[2])&&(j[1]._set(f[2]),j[1].setIndexOver())}else if(g(f[1])){var j=i.getPointers();h(j[0])&&h(f[1])&&(j[0]._set(f[1]),j[0].setIndexOver())}else e=i.getPrcValue();break;case"calculatedValue":var k=i.getValue().split(";");e="";for(var l=0;l<k.length;l++)e+=(l>0?";":"")+i.nice(k[l]);break;case"skin":i.setSkin(f[1])}else!c&&!d&&(b(e)||(e=[]),e.push(i))}),b(e)&&e.length==1&&(e=e[0]),e||this};var c={settings:{from:1,to:10,step:1,smooth:!0,limits:!0,round:0,format:{format:"#,##0.##"},value:"5;7",dimension:""},className:"jslider",selector:".jslider-",template:tmpl('<span class="<%=className%>"><table><tr><td><div class="<%=className%>-bg"><i class="l"></i><i class="r"></i><i class="v"></i></div><div class="<%=className%>-pointer"></div><div class="<%=className%>-pointer <%=className%>-pointer-to"></div><div class="<%=className%>-label"><span><%=settings.from%></span></div><div class="<%=className%>-label <%=className%>-label-to"><span><%=settings.to%></span><%=settings.dimension%></div><div class="<%=className%>-value"><span></span><%=settings.dimension%></div><div class="<%=className%>-value <%=className%>-value-to"><span></span><%=settings.dimension%></div><div class="<%=className%>-scale"><%=scale%></div></td></tr></table></span>')};d.prototype.init=function(b,d){this.settings=a.extend(!0,{},c.settings,d?d:{}),this.inputNode=a(b).hide(),this.settings.interval=this.settings.to-this.settings.from,this.settings.value=this.inputNode.attr("value"),this.settings.calculate&&a.isFunction(this.settings.calculate)&&(this.nice=this.settings.calculate),this.settings.onstatechange&&a.isFunction(this.settings.onstatechange)&&(this.onstatechange=this.settings.onstatechange),this.is={init:!1},this.o={},this.create()},d.prototype.onstatechange=function(){},d.prototype.create=function(){var b=this;this.domNode=a(c.template({className:c.className,settings:{from:this.nice(this.settings.from),to:this.nice(this.settings.to),dimension:this.settings.dimension},scale:this.generateScale()})),this.inputNode.after(this.domNode),this.drawScale(),this.settings.skin&&this.settings.skin.length>0&&this.setSkin(this.settings.skin),this.sizes={domWidth:this.domNode.width(),domOffset:this.domNode.offset()},a.extend(this.o,{pointers:{},labels:{0:{o:this.domNode.find(c.selector+"value").not(c.selector+"value-to")},1:{o:this.domNode.find(c.selector+"value").filter(c.selector+"value-to")}},limits:{0:this.domNode.find(c.selector+"label").not(c.selector+"label-to"),1:this.domNode.find(c.selector+"label").filter(c.selector+"label-to")}}),a.extend(this.o.labels[0],{value:this.o.labels[0].o.find("span")}),a.extend(this.o.labels[1],{value:this.o.labels[1].o.find("span")}),b.settings.value.split(";")[1]||(this.settings.single=!0,this.domNode.addDependClass("single")),b.settings.limits||this.domNode.addDependClass("limitless"),this.domNode.find(c.selector+"pointer").each(function(a){var c=b.settings.value.split(";")[a];if(c){b.o.pointers[a]=new e(this,a,b);var d=b.settings.value.split(";")[a-1];d&&new Number(c)<new Number(d)&&(c=d),c=c<b.settings.from?b.settings.from:c,c=c>b.settings.to?b.settings.to:c,b.o.pointers[a].set(c,!0)}}),this.o.value=this.domNode.find(".v"),this.is.init=!0,a.each(this.o.pointers,function(a){b.redraw(this)}),function(b){a(window).resize(function(){b.onresize()})}(this)},d.prototype.setSkin=function(a){this.skin_&&this.domNode.removeDependClass(this.skin_,"_"),this.domNode.addDependClass(this.skin_=a,"_")},d.prototype.setPointersIndex=function(b){a.each(this.getPointers(),function(a){this.index(a)})},d.prototype.getPointers=function(){return this.o.pointers},d.prototype.generateScale=function(){if(this.settings.scale&&this.settings.scale.length>0){var a="",b=this.settings.scale,c=Math.round(100/(b.length-1)*10)/10;for(var d=0;d<b.length;d++)a+='<span style="left: '+d*c+'%">'+(b[d]!="|"?"<ins>"+b[d]+"</ins>":"")+"</span>";return a}return""},d.prototype.drawScale=function(){this.domNode.find(c.selector+"scale span ins").each(function(){a(this).css({marginLeft:-a(this).outerWidth()/2})})},d.prototype.onresize=function(){var b=this;this.sizes={domWidth:this.domNode.width(),domOffset:this.domNode.offset()},a.each(this.o.pointers,function(a){b.redraw(this)})},d.prototype.update=function(){this.onresize(),this.drawScale()},d.prototype.limits=function(a,b){if(!this.settings.smooth){var c=this.settings.step*100/this.settings.interval;a=Math.round(a/c)*c}var d=this.o.pointers[1-b.uid];return d&&b.uid&&a<d.value.prc&&(a=d.value.prc),d&&!b.uid&&a>d.value.prc&&(a=d.value.prc),a<0&&(a=0),a>100&&(a=100),Math.round(a*10)/10},d.prototype.redraw=function(a){if(!this.is.init)return!1;this.setValue(),this.o.pointers[0]&&this.o.pointers[1]&&this.o.value.css({left:this.o.pointers[0].value.prc+"%",width:this.o.pointers[1].value.prc-this.o.pointers[0].value.prc+"%"}),this.o.labels[a.uid].value.html(this.nice(a.value.origin)),this.redrawLabels(a)},d.prototype.redrawLabels=function(a){function b(a,b,d){return b.margin=-b.label/2,label_left=b.border+b.margin,label_left<0&&(b.margin-=label_left),b.border+b.label/2>c.sizes.domWidth?(b.margin=0,b.right=!0):b.right=!1,a.o.css({left:d+"%",marginLeft:b.margin,right:"auto"}),b.right&&a.o.css({left:"auto",right:0}),b}var c=this,d=this.o.labels[a.uid],e=a.value.prc,f={label:d.o.outerWidth(),right:!1,border:e*this.sizes.domWidth/100};if(!this.settings.single){var g=this.o.pointers[1-a.uid],h=this.o.labels[g.uid];switch(a.uid){case 0:f.border+f.label/2>h.o.offset().left-this.sizes.domOffset.left?(h.o.css({visibility:"hidden"}),h.value.html(this.nice(g.value.origin)),d.o.css({visibility:"visible"}),e=(g.value.prc-e)/2+e,g.value.prc!=a.value.prc&&(d.value.html(this.nice(a.value.origin)+"&nbsp;&ndash;&nbsp;"+this.nice(g.value.origin)),f.label=d.o.outerWidth(),f.border=e*this.sizes.domWidth/100)):h.o.css({visibility:"visible"});break;case 1:f.border-f.label/2<h.o.offset().left-this.sizes.domOffset.left+h.o.outerWidth()?(h.o.css({visibility:"hidden"}),h.value.html(this.nice(g.value.origin)),d.o.css({visibility:"visible"}),e=(e-g.value.prc)/2+g.value.prc,g.value.prc!=a.value.prc&&(d.value.html(this.nice(g.value.origin)+"&nbsp;&ndash;&nbsp;"+this.nice(a.value.origin)),f.label=d.o.outerWidth(),f.border=e*this.sizes.domWidth/100)):h.o.css({visibility:"visible"})}}f=b(d,f,e);if(h){var f={label:h.o.outerWidth(),right:!1,border:g.value.prc*this.sizes.domWidth/100};f=b(h,f,g.value.prc)}this.redrawLimits()},d.prototype.redrawLimits=function(){if(this.settings.limits){var a=[!0,!0];for(key in this.o.pointers)if(!this.settings.single||key==0){var b=this.o.pointers[key],c=this.o.labels[b.uid],d=c.o.offset().left-this.sizes.domOffset.left,e=this.o.limits[0];d<e.outerWidth()&&(a[0]=!1);var e=this.o.limits[1];d+c.o.outerWidth()>this.sizes.domWidth-e.outerWidth()&&(a[1]=!1)}for(var f=0;f<a.length;f++)a[f]?this.o.limits[f].fadeIn("fast"):this.o.limits[f].fadeOut("fast")}},d.prototype.setValue=function(){var a=this.getValue();this.inputNode.attr("value",a),this.onstatechange.call(this,a)},d.prototype.getValue=function(){if(!this.is.init)return!1;var b=this,c="";return a.each(this.o.pointers,function(a){this.value.prc!=undefined&&!isNaN(this.value.prc)&&(c+=(a>0?";":"")+b.prcToValue(this.value.prc))}),c},d.prototype.getPrcValue=function(){if(!this.is.init)return!1;var b=this,c="";return a.each(this.o.pointers,function(a){this.value.prc!=undefined&&!isNaN(this.value.prc)&&(c+=(a>0?";":"")+this.value.prc)}),c},d.prototype.prcToValue=function(a){if(this.settings.heterogeneity&&this.settings.heterogeneity.length>0){var b=this.settings.heterogeneity,c=0,d=this.settings.from;for(var e=0;e<=b.length;e++){if(b[e])var f=b[e].split("/");else var f=[100,this.settings.to];f[0]=new Number(f[0]),f[1]=new Number(f[1]);if(a>=c&&a<=f[0])var g=d+(a-c)*(f[1]-d)/(f[0]-c);c=f[0],d=f[1]}}else var g=this.settings.from+a*this.settings.interval/100;return this.round(g)},d.prototype.valueToPrc=function(a,b){if(this.settings.heterogeneity&&this.settings.heterogeneity.length>0){var c=this.settings.heterogeneity,d=0,e=this.settings.from;for(var f=0;f<=c.length;f++){if(c[f])var g=c[f].split("/");else var g=[100,this.settings.to];g[0]=new Number(g[0]),g[1]=new Number(g[1]);if(a>=e&&a<=g[1])var h=b.limits(d+(a-e)*(g[0]-d)/(g[1]-e));d=g[0],e=g[1]}}else var h=b.limits((a-this.settings.from)*100/this.settings.interval);return h},d.prototype.round=function(a){return a=Math.round(a/this.settings.step)*this.settings.step,this.settings.round?a=Math.round(a*Math.pow(10,this.settings.round))/Math.pow(10,this.settings.round):a=Math.round(a),a},d.prototype.nice=function(b){return b=b.toString().replace(/,/gi,".").replace(/ /gi,""),a.formatNumber?a.formatNumber(new Number(b),this.settings.format||{}).replace(/-/gi,"&minus;"):new Number(b)},e.prototype=new Draggable,e.prototype.oninit=function(a,b,c){this.uid=b,this.parent=c,this.value={},this.settings=this.parent.settings},e.prototype.onmousedown=function(a){this._parent={offset:this.parent.domNode.offset(),width:this.parent.domNode.width()},this.ptr.addDependClass("hover"),this.setIndexOver()},e.prototype.onmousemove=function(a,b){var c=this._getPageCoords(a);this._set(this.calc(c.x))},e.prototype.onmouseup=function(b){this.parent.settings.callback&&a.isFunction(this.parent.settings.callback)&&this.parent.settings.callback.call(this.parent,this.parent.getValue()),this.ptr.removeDependClass("hover")},e.prototype.setIndexOver=function(){this.parent.setPointersIndex(1),this.index(2)},e.prototype.index=function(a){this.ptr.css({zIndex:a})},e.prototype.limits=function(a){return this.parent.limits(a,this)},e.prototype.calc=function(a){var b=this.limits((a-this._parent.offset.left)*100/this._parent.width);return b},e.prototype.set=function(a,b){this.value.origin=this.parent.round(a),this._set(this.parent.valueToPrc(a,this),b)},e.prototype._set=function(a,b){b||(this.value.origin=this.parent.prcToValue(a)),this.value.prc=a,this.ptr.css({left:a+"%"}),this.parent.redraw(this)}}(jQuery);

(function( $ ) {
  
  function isArray( value ){
    if( typeof value == "undefined" ) return false;
    
    if (value instanceof Array || (!(value instanceof Object) &&
         (Object.prototype.toString.call((value)) == '[object Array]') ||
         typeof value.length == 'number' &&
         typeof value.splice != 'undefined' &&
         typeof value.propertyIsEnumerable != 'undefined' &&
         !value.propertyIsEnumerable('splice')
        )) {
      return true;
    }
    
    return false;
  }

	$.jslider = function( node, settings ){

	  var jNode = $(node);
	  if( !jNode.data( "jslider" ) )
	    jNode.data( "jslider", new jSlider( node, settings ) );
	  
	  return jNode.data( "jslider" );
	};
	
	$.fn.jslider = function( action, opt_value ){
	  var returnValue, args = arguments;
	  
	  function isDef( val ){
	    return val !== undefined;
	  };

	  function isDefAndNotNull( val ){
      return val != null;
	  };
	  
		this.each(function(){
		  var self = $.jslider( this, action );
		  
		  // do actions
		  if( typeof action == "string" ){
		    switch( action ){
		      case "value":
		        if( isDef( args[ 1 ] ) && isDef( args[ 2 ] ) ){
		          var pointers = self.getPointers();
		          if( isDefAndNotNull( pointers[0] ) && isDefAndNotNull( args[1] ) ){
		            pointers[0].set( args[ 1 ] );
		            pointers[0].setIndexOver();
		          }
		          
		          if( isDefAndNotNull( pointers[1] ) && isDefAndNotNull( args[2] ) ){
		            pointers[1].set( args[ 2 ] );
		            pointers[1].setIndexOver();
		          }
		        }
		        
		        else if( isDef( args[ 1 ] ) ){
		          var pointers = self.getPointers();
		          if( isDefAndNotNull( pointers[0] ) && isDefAndNotNull( args[1] ) ){
		            pointers[0].set( args[ 1 ] );
		            pointers[0].setIndexOver();
		          }
		        }
		        
		        else
  		        returnValue = self.getValue();

		        break;

		      case "prc":
		        if( isDef( args[ 1 ] ) && isDef( args[ 2 ] ) ){
		          var pointers = self.getPointers();
		          if( isDefAndNotNull( pointers[0] ) && isDefAndNotNull( args[1] ) ){
		            pointers[0]._set( args[ 1 ] );
		            pointers[0].setIndexOver();
		          }

		          if( isDefAndNotNull( pointers[1] ) && isDefAndNotNull( args[2] ) ){
		            pointers[1]._set( args[ 2 ] );
		            pointers[1].setIndexOver();
		          }
		        }

		        else if( isDef( args[ 1 ] ) ){
		          var pointers = self.getPointers();
		          if( isDefAndNotNull( pointers[0] ) && isDefAndNotNull( args[1] ) ){
		            pointers[0]._set( args[ 1 ] );
		            pointers[0].setIndexOver();
		          }
		        }

		        else
  		        returnValue = self.getPrcValue();

		        break;

  		    case "calculatedValue":
  		      var value = self.getValue().split(";");
  		      returnValue = "";
  		      for (var i=0; i < value.length; i++) {
  		        returnValue += (i > 0 ? ";" : "") + self.nice( value[i] );
  		      };
  		      
  		      break;
  		      
  		    case "skin":
		        self.setSkin( args[1] );

  		      break;
		    };
		  
		  }
		  
		  // return actual object
		  else if( !action && !opt_value ){
		    if( !isArray( returnValue ) )
		      returnValue = [];

		    returnValue.push( self );
		  }
		});
		
		// flatten array just with one slider
		if( isArray( returnValue ) && returnValue.length == 1 )
		  returnValue = returnValue[ 0 ];
		
		return returnValue || this;
	};
  
  var OPTIONS = {

    settings: {
      from: 1,
      to: 10,
      step: 1,
      smooth: true,
      limits: true,
      minInterval: 0,
      round: 0,
      format: { format: "#,##0.##" },
      value: "5;7",
      dimension: ""
    },
    
    className: "jslider",
    selector: ".jslider-",

    template: tmpl(
      '<span class="<%=className%>">' +
        '<table><tr><td>' +
          '<div class="<%=className%>-bg">' +
            '<i class="l"></i><i class="r"></i>' +
            '<i class="v"></i>' +
          '</div>' +

          '<div class="<%=className%>-pointer"></div>' +
          '<div class="<%=className%>-pointer <%=className%>-pointer-to"></div>' +
        
          '<div class="<%=className%>-label"><span><%=settings.from%></span></div>' +
          '<div class="<%=className%>-label <%=className%>-label-to"><span><%=settings.to%></span><%=settings.dimension%></div>' +

          '<div class="<%=className%>-value"><span></span><%=settings.dimension%></div>' +
          '<div class="<%=className%>-value <%=className%>-value-to"><span></span><%=settings.dimension%></div>' +
          
          '<div class="<%=className%>-scale"><%=scale%></div>'+

        '</td></tr></table>' +
      '</span>'
    )
    
  };

  function jSlider(){
  	return this.init.apply( this, arguments );
  };

  jSlider.prototype.init = function( node, settings ){
    this.settings = $.extend(true, {}, OPTIONS.settings, settings ? settings : {});
    
    // obj.sliderHandler = this;
    this.inputNode = $( node ).hide();
    						
		this.settings.interval = this.settings.to-this.settings.from;
		this.settings.value = this.inputNode.attr("value");
		
		if( this.settings.calculate && $.isFunction( this.settings.calculate ) )
		  this.nice = this.settings.calculate;

		if( this.settings.onstatechange && $.isFunction( this.settings.onstatechange ) )
		  this.onstatechange = this.settings.onstatechange;

    this.is = {
      init: false
    };
		this.o = {};

    this.create();
  };
  
  jSlider.prototype.onstatechange = function(){
    
  };
  
  jSlider.prototype.create = function(){
    var $this = this;
    
    this.domNode = $( OPTIONS.template({
      className: OPTIONS.className,
      settings: {
        from: this.nice( this.settings.from ),
        to: this.nice( this.settings.to ),
        dimension: this.settings.dimension
      },
      scale: this.generateScale()
    }) );
    
    this.inputNode.after( this.domNode );
    this.drawScale();
    
    // set skin class
    if( this.settings.skin && this.settings.skin.length > 0 )
      this.setSkin( this.settings.skin );

		this.sizes = {
		  domWidth: this.domNode.width(),
		  domOffset: this.domNode.offset()
		};

    // find some objects
    $.extend(this.o, {
      pointers: {},
      labels: {
        0: {
          o: this.domNode.find(OPTIONS.selector + "value").not(OPTIONS.selector + "value-to")
        },
        1: {
          o: this.domNode.find(OPTIONS.selector + "value").filter(OPTIONS.selector + "value-to")
        }
      },
      limits: {
        0: this.domNode.find(OPTIONS.selector + "label").not(OPTIONS.selector + "label-to"),
        1: this.domNode.find(OPTIONS.selector + "label").filter(OPTIONS.selector + "label-to")
      }
    });

    $.extend(this.o.labels[0], {
      value: this.o.labels[0].o.find("span")
    });

    $.extend(this.o.labels[1], {
      value: this.o.labels[1].o.find("span")
    });

    
    if( !$this.settings.value.split(";")[1] ){
      this.settings.single = true;
      this.domNode.addDependClass("single");
    }

    if( !$this.settings.limits )
      this.domNode.addDependClass("limitless");

    this.domNode.find(OPTIONS.selector + "pointer").each(function( i ){
      var value = $this.settings.value.split(";")[i];
      if( value ){
        $this.o.pointers[i] = new jSliderPointer( this, i, $this );

        var prev = $this.settings.value.split(";")[i-1];
        if( prev && new Number(value) < new Number(prev) ) value = prev;

        value = value < $this.settings.from ? $this.settings.from : value;
        value = value > $this.settings.to ? $this.settings.to : value;
      
        $this.o.pointers[i].set( value, true );
      }
    });
    
    this.o.value = this.domNode.find(".v");
    this.is.init = true;
    
    $.each(this.o.pointers, function(i){
      $this.redraw(this);
    });
    
    (function(self){
      $(window).resize(function(){
        self.onresize();
      });
        //window.setTimeout(window.resize,1000);
    })(this);
      var self = this;
      //window.setTimeout(function(){self.onresize();},1000);
      $(window).load(function(){self.onresize();});

  };
  
  jSlider.prototype.setSkin = function( skin ){
    if( this.skin_ )
      this.domNode.removeDependClass( this.skin_, "_" );

    this.domNode.addDependClass( this.skin_ = skin, "_" );
  };
  
  jSlider.prototype.setPointersIndex = function( i ){
    $.each(this.getPointers(), function(i){
      this.index( i );
    });
  };
  
  jSlider.prototype.getPointers = function(){
    return this.o.pointers;
  };
  
  jSlider.prototype.generateScale = function(){
    if( this.settings.scale && this.settings.scale.length > 0 ){
      var str = "";
      var s = this.settings.scale;
      var prc = Math.round((100/(s.length-1))*10)/10;
      for( var i=0; i < s.length; i++ ){
        str += '<span style="left: ' + i*prc + '%">' + ( s[i] != '|' ? '<ins>' + s[i] + '</ins>' : '' ) + '</span>';
      };
      return str;
    } else return "";

    return "";
  };
  
  jSlider.prototype.drawScale = function(){
    this.domNode.find(OPTIONS.selector + "scale span ins").each(function(){
      $(this).css({ marginLeft: -$(this).outerWidth()/2 });
    });
  };
  
  jSlider.prototype.onresize = function(){
    var self = this;
		this.sizes = {
		  domWidth: this.domNode.width(),
		  domOffset: this.domNode.offset()
		};
    $.each(this.o.pointers, function(i){
      self.redraw(this);
    });
  };
  
  jSlider.prototype.update = function(){
    this.onresize();
    this.drawScale();
  };
  
  jSlider.prototype.limits = function( x, pointer ){
	  // smooth
	  if( !this.settings.smooth ){
	    var step = this.settings.step*100 / ( this.settings.interval );
	    x = Math.round( x/step ) * step;
	  }
	  
	  var another = this.o.pointers[1-pointer.uid];
      //console.log('pointer');
      //console.log(pointer);
      //console.log('another');
      //console.log(another);
      var xVal = this.prcToValue(x);
      var delta = this.settings.minInterval;
      var deltaPrc = Math.round((this.settings.minInterval/(this.settings.to - this.settings.from))*1000)/10;
      //console.log(deltaPrc);
	  if( another && pointer.uid && x < (another.value.prc + deltaPrc) ) {x = another.value.prc + deltaPrc;}
	  if( another && !pointer.uid && x > (another.value.prc - deltaPrc) ) x = another.value.prc - deltaPrc;

    // base limit
	  if( x < 0 ) x = 0;
	  if( x > 100 ) x = 100;
	  
    return Math.round( x*10 ) / 10;
  };
  
  jSlider.prototype.redraw = function( pointer ){
    if( !this.is.init ) return false;
    
    this.setValue();
    
    // redraw range line
    if( this.o.pointers[0] && this.o.pointers[1] ){
      this.o.value.css({ left: this.o.pointers[0].value.prc + "%", width: ( this.o.pointers[1].value.prc - this.o.pointers[0].value.prc ) + "%" });
    }else{
        if(this.settings.single){
            this.o.value.css({width: ( this.o.pointers[0].value.prc ) + "%" });
        }
    }
    this.o.labels[pointer.uid].value.html(
      this.nice(
        pointer.value.origin
      )
    );
    
    // redraw position of labels
    this.redrawLabels( pointer );

  };
  
  jSlider.prototype.redrawLabels = function( pointer ){

    function setPosition( label, sizes, prc ){
  	  sizes.margin = -sizes.label/2;

      // left limit
      label_left = sizes.border + sizes.margin;
      //if( label_left < 0 )
      //  sizes.margin -= label_left;

      // right limit
      if( sizes.border+sizes.label / 2 > self.sizes.domWidth ){
        //sizes.margin = 0;
        //sizes.right = true;
      } else
        sizes.right = false;
      var oldMargin = label.o.css('marginLeft');
      oldMargin = oldMargin.substr(0, oldMargin.length-2);
      if(Math.abs(oldMargin-sizes.margin) < 0.7){
          sizes.margin = oldMargin;
          label.o.css({ left: prc + "%", right: "auto" });
          return sizes;
      }
        
      label.o.css({ left: prc + "%", marginLeft: sizes.margin, right: "auto" });
      //if( sizes.right ) label.o.css({ left: "auto", right: 0 });
      return sizes;
    }

    var self = this;
	  var label = this.o.labels[pointer.uid];
	  var prc = pointer.value.prc;

	  var sizes = {
	    label: label.o.outerWidth(),
	    right: false,
	    border: ( prc * this.sizes.domWidth ) / 100
	  };

    if( !this.settings.single ){
      // glue if near;
      var another = this.o.pointers[1-pointer.uid];
    	var another_label = this.o.labels[another.uid];

      switch( pointer.uid ){
        case 0:
            //console.log(this.sizes);
          //console.log('sizes.boreder:'+sizes.border+' sizes.label / 2:'+ (sizes.label / 2)+' (another_label.o.offset().left-this.sizes.domOffset.left):'+(another_label.o.offset().left-this.sizes.domOffset.left)+' this.sizes.domOffset.left:'+this.sizes.domOffset.left);
          if( sizes.border+sizes.label / 2 > another_label.o.offset().left-this.sizes.domOffset.left ){
            another_label.o.css({ visibility: "hidden" });
        	  another_label.value.html( this.nice( another.value.origin ) );

          	label.o.css({ visibility: "visible" });

          	prc = ( another.value.prc - prc ) / 2 + prc;
          	if( another.value.prc != pointer.value.prc ){
          	  label.value.html( this.nice(pointer.value.origin) + "-" + this.nice(another.value.origin) );
            	sizes.label = label.o.outerWidth();
            	sizes.border = ( prc * this.sizes.domWidth ) / 100;
            }
          } else {
          	another_label.o.css({ visibility: "visible" });
          }
          break;

        case 1:
          //console.log('sizes.boreder:'+sizes.border+' sizes.label / 2:'+ (sizes.label / 2)+' (another_label.o.offset().left-this.sizes.domOffset.left):'+(another_label.o.offset().left-this.sizes.domOffset.left)+' another_label.o.outerWidth():'+another_label.o.outerWidth());
          if( sizes.border - sizes.label / 2 < another_label.o.offset().left - this.sizes.domOffset.left + another_label.o.outerWidth() ){
            another_label.o.css({ visibility: "hidden" });
        	  another_label.value.html( this.nice(another.value.origin) );

          	label.o.css({ visibility: "visible" });

          	prc = ( prc - another.value.prc ) / 2 + another.value.prc;
          	if( another.value.prc != pointer.value.prc ){
                  //replace &ndash; to -
          	  label.value.html( this.nice(another.value.origin) + "-" + this.nice(pointer.value.origin) );
            	sizes.label = label.o.outerWidth();
            	sizes.border = ( prc * this.sizes.domWidth ) / 100;
            }
          } else {
            another_label.o.css({ visibility: "visible" });
          }
          break;
      }
    }

    sizes = setPosition( label, sizes, prc );
    
    /* draw second label */
    if( another_label ){
      var sizes = {
  	    label: another_label.o.outerWidth(),
  	    right: false,
  	    border: ( another.value.prc * this.sizes.domWidth ) / 100
  	  };
      sizes = setPosition( another_label, sizes, another.value.prc );
    }
	  
    this.redrawLimits();
  };
  
  jSlider.prototype.redrawLimits = function(){
	  if( this.settings.limits ){

      var limits = [ true, true ];

      for( key in this.o.pointers ){

        if( !this.settings.single || key == 0 ){
        
      	  var pointer = this.o.pointers[key];
          var label = this.o.labels[pointer.uid];
          var label_left = label.o.offset().left - this.sizes.domOffset.left;

      	  var limit = this.o.limits[0];
          if( label_left < limit.outerWidth() )
            limits[0] = false;

      	  var limit = this.o.limits[1];
      	  if( label_left + label.o.outerWidth() > this.sizes.domWidth - limit.outerWidth() )
      	    limits[1] = false;
      	}

      };

      for( var i=0; i < limits.length; i++ ){
        if( limits[i] )
          this.o.limits[i].fadeIn("fast");
        else
          this.o.limits[i].fadeOut("fast");
      };

	  }
  };
  
  jSlider.prototype.setValue = function(){
    var value = this.getValue();
    this.inputNode.attr( "value", value );
    this.onstatechange.call( this, value );
  };

  jSlider.prototype.getValue = function(){
    if(!this.is.init) return false;
    var $this = this;
    
    var value = "";
    $.each( this.o.pointers, function(i){
      if( this.value.prc != undefined && !isNaN(this.value.prc) ) value += (i > 0 ? ";" : "") + $this.prcToValue( this.value.prc );
    });
    return value;
  };

  jSlider.prototype.getPrcValue = function(){
    if(!this.is.init) return false;
    var $this = this;
    
    var value = "";
    $.each( this.o.pointers, function(i){
      if( this.value.prc != undefined && !isNaN(this.value.prc) ) value += (i > 0 ? ";" : "") + this.value.prc;
    });
    return value;
  };
  
  jSlider.prototype.prcToValue = function( prc ){

	  if( this.settings.heterogeneity && this.settings.heterogeneity.length > 0 ){
  	  var h = this.settings.heterogeneity;

  	  var _start = 0;
  	  var _from = this.settings.from;

  	  for( var i=0; i <= h.length; i++ ){
  	    if( h[i] ) var v = h[i].split("/");
  	    else       var v = [100, this.settings.to];
  	    
  	    v[0] = new Number(v[0]);
  	    v[1] = new Number(v[1]);
  	      
  	    if( prc >= _start && prc <= v[0] ) {
  	      var value = _from + ( (prc-_start) * (v[1]-_from) ) / (v[0]-_start);
  	    }

  	    _start = v[0];
  	    _from = v[1];
  	  };

	  } else {
      var value = this.settings.from + ( prc * this.settings.interval ) / 100;
	  }

    return this.round( value );
  };
  
	jSlider.prototype.valueToPrc = function( value, pointer ){  	  
	  if( this.settings.heterogeneity && this.settings.heterogeneity.length > 0 ){
  	  var h = this.settings.heterogeneity;

  	  var _start = 0;
  	  var _from = this.settings.from;

  	  for (var i=0; i <= h.length; i++) {
  	    if(h[i]) var v = h[i].split("/");
  	    else     var v = [100, this.settings.to];
  	    v[0] = new Number(v[0]); v[1] = new Number(v[1]);
  	      
  	    if(value >= _from && value <= v[1]){
  	      var prc = pointer.limits(_start + (value-_from)*(v[0]-_start)/(v[1]-_from));
  	    }

  	    _start = v[0]; _from = v[1];
  	  };

	  } else {
  	  var prc = pointer.limits((value-this.settings.from)*100/this.settings.interval);
	  }

	  return prc;
	};
  
	jSlider.prototype.round = function( value ){
    value = Math.round( value / this.settings.step ) * this.settings.step;
		if( this.settings.round ) value = Math.round( value * Math.pow(10, this.settings.round) ) / Math.pow(10, this.settings.round);
		else value = Math.round( value );
		return value;
	};
	
	jSlider.prototype.nice = function( value ){
		value = value.toString().replace(/,/gi, ".").replace(/ /gi, "");;

		if( $.formatNumber ){
		  return $.formatNumber( new Number(value), this.settings.format || {} ).replace( /-/gi, "&minus;" );
		}
		  
		else {
		  return new Number(value);
		}
	};

  
  function jSliderPointer(){
  	Draggable.apply( this, arguments );
  }
  jSliderPointer.prototype = new Draggable();
  
  jSliderPointer.prototype.oninit = function( ptr, id, _constructor ){
    this.uid = id;
    this.parent = _constructor;
    this.value = {};
    this.settings = this.parent.settings;
  };
  
  jSliderPointer.prototype.onmousedown = function(evt){
	  this._parent = {
	    offset: this.parent.domNode.offset(),
	    width: this.parent.domNode.width()
	  };
	  this.ptr.addDependClass("hover");
	  this.setIndexOver();
	};

	jSliderPointer.prototype.onmousemove = function( evt, x ){
	  var coords = this._getPageCoords( evt );
	  this._set( this.calc( coords.x ) );
	};
	
	jSliderPointer.prototype.onmouseup = function( evt ){
	  if( this.parent.settings.callback && $.isFunction(this.parent.settings.callback) )
	    this.parent.settings.callback.call( this.parent, this.parent.getValue() );
	    
	  this.ptr.removeDependClass("hover");
	};
	
	jSliderPointer.prototype.setIndexOver = function(){
	  this.parent.setPointersIndex( 1 );
	  this.index( 2 );
	};
	
	jSliderPointer.prototype.index = function( i ){
	  this.ptr.css({ zIndex: i });
	};
	
	jSliderPointer.prototype.limits = function( x ){
        //console.log(this.parent);
	  return this.parent.limits( x, this );
	};
	
	jSliderPointer.prototype.calc = function(coords){
	  var x = this.limits(((coords-this._parent.offset.left)*100)/this._parent.width);
      //console.log(x);
	  return x;
	};

	jSliderPointer.prototype.set = function( value, opt_origin ){
	  this.value.origin = this.parent.round(value);
	  this._set( this.parent.valueToPrc( value, this ), opt_origin );
	};
	
	jSliderPointer.prototype._set = function( prc, opt_origin ){
	  if( !opt_origin )
	    this.value.origin = this.parent.prcToValue(prc);

	  this.value.prc = prc;
		this.ptr.css({ left: prc + "%" });
	  this.parent.redraw(this);
	};
  
})(jQuery);/**
 * Created with JetBrains PhpStorm.
 * User: oleg
 * Date: 09.10.12
 * Time: 11:33
 * To change this template use File | Settings | File Templates.
 */
(function ($) {
    $.photoSlider = {
        init: function(obj,options) {
            var _this = $(obj);
            var mainClass = _this.attr('class');
            _this.data('options',options);
            var self = this;
            self.obj = _this;
            self.unloadedImages = 0;
            self.totalImages = 0;
            self.leftNavi = $('<div class="left-navi"></div>');
            self.leftNavi.hide();

            self.rightNavi = $('<div class="right-navi"></div>');
            self.rightNavi.hide();
            self.obj.after(self.rightNavi);
            self.obj.after(self.leftNavi);
            self.leftNavi.click(function(){self.leftClick();})
            self.rightNavi.click(function(){self.rightClick();})

            console.log('initing photoslider!!!!');
            console.log(_this);
            console.log(self);
            _this.find('img').each(function(ind,el){
                //console.log(el,ind);
                self.unloadedImages++;
                self.totalImages++;
                var img  = new Image;
                var src = $(el).attr('src');
                $(img).bind('load error',function(){
                    console.log('image is loaded',this);
                    self.unloadedImages--;
                    if(self.unloadedImages <= 0 ){
                        self.allImagesLoaded();
                    }
                });
                img.src = src;
            });
        },
        testLimits: function(){
            var self = this;
            var rightVisible = self.rightNavi.css('display') != 'none';
            if( ((self.fullWidth - self.leftPosition) > self.visibleWidth) && !rightVisible){
                self.rightNavi.fadeIn();
            }else if( ((self.fullWidth - self.leftPosition) <= self.visibleWidth) && rightVisible ){
                self.rightNavi.fadeOut();
            }
            var leftVisible = self.leftNavi.css('display') != 'none';
            if( (self.indexPosition > 0) && !leftVisible){
                self.leftNavi.fadeIn();
            }else if( (self.indexPosition <= 0) && leftVisible ){
                self.leftNavi.fadeOut();
            }
        },
        allImagesLoaded: function(){
            var self = this;
            console.log('allImages loaded');

            self.fullWidth = 0;
            var pos = self.obj.find('li:last').position();
            var lastWidth = self.obj.find('li:last').width();
            self.fullWidth = pos.left + lastWidth;
            self.indexPosition = 0;
            self.leftPosition = 0;
            self.transitionProcess = false;
            self.visibleWidth = self.obj.parent().width();
            self.testLimits();
            $(window).resize(function(){self.onresize()});

            console.log(self);
        },
        transit: function(){
            var self = this;
            var pos = self.obj.find('li:eq('+self.indexPosition+')').position();
            //console.log(pos);
            if( self.indexPosition > 0 && ((self.fullWidth - pos.left) < self.visibleWidth) ){
                pos.left = self.fullWidth - self.visibleWidth;
            }
            self.leftPosition = pos.left;
            self.obj.animate({'left' : (-pos.left) +'px'}, 200, function() {
                self.transitionProcess = false;
                self.testLimits();
            });
        },
        rightClick: function(){
            var self = this;

            if( !self.transitionProcess && ((self.fullWidth - self.leftPosition) > self.visibleWidth) && (self.indexPosition < self.totalImages) ){
                self.transitionProcess = true;
                self.indexPosition++;
                self.transit();
            }
        },
        leftClick: function(){
            var self = this;

            if( !self.transitionProcess && (self.indexPosition > 0) ){
                self.transitionProcess = true;
                self.indexPosition--;
                self.transit();
            }
        },
        onresize: function(){
            var self = this;
            var alignRight = (self.fullWidth - self.leftPosition) == self.visibleWidth;

            self.visibleWidth = self.obj.parent().width();

            if(alignRight){
                self.leftPosition = self.fullWidth - self.visibleWidth;
                self.obj.css({'left': (-self.leftPosition) + 'px'});
            }
        }
    }
    $.fn.photoSlider = function (action,options) {
        if(typeof action == 'string'){

        }else{
            options = action;
            var defaultOptions = {kg:'am'};
            options = $.extend({},defaultOptions,options);

            $(this).each(function () {
                var self = this;
                window.setTimeout(function(){
                    $.photoSlider.init(self,options);
                }, 100);
            });
        }
    }
})(jQuery);var arr_textLoad = ['   5  30 ', '   500 ','  ', ' ', ' '];
var pointsInterval, textInterval, started = false, var_loadTextCounts;
function loaderChange(toStart) {
    var loadText = $('#changeText');
    if (toStart)
    {
        if (started)
            return;
        var_loadTextCounts = 0;
        loadText.text(arr_textLoad[var_loadTextCounts]);
        pointsInterval = setInterval(runPoints, 500);
        textInterval = setInterval(runText, 12000);
        started = true;
    }
    else
    {
        clearInterval(pointsInterval);
        clearInterval(textInterval);
        started = false;
    }
}

function runPoints() {
    var loadLight = $('#loadLight');
    var ind = loadLight.find('li.active').index();
    ind += 1;
    if (ind == loadLight.find('li').length) {
        ind = 0;
    }
    loadLight.find('li').removeClass('active');
    loadLight.find('li').eq(ind).addClass('active');
}

function runText() {
    var loadText = $('#changeText');
    var_loadTextCounts += 1;
    if (var_loadTextCounts == arr_textLoad.length) {
        var_loadTextCounts = 0;
    }
    loadText.text(arr_textLoad[var_loadTextCounts]);
}
var speedAnimateChangePic = 500;

function slideToursSlide() {
    if ($('.innerBlockMain').length > 0 && $('.innerBlockMain').is(':visible')) {
        //console.log('!!!==== 2 ====!!!');

        var WidthAllWindow = $(window).width();
        var var_slideToursBody = $('.slideTours');
        var var_lengthTours;

        var var_slideTours = $('.centerTours');
        var widthSmall;
        if (WidthAllWindow <= 1000) {
            widthSmall = 1000;
        }
        else if (WidthAllWindow > 1000 && WidthAllWindow < 1050) {
            widthSmall = WidthAllWindow;
        }
        else if (WidthAllWindow > 1050 && WidthAllWindow < 1290) {
            widthSmall = Math.floor(1050 + ( (WidthAllWindow - 1050) / ((1290 - 1050) / (1205 - 1050))) );
        }
        else if (WidthAllWindow > 1290 && WidthAllWindow < 1390) {
            widthSmall = 1205;
        }
        else if (WidthAllWindow > 1390 && WidthAllWindow < 1490) {
            widthSmall = Math.floor(1205 + ( (WidthAllWindow - 1390) / ((1490 - 1390) / (1390 - 1205))) );
        }
        else if (WidthAllWindow > 1490) {
            widthSmall = 1390;
        }

        var_slideTours.css('width', widthSmall+'px');
        $('.slideTours .center').css('width', widthSmall+'px');

        var var_allWidth = $('.slideTours .center').width();
        var var_widthTours;
        if (var_allWidth >= 1390) {
            var_lengthTours = 8;
            var_widthTours = Math.floor(((var_allWidth / var_lengthTours) - 2));
        }
        else if (var_allWidth < 1390 && var_allWidth >= 1290) {
            var_lengthTours = 7;
            var_widthTours = Math.floor(((var_allWidth / var_lengthTours) - 2));
        }
        else if (var_allWidth < 1290 && var_allWidth > 1000) {
            var_lengthTours = 6;
            var_widthTours = Math.floor(((var_allWidth / var_lengthTours) - 2));
        }
        else if (var_allWidth <= 1000) {
            var_lengthTours = 5;
            var_widthTours = Math.floor(((var_allWidth / var_lengthTours) - 2));
        }
        var_slideToursBody.find('.toursTicketsMain').css('width',var_widthTours+'px');
    }
}

function CenterIMGResize(index) {
    if (index == undefined)
        index = 0
	if ($('.innerBlockMain').length > 0 && $('.innerBlockMain').is(':visible')) {
        var HeightAllWindow = $(window).height();
        if (HeightAllWindow < 800) {
            HeightAllWindow = HeightAllWindow - 38 - 158;
            $('.slideTours').addClass('small');
        }
        else {
            HeightAllWindow = HeightAllWindow - 38 - 214;
            $('.slideTours').removeClass('small');
        }
        $('.innerBlockMain').css('height', HeightAllWindow+'px');


        var pathIMG = $('.innerBlockMain .IMGmain').eq(index).find('img');
        var marginPathLeft = 0;
        var var_allWidth = $('.slideTours .center').width();
        var heightImgMain = $('div.IMGmain').eq(index).find('img').height();




        var marginPathTop = (heightImgMain - HeightAllWindow) / 2;
        console.log("!!!! " +marginPathTop);
        if (marginPathTop < 0) {
            pathIMG.css('top', '0px');
            pathIMG.css('height', $('.innerBlockMain .IMGmain').eq(index).height()+'px').css('width','auto');

        }
        else {
            pathIMG.css('top', '-'+marginPathTop+'px');
        }

        if (var_allWidth >= 1390) {
            marginPathLeft = (1390 - var_allWidth) / 2;
        }
        else if (var_allWidth < 1390 && var_allWidth >= 1290) {
            marginPathLeft = (1390 - var_allWidth) / 2;

        }
        else if (var_allWidth < 1290 && var_allWidth > 1000) {
            marginPathLeft = (1390 - var_allWidth) / 2;
        }
        else if (var_allWidth <= 1000) {
            marginPathLeft = (1390 - var_allWidth) / 2;
        }

        pathIMG.css('left', '-'+marginPathLeft+'px');
    }
}

function smallIMGresizeIndex() {
	var _this = $('.imgTours');
    if (_this.length > 0 && _this.is(':visible')) {
        //console.log('!!!==== 5 ====!!!');
        var _img = _this.find('img');
        _this.each(function(e) {
            var _img = $(this).find('img');
            var _imgHeight = _img.height();
            var _imgWidth = _img.width();
            var _thisHeight = $(this).height();
            var _thisWidth = $(this).width();

            if (_imgHeight < _thisHeight) {
                _img.css('height', _thisHeight+'px');
                //console.log('!!!==='+_imgHeight +' / '+ _imgWidth +' / '+ _thisHeight +' / '+ _thisWidth);
            }
            //console.log(_imgHeight +' / '+ _imgWidth +' / '+ _thisHeight +' / '+ _thisWidth);
        });
    }
}

function indexIMGresizeCenter(index) {
	var _indexIMG = $('.IMGmain').eq(index).find('img');
	_indexIMG.css('width','100%');
	var _imgHeight = _indexIMG.height();
	var _innerHeight = $('.innerBlockMain').height();
	if (_innerHeight > _imgHeight) {
		_indexIMG.css('height', _innerHeight+'px').css('width', 'auto');
	}

}
function WidthMine() {
	var var_activeLI = $('.slide-turn-mode ul').find('.active');
	var var_activeLIindex = var_activeLI.index();
    if (var_activeLIindex<0) return;
	var var_switchSlide = $('.slide-turn-mode').find('.switch');
	var var_speed = 400;
	
	var arr_plannerWidth = [143, 0];
	var arr_aviaticketsWidth = [135, 155];
	var arr_hotelWidth = [95, 295];
	var arr_finishStagesWidth = [148, 403];
	
	var arr_valueWidth = [arr_plannerWidth, arr_aviaticketsWidth, arr_hotelWidth, arr_finishStagesWidth]
	
	var_switchSlide.css('width', arr_valueWidth[var_activeLIindex][0] +'px').css('left', arr_valueWidth[var_activeLIindex][1]+'px');
	var_switchSlide.find('.c').css('width', (arr_valueWidth[var_activeLIindex][0] - 27) +'px');

	$('.slide-turn-mode .btn').click(function(e) {
		e.preventDefault();
		if (! $(this).hasClass('active')) {
			$('.btn').removeClass('active');
			$(this).addClass('active');
			var_activeLI = $('.slide-turn-mode ul').find('.active');
			var_activeLIindex = var_activeLI.index();
			var_switchSlide.animate({width : arr_valueWidth[var_activeLIindex][0] +'px', left : arr_valueWidth[var_activeLIindex][1]+'px'}, var_speed , function() {
						$(this).addClass('active');
			});
			var_switchSlide.find('.c').animate({width : (arr_valueWidth[var_activeLIindex][0] - 27) +'px'}, var_speed );
		}
	});
}/**
 * Created with JetBrains PhpStorm.
 * User: oleg
 * Date: 01.11.12
 * Time: 17:44
 * To change this template use File | Settings | File Templates.
 */
function googleInfoDiv() {
    this.extend(googleInfoDiv, google.maps.OverlayView);
    this.show = __bind(this.show, this);

    this.hide = __bind(this.hide, this);

    this.getPosFromLatLng_ = __bind(this.getPosFromLatLng_, this);

    this.onAdd = __bind(this.onAdd, this);

    this.draw = __bind(this.draw, this);

    this.setContent = __bind(this.setContent, this);

    this.setPosition = __bind(this.setPosition, this);
    this.div_ = null;
    this.latLng = null;
    this.content = '';
    googleInfoDiv.prototype.getProjection = google.maps.OverlayView.prototype.getProjection;
}

googleInfoDiv.prototype.extend = function(obj1, obj2) {
    return (function(object) {
        for (var property in object.prototype) {
            this.prototype[property] = object.prototype[property];
        }
        return this;
    }).apply(obj1, [obj2]);
};

googleInfoDiv.prototype.setPosition = function(latLng) {
    var pos;
    this.latLng = latLng;
    pos = this.getPosFromLatLng_(this.latLng);
    if (this.div_) {
        this.div_.css({
            'top': pos.y + 'px',
            'left': pos.x + 'px'
        });
    }
};

googleInfoDiv.prototype.setContent = function(content) {
    this.content = content;
    if (this.div_) {
        this.div_.html(this.content);
    }
};

googleInfoDiv.prototype.draw = function() {
    var pos;
    if (this.div_) {
        pos = this.getPosFromLatLng_(this.latLng);
        return this.div_.css({
            'top': pos.y + 'px',
            'left': pos.x + 'px'
        });
    }
};

googleInfoDiv.prototype.onAdd = function() {
    var divEl, panes, pos;
    pos = this.getPosFromLatLng_(this.latLng);
    divEl = $('<div style=" width: 5px; height: 5px;position: absolute">' + this.content + '</div>');
    divEl.css({
        'top': (pos.y - 20) + 'px',
        'left': pos.x + 'px'
    });
    this.div_ = divEl;
    panes = this.getPanes();
    $(panes.overlayMouseTarget).append(divEl);
};

googleInfoDiv.prototype.getPosFromLatLng_ = function(LatLng) {
    var pos;
    if(this.getProjection()){
        pos = this.getProjection().fromLatLngToDivPixel(LatLng);
    }
    return pos;
};

googleInfoDiv.prototype.hide = function() {
    if(this.div_){
        this.div_.hide();
    }
};

googleInfoDiv.prototype.show = function() {
    if(this.div_){
        this.div_.show();
    }
};/*
	Masked Input plugin for jQuery
	Copyright (c) 2007-2011 Josh Bush (digitalbush.com)
	Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license) 
	Version: 1.3
*/
(function($) {
	var pasteEventName = ($.browser.msie ? 'paste' : 'input') + ".mask";
	var iPhone = (window.orientation != undefined);

	$.mask = {
		//Predefined character definitions
		definitions: {
			'9': "[0-9]",
			'a': "[A-Za-z]",
			'*': "[A-Za-z0-9]"
		},
		dataName:"rawMaskFn"
	};

	$.fn.extend({
		//Helper Function for Caret positioning
		caret: function(begin, end) {
			if (this.length == 0) return;
			if (typeof begin == 'number') {
				end = (typeof end == 'number') ? end : begin;
				return this.each(function() {
					if (this.setSelectionRange) {
						this.setSelectionRange(begin, end);
					} else if (this.createTextRange) {
						var range = this.createTextRange();
						range.collapse(true);
						range.moveEnd('character', end);
						range.moveStart('character', begin);
						range.select();
					}
				});
			} else {
				if (this[0].setSelectionRange) {
					begin = this[0].selectionStart;
					end = this[0].selectionEnd;
				} else if (document.selection && document.selection.createRange) {
					var range = document.selection.createRange();
					begin = 0 - range.duplicate().moveStart('character', -100000);
					end = begin + range.text.length;
				}
				return { begin: begin, end: end };
			}
		},
		unmask: function() { return this.trigger("unmask"); },
		mask: function(mask, settings) {
			if (!mask && this.length > 0) {
				var input = $(this[0]);
				return input.data($.mask.dataName)();
			}
			settings = $.extend({
				placeholder: "_",
				completed: null
			}, settings);

			var defs = $.mask.definitions;
			var tests = [];
			var partialPosition = mask.length;
			var firstNonMaskPos = null;
			var len = mask.length;

			$.each(mask.split(""), function(i, c) {
				if (c == '?') {
					len--;
					partialPosition = i;
				} else if (defs[c]) {
					tests.push(new RegExp(defs[c]));
					if(firstNonMaskPos==null)
						firstNonMaskPos =  tests.length - 1;
				} else {
					tests.push(null);
				}
			});

			return this.trigger("unmask").each(function() {
				var input = $(this);
				var buffer = $.map(mask.split(""), function(c, i) { if (c != '?') return defs[c] ? settings.placeholder : c });
				var focusText = input.val();

				function seekNext(pos) {
					while (++pos <= len && !tests[pos]);
					return pos;
				};
				function seekPrev(pos) {
					while (--pos >= 0 && !tests[pos]);
					return pos;
				};

				function shiftL(begin,end) {
					if(begin<0)
					   return;
					for (var i = begin,j = seekNext(end); i < len; i++) {
						if (tests[i]) {
							if (j < len && tests[i].test(buffer[j])) {
								buffer[i] = buffer[j];
								buffer[j] = settings.placeholder;
							} else
								break;
							j = seekNext(j);
						}
					}
					writeBuffer();
					input.caret(Math.max(firstNonMaskPos, begin));
				};

				function shiftR(pos) {
					for (var i = pos, c = settings.placeholder; i < len; i++) {
						if (tests[i]) {
							var j = seekNext(i);
							var t = buffer[i];
							buffer[i] = c;
							if (j < len && tests[j].test(t))
								c = t;
							else
								break;
						}
					}
				};

				function keydownEvent(e) {
					var k=e.which;

					//backspace, delete, and escape get special treatment
					if(k == 8 || k == 46 || (iPhone && k == 127)){
						var pos = input.caret(),
							begin = pos.begin,
							end = pos.end;
						
						if(end-begin==0){
							begin=k!=46?seekPrev(begin):(end=seekNext(begin-1));
							end=k==46?seekNext(end):end;
						}
						clearBuffer(begin, end);
						shiftL(begin,end-1);

						return false;
					} else if (k == 27) {//escape
						input.val(focusText);
						input.caret(0, checkVal());
						return false;
					}
				};

				function keypressEvent(e) {
					var k = e.which,
						pos = input.caret();
					if (e.ctrlKey || e.altKey || e.metaKey || k<32) {//Ignore
						return true;
					} else if (k) {
						if(pos.end-pos.begin!=0){
							clearBuffer(pos.begin, pos.end);
							shiftL(pos.begin, pos.end-1);
						}

						var p = seekNext(pos.begin - 1);
						if (p < len) {
							var c = String.fromCharCode(k);
							if (tests[p].test(c)) {
								shiftR(p);
								buffer[p] = c;
								writeBuffer();
								var next = seekNext(p);
								input.caret(next);
								if (settings.completed && next >= len)
									settings.completed.call(input);
							}
						}
						return false;
					}
				};

				function clearBuffer(start, end) {
					for (var i = start; i < end && i < len; i++) {
						if (tests[i])
							buffer[i] = settings.placeholder;
					}
				};

				function writeBuffer() { return input.val(buffer.join('')).val(); };

				function checkVal(allow) {
					//try to place characters where they belong
					var test = input.val();
					var lastMatch = -1;
					for (var i = 0, pos = 0; i < len; i++) {
						if (tests[i]) {
							buffer[i] = settings.placeholder;
							while (pos++ < test.length) {
								var c = test.charAt(pos - 1);
								if (tests[i].test(c)) {
									buffer[i] = c;
									lastMatch = i;
									break;
								}
							}
							if (pos > test.length)
								break;
						} else if (buffer[i] == test.charAt(pos) && i!=partialPosition) {
							pos++;
							lastMatch = i;
						}
					}
					if (!allow && lastMatch + 1 < partialPosition) {
						input.val("");
						clearBuffer(0, len);
					} else if (allow || lastMatch + 1 >= partialPosition) {
						writeBuffer();
						if (!allow) input.val(input.val().substring(0, lastMatch + 1));
					}
					return (partialPosition ? i : firstNonMaskPos);
				};

				input.data($.mask.dataName,function(){
					return $.map(buffer, function(c, i) {
						return tests[i]&&c!=settings.placeholder ? c : null;
					}).join('');
				})

				if (!input.attr("readonly"))
					input
					.one("unmask", function() {
						input
							.unbind(".mask")
							.removeData($.mask.dataName);
					})
					.bind("focus.mask", function() {
						focusText = input.val();
						var pos = checkVal();
						writeBuffer();
						var moveCaret=function(){
							if (pos == mask.length)
								input.caret(0, pos);
							else
								input.caret(pos);
						};
						($.browser.msie ? moveCaret:function(){setTimeout(moveCaret,0)})();
					})
					.bind("blur.mask", function() {
						checkVal();
						if (input.val() != focusText)
							input.change();
					})
					.bind("keydown.mask", keydownEvent)
					.bind("keypress.mask", keypressEvent)
					.bind(pasteEventName, function() {
						setTimeout(function() { input.caret(checkVal(true)); }, 0);
					});

				checkVal(); //Perform initial check for existing values
			});
		}
	});
})(jQuery);// Knockout JavaScript library v2.2.0
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(){
var DEBUG=true;
(function(window,document,navigator,jQuery,undefined){
!function(factory) {
    // Support three module loading scenarios
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        // [1] CommonJS/Node.js
        var target = module['exports'] || exports; // module.exports is for Node.js
        factory(target);
    } else if (typeof define === 'function' && define['amd']) {
        // [2] AMD anonymous module
        define(['exports'], factory);
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko'] = {});
    }
}(function(koExports){
// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
var ko = typeof koExports !== 'undefined' ? koExports : {};
// Google Closure Compiler helpers (used only to make the minified file smaller)
ko.exportSymbol = function(koPath, object) {
	var tokens = koPath.split(".");

	// In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
	// At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
	var target = ko;

	for (var i = 0; i < tokens.length - 1; i++)
		target = target[tokens[i]];
	target[tokens[tokens.length - 1]] = object;
};
ko.exportProperty = function(owner, publicName, object) {
  owner[publicName] = object;
};
ko.version = "2.2.0";

ko.exportSymbol('version', ko.version);
ko.utils = new (function () {
    var stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;

    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
    var knownEvents = {}, knownEventTypesByEventName = {};
    var keyEventTypeName = /Firefox\/2/i.test(navigator.userAgent) ? 'KeyboardEvent' : 'UIEvents';
    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
    for (var eventType in knownEvents) {
        var knownEventsForType = knownEvents[eventType];
        if (knownEventsForType.length) {
            for (var i = 0, j = knownEventsForType.length; i < j; i++)
                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
        }
    }
    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406

    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
    // If there is a future need to detect specific versions of IE10+, we will amend this.
    var ieVersion = (function() {
        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');

        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
        while (
            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
            iElems[0]
        );
        return version > 4 ? version : undefined;
    }());
    var isIe6 = ieVersion === 6,
        isIe7 = ieVersion === 7;

    function isClickOnCheckableElement(element, eventType) {
        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
        if (eventType.toLowerCase() != "click") return false;
        var inputType = element.type;
        return (inputType == "checkbox") || (inputType == "radio");
    }

    return {
        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],

        arrayForEach: function (array, action) {
            for (var i = 0, j = array.length; i < j; i++)
                action(array[i]);
        },

        arrayIndexOf: function (array, item) {
            if (typeof Array.prototype.indexOf == "function")
                return Array.prototype.indexOf.call(array, item);
            for (var i = 0, j = array.length; i < j; i++)
                if (array[i] === item)
                    return i;
            return -1;
        },

        arrayFirst: function (array, predicate, predicateOwner) {
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate.call(predicateOwner, array[i]))
                    return array[i];
            return null;
        },

        arrayRemoveItem: function (array, itemToRemove) {
            var index = ko.utils.arrayIndexOf(array, itemToRemove);
            if (index >= 0)
                array.splice(index, 1);
        },

        arrayGetDistinctValues: function (array) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                    result.push(array[i]);
            }
            return result;
        },

        arrayMap: function (array, mapping) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                result.push(mapping(array[i]));
            return result;
        },

        arrayFilter: function (array, predicate) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate(array[i]))
                    result.push(array[i]);
            return result;
        },

        arrayPushAll: function (array, valuesToPush) {
            if (valuesToPush instanceof Array)
                array.push.apply(array, valuesToPush);
            else
                for (var i = 0, j = valuesToPush.length; i < j; i++)
                    array.push(valuesToPush[i]);
            return array;
        },

        extend: function (target, source) {
            if (source) {
                for(var prop in source) {
                    if(source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }
            }
            return target;
        },

        emptyDomNode: function (domNode) {
            while (domNode.firstChild) {
                ko.removeNode(domNode.firstChild);
            }
        },

        moveCleanedNodesToContainerElement: function(nodes) {
            // Ensure it's a real array, as we're about to reparent the nodes and
            // we don't want the underlying collection to change while we're doing that.
            var nodesArray = ko.utils.makeArray(nodes);

            var container = document.createElement('div');
            for (var i = 0, j = nodesArray.length; i < j; i++) {
                container.appendChild(ko.cleanNode(nodesArray[i]));
            }
            return container;
        },

        cloneNodes: function (nodesArray, shouldCleanNodes) {
            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
                var clonedNode = nodesArray[i].cloneNode(true);
                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
            }
            return newNodesArray;
        },

        setDomNodeChildren: function (domNode, childNodes) {
            ko.utils.emptyDomNode(domNode);
            if (childNodes) {
                for (var i = 0, j = childNodes.length; i < j; i++)
                    domNode.appendChild(childNodes[i]);
            }
        },

        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
            if (nodesToReplaceArray.length > 0) {
                var insertionPoint = nodesToReplaceArray[0];
                var parent = insertionPoint.parentNode;
                for (var i = 0, j = newNodesArray.length; i < j; i++)
                    parent.insertBefore(newNodesArray[i], insertionPoint);
                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                    ko.removeNode(nodesToReplaceArray[i]);
                }
            }
        },

        setOptionNodeSelectionState: function (optionNode, isSelected) {
            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
            if (ieVersion < 7)
                optionNode.setAttribute("selected", isSelected);
            else
                optionNode.selected = isSelected;
        },

        stringTrim: function (string) {
            return (string || "").replace(stringTrimRegex, "");
        },

        stringTokenize: function (string, delimiter) {
            var result = [];
            var tokens = (string || "").split(delimiter);
            for (var i = 0, j = tokens.length; i < j; i++) {
                var trimmed = ko.utils.stringTrim(tokens[i]);
                if (trimmed !== "")
                    result.push(trimmed);
            }
            return result;
        },

        stringStartsWith: function (string, startsWith) {
            string = string || "";
            if (startsWith.length > string.length)
                return false;
            return string.substring(0, startsWith.length) === startsWith;
        },

        domNodeIsContainedBy: function (node, containedByNode) {
            if (containedByNode.compareDocumentPosition)
                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
            while (node != null) {
                if (node == containedByNode)
                    return true;
                node = node.parentNode;
            }
            return false;
        },

        domNodeIsAttachedToDocument: function (node) {
            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument);
        },

        anyDomNodeIsAttachedToDocument: function(nodes) {
            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
        },

        tagNameLower: function(element) {
            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
            return element && element.tagName && element.tagName.toLowerCase();
        },

        registerEventHandler: function (element, eventType, handler) {
            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
            if (!mustUseAttachEvent && typeof jQuery != "undefined") {
                if (isClickOnCheckableElement(element, eventType)) {
                    // For click events on checkboxes, jQuery interferes with the event handling in an awkward way:
                    // it toggles the element checked state *after* the click event handlers run, whereas native
                    // click events toggle the checked state *before* the event handler.
                    // Fix this by intecepting the handler and applying the correct checkedness before it runs.
                    var originalHandler = handler;
                    handler = function(event, eventData) {
                        var jQuerySuppliedCheckedState = this.checked;
                        if (eventData)
                            this.checked = eventData.checkedStateBeforeEvent !== true;
                        originalHandler.call(this, event);
                        this.checked = jQuerySuppliedCheckedState; // Restore the state jQuery applied
                    };
                }
                jQuery(element)['bind'](eventType, handler);
            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                element.addEventListener(eventType, handler, false);
            else if (typeof element.attachEvent != "undefined")
                element.attachEvent("on" + eventType, function (event) {
                    handler.call(element, event);
                });
            else
                throw new Error("Browser doesn't support addEventListener or attachEvent");
        },

        triggerEvent: function (element, eventType) {
            if (!(element && element.nodeType))
                throw new Error("element must be a DOM node when calling triggerEvent");

            if (typeof jQuery != "undefined") {
                var eventData = [];
                if (isClickOnCheckableElement(element, eventType)) {
                    // Work around the jQuery "click events on checkboxes" issue described above by storing the original checked state before triggering the handler
                    eventData.push({ checkedStateBeforeEvent: element.checked });
                }
                jQuery(element)['trigger'](eventType, eventData);
            } else if (typeof document.createEvent == "function") {
                if (typeof element.dispatchEvent == "function") {
                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                    var event = document.createEvent(eventCategory);
                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                    element.dispatchEvent(event);
                }
                else
                    throw new Error("The supplied element doesn't support dispatchEvent");
            } else if (typeof element.fireEvent != "undefined") {
                // Unlike other browsers, IE doesn't change the checked state of checkboxes/radiobuttons when you trigger their "click" event
                // so to make it consistent, we'll do it manually here
                if (isClickOnCheckableElement(element, eventType))
                    element.checked = element.checked !== true;
                element.fireEvent("on" + eventType);
            }
            else
                throw new Error("Browser doesn't support triggering events");
        },

        unwrapObservable: function (value) {
            return ko.isObservable(value) ? value() : value;
        },

        peekObservable: function (value) {
            return ko.isObservable(value) ? value.peek() : value;
        },

        toggleDomNodeCssClass: function (node, classNames, shouldHaveClass) {
            if (classNames) {
                var cssClassNameRegex = /[\w-]+/g,
                    currentClassNames = node.className.match(cssClassNameRegex) || [];
                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                    var indexOfClass = ko.utils.arrayIndexOf(currentClassNames, className);
                    if (indexOfClass >= 0) {
                        if (!shouldHaveClass)
                            currentClassNames.splice(indexOfClass, 1);
                    } else {
                        if (shouldHaveClass)
                            currentClassNames.push(className);
                    }
                });
                node.className = currentClassNames.join(" ");
            }
        },

        setTextContent: function(element, textContent) {
            var value = ko.utils.unwrapObservable(textContent);
            if ((value === null) || (value === undefined))
                value = "";

            if (element.nodeType === 3) {
                element.data = value;
            } else {
                // We need there to be exactly one child: a text node.
                // If there are no children, more than one, or if it's not a text node,
                // we'll clear everything and create a single text node.
                var innerTextNode = ko.virtualElements.firstChild(element);
                if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
                    ko.virtualElements.setDomNodeChildren(element, [document.createTextNode(value)]);
                } else {
                    innerTextNode.data = value;
                }

                ko.utils.forceRefresh(element);
            }
        },

        setElementName: function(element, name) {
            element.name = name;

            // Workaround IE 6/7 issue
            // - https://github.com/SteveSanderson/knockout/issues/197
            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
            if (ieVersion <= 7) {
                try {
                    element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
                }
                catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
            }
        },

        forceRefresh: function(node) {
            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
            if (ieVersion >= 9) {
                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
                var elem = node.nodeType == 1 ? node : node.parentNode;
                if (elem.style)
                    elem.style.zoom = elem.style.zoom;
            }
        },

        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
            if (ieVersion >= 9) {
                var originalWidth = selectElement.style.width;
                selectElement.style.width = 0;
                selectElement.style.width = originalWidth;
            }
        },

        range: function (min, max) {
            min = ko.utils.unwrapObservable(min);
            max = ko.utils.unwrapObservable(max);
            var result = [];
            for (var i = min; i <= max; i++)
                result.push(i);
            return result;
        },

        makeArray: function(arrayLikeObject) {
            var result = [];
            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                result.push(arrayLikeObject[i]);
            };
            return result;
        },

        isIe6 : isIe6,
        isIe7 : isIe7,
        ieVersion : ieVersion,

        getFormFields: function(form, fieldName) {
            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
            var isMatchingField = (typeof fieldName == 'string')
                ? function(field) { return field.name === fieldName }
                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
            var matches = [];
            for (var i = fields.length - 1; i >= 0; i--) {
                if (isMatchingField(fields[i]))
                    matches.push(fields[i]);
            };
            return matches;
        },

        parseJson: function (jsonString) {
            if (typeof jsonString == "string") {
                jsonString = ko.utils.stringTrim(jsonString);
                if (jsonString) {
                    if (window.JSON && window.JSON.parse) // Use native parsing where available
                        return window.JSON.parse(jsonString);
                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                }
            }
            return null;
        },

        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
            if ((typeof JSON == "undefined") || (typeof JSON.stringify == "undefined"))
                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
        },

        postJson: function (urlOrForm, data, options) {
            options = options || {};
            var params = options['params'] || {};
            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
            var url = urlOrForm;

            // If we were given a form, use its 'action' URL and pick out any requested field values
            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                var originalForm = urlOrForm;
                url = originalForm.action;
                for (var i = includeFields.length - 1; i >= 0; i--) {
                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                    for (var j = fields.length - 1; j >= 0; j--)
                        params[fields[j].name] = fields[j].value;
                }
            }

            data = ko.utils.unwrapObservable(data);
            var form = document.createElement("form");
            form.style.display = "none";
            form.action = url;
            form.method = "post";
            for (var key in data) {
                var input = document.createElement("input");
                input.name = key;
                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                form.appendChild(input);
            }
            for (var key in params) {
                var input = document.createElement("input");
                input.name = key;
                input.value = params[key];
                form.appendChild(input);
            }
            document.body.appendChild(form);
            options['submitter'] ? options['submitter'](form) : form.submit();
            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
        }
    }
})();

ko.exportSymbol('utils', ko.utils);
ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
ko.exportSymbol('utils.extend', ko.utils.extend);
ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
ko.exportSymbol('utils.postJson', ko.utils.postJson);
ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
ko.exportSymbol('utils.range', ko.utils.range);
ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);

if (!Function.prototype['bind']) {
    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
    Function.prototype['bind'] = function (object) {
        var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift();
        return function () {
            return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

ko.utils.domData = new (function () {
    var uniqueId = 0;
    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
    var dataStore = {};
    return {
        get: function (node, key) {
            var allDataForNode = ko.utils.domData.getAll(node, false);
            return allDataForNode === undefined ? undefined : allDataForNode[key];
        },
        set: function (node, key, value) {
            if (value === undefined) {
                // Make sure we don't actually create a new domData key if we are actually deleting a value
                if (ko.utils.domData.getAll(node, false) === undefined)
                    return;
            }
            var allDataForNode = ko.utils.domData.getAll(node, true);
            allDataForNode[key] = value;
        },
        getAll: function (node, createIfNotFound) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
            if (!hasExistingDataStore) {
                if (!createIfNotFound)
                    return undefined;
                dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
                dataStore[dataStoreKey] = {};
            }
            return dataStore[dataStoreKey];
        },
        clear: function (node) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            if (dataStoreKey) {
                delete dataStore[dataStoreKey];
                node[dataStoreKeyExpandoPropertyName] = null;
                return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
            }
            return false;
        }
    }
})();

ko.exportSymbol('utils.domData', ko.utils.domData);
ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully

ko.utils.domNodeDisposal = new (function () {
    var domDataKey = "__ko_domNodeDisposal__" + (new Date).getTime();
    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document

    function getDisposeCallbacksCollection(node, createIfNotFound) {
        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
            allDisposeCallbacks = [];
            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
        }
        return allDisposeCallbacks;
    }
    function destroyCallbacksCollection(node) {
        ko.utils.domData.set(node, domDataKey, undefined);
    }

    function cleanSingleNode(node) {
        // Run all the dispose callbacks
        var callbacks = getDisposeCallbacksCollection(node, false);
        if (callbacks) {
            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
            for (var i = 0; i < callbacks.length; i++)
                callbacks[i](node);
        }

        // Also erase the DOM data
        ko.utils.domData.clear(node);

        // Special support for jQuery here because it's so commonly used.
        // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
        // so notify it to tear down any resources associated with the node & descendants here.
        if ((typeof jQuery == "function") && (typeof jQuery['cleanData'] == "function"))
            jQuery['cleanData']([node]);

        // Also clear any immediate-child comment nodes, as these wouldn't have been found by
        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
        if (cleanableNodeTypesWithDescendants[node.nodeType])
            cleanImmediateCommentTypeChildren(node);
    }

    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
        var child, nextChild = nodeWithChildren.firstChild;
        while (child = nextChild) {
            nextChild = child.nextSibling;
            if (child.nodeType === 8)
                cleanSingleNode(child);
        }
    }

    return {
        addDisposeCallback : function(node, callback) {
            if (typeof callback != "function")
                throw new Error("Callback must be a function");
            getDisposeCallbacksCollection(node, true).push(callback);
        },

        removeDisposeCallback : function(node, callback) {
            var callbacksCollection = getDisposeCallbacksCollection(node, false);
            if (callbacksCollection) {
                ko.utils.arrayRemoveItem(callbacksCollection, callback);
                if (callbacksCollection.length == 0)
                    destroyCallbacksCollection(node);
            }
        },

        cleanNode : function(node) {
            // First clean this node, where applicable
            if (cleanableNodeTypes[node.nodeType]) {
                cleanSingleNode(node);

                // ... then its descendants, where applicable
                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                    // Clone the descendants list in case it changes during iteration
                    var descendants = [];
                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                    for (var i = 0, j = descendants.length; i < j; i++)
                        cleanSingleNode(descendants[i]);
                }
            }
            return node;
        },

        removeNode : function(node) {
            ko.cleanNode(node);
            if (node.parentNode)
                node.parentNode.removeChild(node);
        }
    }
})();
ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
ko.exportSymbol('cleanNode', ko.cleanNode);
ko.exportSymbol('removeNode', ko.removeNode);
ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
(function () {
    var leadingCommentRegex = /^(\s*)<!--(.*?)-->/;

    function simpleHtmlParse(html) {
        // Based on jQuery's "clean" function, but only accounting for table-related elements.
        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly

        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.

        // Trim whitespace, otherwise indexOf won't work as expected
        var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement("div");

        // Finds the first match from the left column, and returns the corresponding "wrap" data from the right column
        var wrap = tags.match(/^<(thead|tbody|tfoot)/)              && [1, "<table>", "</table>"] ||
                   !tags.indexOf("<tr")                             && [2, "<table><tbody>", "</tbody></table>"] ||
                   (!tags.indexOf("<td") || !tags.indexOf("<th"))   && [3, "<table><tbody><tr>", "</tr></tbody></table>"] ||
                   /* anything else */                                 [0, "", ""];

        // Go to html and back, then peel off extra wrappers
        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
        if (typeof window['innerShiv'] == "function") {
            div.appendChild(window['innerShiv'](markup));
        } else {
            div.innerHTML = markup;
        }

        // Move to the right depth
        while (wrap[0]--)
            div = div.lastChild;

        return ko.utils.makeArray(div.lastChild.childNodes);
    }

    function jQueryHtmlParse(html) {
        var elems = jQuery['clean']([html]);

        // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
        // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
        // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
        if (elems && elems[0]) {
            // Find the top-most parent element that's a direct child of a document fragment
            var elem = elems[0];
            while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                elem = elem.parentNode;
            // ... then detach it
            if (elem.parentNode)
                elem.parentNode.removeChild(elem);
        }

        return elems;
    }

    ko.utils.parseHtmlFragment = function(html) {
        return typeof jQuery != 'undefined' ? jQueryHtmlParse(html)   // As below, benefit from jQuery's optimisations where possible
                                            : simpleHtmlParse(html);  // ... otherwise, this simple logic will do in most common cases.
    };

    ko.utils.setHtml = function(node, html) {
        ko.utils.emptyDomNode(node);

        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
        html = ko.utils.unwrapObservable(html);

        if ((html !== null) && (html !== undefined)) {
            if (typeof html != 'string')
                html = html.toString();

            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
            // for example <tr> elements which are not normally allowed to exist on their own.
            // If you've referenced jQuery we'll use that rather than duplicating its code.
            if (typeof jQuery != 'undefined') {
                jQuery(node)['html'](html);
            } else {
                // ... otherwise, use KO's own parsing logic.
                var parsedNodes = ko.utils.parseHtmlFragment(html);
                for (var i = 0; i < parsedNodes.length; i++)
                    node.appendChild(parsedNodes[i]);
            }
        }
    };
})();

ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
ko.exportSymbol('utils.setHtml', ko.utils.setHtml);

ko.memoization = (function () {
    var memos = {};

    function randomMax8HexChars() {
        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
    }
    function generateRandomId() {
        return randomMax8HexChars() + randomMax8HexChars();
    }
    function findMemoNodes(rootNode, appendToArray) {
        if (!rootNode)
            return;
        if (rootNode.nodeType == 8) {
            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
            if (memoId != null)
                appendToArray.push({ domNode: rootNode, memoId: memoId });
        } else if (rootNode.nodeType == 1) {
            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                findMemoNodes(childNodes[i], appendToArray);
        }
    }

    return {
        memoize: function (callback) {
            if (typeof callback != "function")
                throw new Error("You can only pass a function to ko.memoization.memoize()");
            var memoId = generateRandomId();
            memos[memoId] = callback;
            return "<!--[ko_memo:" + memoId + "]-->";
        },

        unmemoize: function (memoId, callbackParams) {
            var callback = memos[memoId];
            if (callback === undefined)
                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
            try {
                callback.apply(null, callbackParams || []);
                return true;
            }
            finally { delete memos[memoId]; }
        },

        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
            var memos = [];
            findMemoNodes(domNode, memos);
            for (var i = 0, j = memos.length; i < j; i++) {
                var node = memos[i].domNode;
                var combinedParams = [node];
                if (extraCallbackParamsArray)
                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                if (node.parentNode)
                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
            }
        },

        parseMemoText: function (memoText) {
            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
            return match ? match[1] : null;
        }
    };
})();

ko.exportSymbol('memoization', ko.memoization);
ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
ko.extenders = {
    'throttle': function(target, timeout) {
        // Throttling means two things:

        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;

        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = setTimeout(function() {
                    target(value);
                }, timeout);
            }
        });
    },

    'notify': function(target, notifyWhen) {
        target["equalityComparer"] = notifyWhen == "always"
            ? function() { return false } // Treat all values as not equal
            : ko.observable["fn"]["equalityComparer"];
        return target;
    }
};

function applyExtenders(requestedExtenders) {
    var target = this;
    if (requestedExtenders) {
        for (var key in requestedExtenders) {
            var extenderHandler = ko.extenders[key];
            if (typeof extenderHandler == 'function') {
                target = extenderHandler(target, requestedExtenders[key]);
            }
        }
    }
    return target;
}

ko.exportSymbol('extenders', ko.extenders);

ko.subscription = function (target, callback, disposeCallback) {
    this.target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    ko.exportProperty(this, 'dispose', this.dispose);
};
ko.subscription.prototype.dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
};

ko.subscribable = function () {
    this._subscriptions = {};

    ko.utils.extend(this, ko.subscribable['fn']);
    ko.exportProperty(this, 'subscribe', this.subscribe);
    ko.exportProperty(this, 'extend', this.extend);
    ko.exportProperty(this, 'getSubscriptionsCount', this.getSubscriptionsCount);
}

var defaultEvent = "change";

ko.subscribable['fn'] = {
    subscribe: function (callback, callbackTarget, event) {
        event = event || defaultEvent;
        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;

        var subscription = new ko.subscription(this, boundCallback, function () {
            ko.utils.arrayRemoveItem(this._subscriptions[event], subscription);
        }.bind(this));

        if (!this._subscriptions[event])
            this._subscriptions[event] = [];
        this._subscriptions[event].push(subscription);
        return subscription;
    },

    "notifySubscribers": function (valueToNotify, event) {
        event = event || defaultEvent;
        if (this._subscriptions[event]) {
            ko.dependencyDetection.ignore(function() {
                ko.utils.arrayForEach(this._subscriptions[event].slice(0), function (subscription) {
                    // In case a subscription was disposed during the arrayForEach cycle, check
                    // for isDisposed on each subscription before invoking its callback
                    if (subscription && (subscription.isDisposed !== true))
                        subscription.callback(valueToNotify);
                });
            }, this);
        }
    },

    getSubscriptionsCount: function () {
        var total = 0;
        for (var eventName in this._subscriptions) {
            if (this._subscriptions.hasOwnProperty(eventName))
                total += this._subscriptions[eventName].length;
        }
        return total;
    },

    extend: applyExtenders
};


ko.isSubscribable = function (instance) {
    return typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
};

ko.exportSymbol('subscribable', ko.subscribable);
ko.exportSymbol('isSubscribable', ko.isSubscribable);

ko.dependencyDetection = (function () {
    var _frames = [];

    return {
        begin: function (callback) {
            _frames.push({ callback: callback, distinctDependencies:[] });
        },

        end: function () {
            _frames.pop();
        },

        registerDependency: function (subscribable) {
            if (!ko.isSubscribable(subscribable))
                throw new Error("Only subscribable things can act as dependencies");
            if (_frames.length > 0) {
                var topFrame = _frames[_frames.length - 1];
                if (!topFrame || ko.utils.arrayIndexOf(topFrame.distinctDependencies, subscribable) >= 0)
                    return;
                topFrame.distinctDependencies.push(subscribable);
                topFrame.callback(subscribable);
            }
        },

        ignore: function(callback, callbackTarget, callbackArgs) {
            try {
                _frames.push(null);
                return callback.apply(callbackTarget, callbackArgs || []);
            } finally {
                _frames.pop();
            }
        }
    };
})();
var primitiveTypes = { 'undefined':true, 'boolean':true, 'number':true, 'string':true };

ko.observable = function (initialValue) {
    var _latestValue = initialValue;

    function observable() {
        if (arguments.length > 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if ((!observable['equalityComparer']) || !observable['equalityComparer'](_latestValue, arguments[0])) {
                observable.valueWillMutate();
                _latestValue = arguments[0];
                if (DEBUG) observable._latestValue = _latestValue;
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
            return _latestValue;
        }
    }
    if (DEBUG) observable._latestValue = _latestValue;
    ko.subscribable.call(observable);
    observable.peek = function() { return _latestValue };
    observable.valueHasMutated = function () { observable["notifySubscribers"](_latestValue); }
    observable.valueWillMutate = function () { observable["notifySubscribers"](_latestValue, "beforeChange"); }
    ko.utils.extend(observable, ko.observable['fn']);

    ko.exportProperty(observable, 'peek', observable.peek);
    ko.exportProperty(observable, "valueHasMutated", observable.valueHasMutated);
    ko.exportProperty(observable, "valueWillMutate", observable.valueWillMutate);

    return observable;
}

ko.observable['fn'] = {
    "equalityComparer": function valuesArePrimitiveAndEqual(a, b) {
        var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
        return oldValueIsPrimitive ? (a === b) : false;
    }
};

var protoProperty = ko.observable.protoProperty = "__ko_proto__";
ko.observable['fn'][protoProperty] = ko.observable;

ko.hasPrototype = function(instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}
ko.isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == "function") && instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == "function") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}


ko.exportSymbol('observable', ko.observable);
ko.exportSymbol('isObservable', ko.isObservable);
ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
ko.observableArray = function (initialValues) {
    if (arguments.length == 0) {
        // Zero-parameter constructor initializes to empty array
        initialValues = [];
    }
    if ((initialValues !== null) && (initialValues !== undefined) && !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.extend(result, ko.observableArray['fn']);
    return result;
}

ko.observableArray['fn'] = {
    'remove': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var removedValues = [];
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        for (var i = 0; i < underlyingArray.length; i++) {
            var value = underlyingArray[i];
            if (predicate(value)) {
                if (removedValues.length === 0) {
                    this.valueWillMutate();
                }
                removedValues.push(value);
                underlyingArray.splice(i, 1);
                i--;
            }
        }
        if (removedValues.length) {
            this.valueHasMutated();
        }
        return removedValues;
    },

    'removeAll': function (arrayOfValues) {
        // If you passed zero args, we remove everything
        if (arrayOfValues === undefined) {
            var underlyingArray = this.peek();
            var allValues = underlyingArray.slice(0);
            this.valueWillMutate();
            underlyingArray.splice(0, underlyingArray.length);
            this.valueHasMutated();
            return allValues;
        }
        // If you passed an arg, we interpret it as an array of entries to remove
        if (!arrayOfValues)
            return [];
        return this['remove'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'destroy': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        this.valueWillMutate();
        for (var i = underlyingArray.length - 1; i >= 0; i--) {
            var value = underlyingArray[i];
            if (predicate(value))
                underlyingArray[i]["_destroy"] = true;
        }
        this.valueHasMutated();
    },

    'destroyAll': function (arrayOfValues) {
        // If you passed zero args, we destroy everything
        if (arrayOfValues === undefined)
            return this['destroy'](function() { return true });

        // If you passed an arg, we interpret it as an array of entries to destroy
        if (!arrayOfValues)
            return [];
        return this['destroy'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'indexOf': function (item) {
        var underlyingArray = this();
        return ko.utils.arrayIndexOf(underlyingArray, item);
    },

    'replace': function(oldItem, newItem) {
        var index = this['indexOf'](oldItem);
        if (index >= 0) {
            this.valueWillMutate();
            this.peek()[index] = newItem;
            this.valueHasMutated();
        }
    }
}

// Populate ko.observableArray.fn with read/write functions from native arrays
// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
        // (for consistency with mutating regular observables)
        var underlyingArray = this.peek();
        this.valueWillMutate();
        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
        this.valueHasMutated();
        return methodCallResult;
    };
});

// Populate ko.observableArray.fn with read-only functions from native arrays
ko.utils.arrayForEach(["slice"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        return underlyingArray[methodName].apply(underlyingArray, arguments);
    };
});

ko.exportSymbol('observableArray', ko.observableArray);
ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    var _latestValue,
        _hasBeenEvaluated = false,
        _isBeingEvaluated = false,
        readFunction = evaluatorFunctionOrOptions;

    if (readFunction && typeof readFunction == "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = readFunction;
        readFunction = options["read"];
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (!readFunction)
            readFunction = options["read"];
    }
    if (typeof readFunction != "function")
        throw new Error("Pass a function that returns the value of the ko.computed");

    function addSubscriptionToDependency(subscribable) {
        _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync));
    }

    function disposeAllSubscriptionsToDependencies() {
        ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) {
            subscription.dispose();
        });
        _subscriptionsToDependencies = [];
    }

    function evaluatePossiblyAsync() {
        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(evaluationTimeoutInstance);
            evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout);
        } else
            evaluateImmediate();
    }

    function evaluateImmediate() {
        if (_isBeingEvaluated) {
            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
            return;
        }

        // Don't dispose on first evaluation, because the "disposeWhen" callback might
        // e.g., dispose when the associated DOM element isn't in the doc, and it's not
        // going to be in the doc until *after* the first evaluation
        if (_hasBeenEvaluated && disposeWhen()) {
            dispose();
            return;
        }

        _isBeingEvaluated = true;
        try {
            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
            // Then, during evaluation, we cross off any that are in fact still being used.
            var disposalCandidates = ko.utils.arrayMap(_subscriptionsToDependencies, function(item) {return item.target;});

            ko.dependencyDetection.begin(function(subscribable) {
                var inOld;
                if ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0)
                    disposalCandidates[inOld] = undefined; // Don't want to dispose this subscription, as it's still being used
                else
                    addSubscriptionToDependency(subscribable); // Brand new subscription - add it
            });

            var newValue = readFunction.call(evaluatorFunctionTarget);

            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
            for (var i = disposalCandidates.length - 1; i >= 0; i--) {
                if (disposalCandidates[i])
                    _subscriptionsToDependencies.splice(i, 1)[0].dispose();
            }
            _hasBeenEvaluated = true;

            dependentObservable["notifySubscribers"](_latestValue, "beforeChange");
            _latestValue = newValue;
            if (DEBUG) dependentObservable._latestValue = _latestValue;
        } finally {
            ko.dependencyDetection.end();
        }

        dependentObservable["notifySubscribers"](_latestValue);
        _isBeingEvaluated = false;
        if (!_subscriptionsToDependencies.length)
            dispose();
    }

    function dependentObservable() {
        if (arguments.length > 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            if (!_hasBeenEvaluated)
                evaluateImmediate();
            ko.dependencyDetection.registerDependency(dependentObservable);
            return _latestValue;
        }
    }

    function peek() {
        if (!_hasBeenEvaluated)
            evaluateImmediate();
        return _latestValue;
    }

    function isActive() {
        return !_hasBeenEvaluated || _subscriptionsToDependencies.length > 0;
    }

    // By here, "options" is always non-null
    var writeFunction = options["write"],
        disposeWhenNodeIsRemoved = options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen = options["disposeWhen"] || options.disposeWhen || function() { return false; },
        dispose = disposeAllSubscriptionsToDependencies,
        _subscriptionsToDependencies = [],
        evaluationTimeoutInstance = null;

    if (!evaluatorFunctionTarget)
        evaluatorFunctionTarget = options["owner"];

    dependentObservable.peek = peek;
    dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; };
    dependentObservable.hasWriteFunction = typeof options["write"] === "function";
    dependentObservable.dispose = function () { dispose(); };
    dependentObservable.isActive = isActive;

    ko.subscribable.call(dependentObservable);
    ko.utils.extend(dependentObservable, ko.dependentObservable['fn']);

    ko.exportProperty(dependentObservable, 'peek', dependentObservable.peek);
    ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose);
    ko.exportProperty(dependentObservable, 'isActive', dependentObservable.isActive);
    ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount);

    // Evaluate, unless deferEvaluation is true
    if (options['deferEvaluation'] !== true)
        evaluateImmediate();

    // Build "disposeWhenNodeIsRemoved" and "disposeWhenNodeIsRemovedCallback" option values.
    // But skip if isActive is false (there will never be any dependencies to dispose).
    // (Note: "disposeWhenNodeIsRemoved" option both proactively disposes as soon as the node is removed using ko.removeNode(),
    // plus adds a "disposeWhen" callback that, on each evaluation, disposes if the node was removed by some other means.)
    if (disposeWhenNodeIsRemoved && isActive()) {
        dispose = function() {
            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee);
            disposeAllSubscriptionsToDependencies();
        };
        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);
        var existingDisposeWhenFunction = disposeWhen;
        disposeWhen = function () {
            return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || existingDisposeWhenFunction();
        }
    }

    return dependentObservable;
};

ko.isComputed = function(instance) {
    return ko.hasPrototype(instance, ko.dependentObservable);
};

var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
ko.dependentObservable[protoProp] = ko.observable;

ko.dependentObservable['fn'] = {};
ko.dependentObservable['fn'][protoProp] = ko.dependentObservable;

ko.exportSymbol('dependentObservable', ko.dependentObservable);
ko.exportSymbol('computed', ko.dependentObservable); // Make "ko.computed" an alias for "ko.dependentObservable"
ko.exportSymbol('isComputed', ko.isComputed);

(function() {
    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)

    ko.toJS = function(rootObject) {
        if (arguments.length == 0)
            throw new Error("When calling ko.toJS, pass the object you want to convert.");

        // We just unwrap everything at every level in the object graph
        return mapJsObjectGraph(rootObject, function(valueToMap) {
            // Loop because an observable's value might in turn be another observable wrapper
            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                valueToMap = valueToMap();
            return valueToMap;
        });
    };

    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
        var plainJavaScriptObject = ko.toJS(rootObject);
        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
    };

    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
        visitedObjects = visitedObjects || new objectLookup();

        rootObject = mapInputCallback(rootObject);
        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date));
        if (!canHaveProperties)
            return rootObject;

        var outputProperties = rootObject instanceof Array ? [] : {};
        visitedObjects.save(rootObject, outputProperties);

        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
            var propertyValue = mapInputCallback(rootObject[indexer]);

            switch (typeof propertyValue) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                    outputProperties[indexer] = propertyValue;
                    break;
                case "object":
                case "undefined":
                    var previouslyMappedValue = visitedObjects.get(propertyValue);
                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
                        ? previouslyMappedValue
                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                    break;
            }
        });

        return outputProperties;
    }

    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
        if (rootObject instanceof Array) {
            for (var i = 0; i < rootObject.length; i++)
                visitorCallback(i);

            // For arrays, also respect toJSON property for custom mappings (fixes #278)
            if (typeof rootObject['toJSON'] == 'function')
                visitorCallback('toJSON');
        } else {
            for (var propertyName in rootObject)
                visitorCallback(propertyName);
        }
    };

    function objectLookup() {
        var keys = [];
        var values = [];
        this.save = function(key, value) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            if (existingIndex >= 0)
                values[existingIndex] = value;
            else {
                keys.push(key);
                values.push(value);
            }
        };
        this.get = function(key) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            return (existingIndex >= 0) ? values[existingIndex] : undefined;
        };
    };
})();

ko.exportSymbol('toJS', ko.toJS);
ko.exportSymbol('toJSON', ko.toJSON);
(function () {
    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';

    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
    ko.selectExtensions = {
        readValue : function(element) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    if (element[hasDomDataExpandoProperty] === true)
                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                    return ko.utils.ieVersion <= 7
                        ? (element.getAttributeNode('value').specified ? element.value : element.text)
                        : element.value;
                case 'select':
                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                default:
                    return element.value;
            }
        },

        writeValue: function(element, value) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    switch(typeof value) {
                        case "string":
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                delete element[hasDomDataExpandoProperty];
                            }
                            element.value = value;
                            break;
                        default:
                            // Store arbitrary object using DomData
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                            element[hasDomDataExpandoProperty] = true;

                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                            element.value = typeof value === "number" ? value : "";
                            break;
                    }
                    break;
                case 'select':
                    for (var i = element.options.length - 1; i >= 0; i--) {
                        if (ko.selectExtensions.readValue(element.options[i]) == value) {
                            element.selectedIndex = i;
                            break;
                        }
                    }
                    break;
                default:
                    if ((value === null) || (value === undefined))
                        value = "";
                    element.value = value;
                    break;
            }
        }
    };
})();

ko.exportSymbol('selectExtensions', ko.selectExtensions);
ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
ko.expressionRewriting = (function () {
    var restoreCapturedTokensRegex = /\@ko_token_(\d+)\@/g;
    var javaScriptReservedWords = ["true", "false"];

    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;

    function restoreTokens(string, tokens) {
        var prevValue = null;
        while (string != prevValue) { // Keep restoring tokens until it no longer makes a difference (they may be nested)
            prevValue = string;
            string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) {
                return tokens[tokenIndex];
            });
        }
        return string;
    }

    function getWriteableValue(expression) {
        if (ko.utils.arrayIndexOf(javaScriptReservedWords, ko.utils.stringTrim(expression).toLowerCase()) >= 0)
            return false;
        var match = expression.match(javaScriptAssignmentTarget);
        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
    }

    function ensureQuoted(key) {
        var trimmedKey = ko.utils.stringTrim(key);
        switch (trimmedKey.length && trimmedKey.charAt(0)) {
            case "'":
            case '"':
                return key;
            default:
                return "'" + trimmedKey + "'";
        }
    }

    return {
        bindingRewriteValidators: [],

        parseObjectLiteral: function(objectLiteralString) {
            // A full tokeniser+lexer would add too much weight to this library, so here's a simple parser
            // that is sufficient just to split an object literal string into a set of top-level key-value pairs

            var str = ko.utils.stringTrim(objectLiteralString);
            if (str.length < 3)
                return [];
            if (str.charAt(0) === "{")// Ignore any braces surrounding the whole object literal
                str = str.substring(1, str.length - 1);

            // Pull out any string literals and regex literals
            var tokens = [];
            var tokenStart = null, tokenEndChar;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case '"':
                        case "'":
                        case "/":
                            tokenStart = position;
                            tokenEndChar = c;
                            break;
                    }
                } else if ((c == tokenEndChar) && (str.charAt(position - 1) !== "\\")) {
                    var token = str.substring(tokenStart, position + 1);
                    tokens.push(token);
                    var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                    str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                    position -= (token.length - replacement.length);
                    tokenStart = null;
                }
            }

            // Next pull out balanced paren, brace, and bracket blocks
            tokenStart = null;
            tokenEndChar = null;
            var tokenDepth = 0, tokenStartChar = null;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case "{": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "}";
                                  break;
                        case "(": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = ")";
                                  break;
                        case "[": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "]";
                                  break;
                    }
                }

                if (c === tokenStartChar)
                    tokenDepth++;
                else if (c === tokenEndChar) {
                    tokenDepth--;
                    if (tokenDepth === 0) {
                        var token = str.substring(tokenStart, position + 1);
                        tokens.push(token);
                        var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                        str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                        position -= (token.length - replacement.length);
                        tokenStart = null;
                    }
                }
            }

            // Now we can safely split on commas to get the key/value pairs
            var result = [];
            var keyValuePairs = str.split(",");
            for (var i = 0, j = keyValuePairs.length; i < j; i++) {
                var pair = keyValuePairs[i];
                var colonPos = pair.indexOf(":");
                if ((colonPos > 0) && (colonPos < pair.length - 1)) {
                    var key = pair.substring(0, colonPos);
                    var value = pair.substring(colonPos + 1);
                    result.push({ 'key': restoreTokens(key, tokens), 'value': restoreTokens(value, tokens) });
                } else {
                    result.push({ 'unknown': restoreTokens(pair, tokens) });
                }
            }
            return result;
        },

        preProcessBindings: function (objectLiteralStringOrKeyValueArray) {
            var keyValueArray = typeof objectLiteralStringOrKeyValueArray === "string"
                ? ko.expressionRewriting.parseObjectLiteral(objectLiteralStringOrKeyValueArray)
                : objectLiteralStringOrKeyValueArray;
            var resultStrings = [], propertyAccessorResultStrings = [];

            var keyValueEntry;
            for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {
                if (resultStrings.length > 0)
                    resultStrings.push(",");

                if (keyValueEntry['key']) {
                    var quotedKey = ensureQuoted(keyValueEntry['key']), val = keyValueEntry['value'];
                    resultStrings.push(quotedKey);
                    resultStrings.push(":");
                    resultStrings.push(val);

                    if (val = getWriteableValue(ko.utils.stringTrim(val))) {
                        if (propertyAccessorResultStrings.length > 0)
                            propertyAccessorResultStrings.push(", ");
                        propertyAccessorResultStrings.push(quotedKey + " : function(__ko_value) { " + val + " = __ko_value; }");
                    }
                } else if (keyValueEntry['unknown']) {
                    resultStrings.push(keyValueEntry['unknown']);
                }
            }

            var combinedResult = resultStrings.join("");
            if (propertyAccessorResultStrings.length > 0) {
                var allPropertyAccessors = propertyAccessorResultStrings.join("");
                combinedResult = combinedResult + ", '_ko_property_writers' : { " + allPropertyAccessors + " } ";
            }

            return combinedResult;
        },

        keyValueArrayContainsKey: function(keyValueArray, key) {
            for (var i = 0; i < keyValueArray.length; i++)
                if (ko.utils.stringTrim(keyValueArray[i]['key']) == key)
                    return true;
            return false;
        },

        // Internal, private KO utility for updating model properties from within bindings
        // property:            If the property being updated is (or might be) an observable, pass it here
        //                      If it turns out to be a writable observable, it will be written to directly
        // allBindingsAccessor: All bindings in the current execution context.
        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
        // value:               The value to be written
        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
        //                      it is !== existing value on that writable observable
        writeValueToProperty: function(property, allBindingsAccessor, key, value, checkIfDifferent) {
            if (!property || !ko.isWriteableObservable(property)) {
                var propWriters = allBindingsAccessor()['_ko_property_writers'];
                if (propWriters && propWriters[key])
                    propWriters[key](value);
            } else if (!checkIfDifferent || property.peek() !== value) {
                property(value);
            }
        }
    };
})();

ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);

// For backward compatibility, define the following aliases. (Previously, these function names were misleading because
// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);(function() {
    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
    // of that virtual hierarchy
    //
    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
    // without having to scatter special cases all over the binding and templating code.

    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
    // So, use node.text where available, and node.nodeValue elsewhere
    var commentNodesHaveTextProperty = document.createComment("test").text === "<!--test-->";

    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*-->$/ : /^\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*$/;
    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };

    function isStartComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
    }

    function isEndComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex);
    }

    function getVirtualChildren(startComment, allowUnbalanced) {
        var currentNode = startComment;
        var depth = 1;
        var children = [];
        while (currentNode = currentNode.nextSibling) {
            if (isEndComment(currentNode)) {
                depth--;
                if (depth === 0)
                    return children;
            }

            children.push(currentNode);

            if (isStartComment(currentNode))
                depth++;
        }
        if (!allowUnbalanced)
            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
        return null;
    }

    function getMatchingEndComment(startComment, allowUnbalanced) {
        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        if (allVirtualChildren) {
            if (allVirtualChildren.length > 0)
                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
            return startComment.nextSibling;
        } else
            return null; // Must have no matching end comment, and allowUnbalanced is true
    }

    function getUnbalancedChildTags(node) {
        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
        var childNode = node.firstChild, captureRemaining = null;
        if (childNode) {
            do {
                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                    captureRemaining.push(childNode);
                else if (isStartComment(childNode)) {
                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                        childNode = matchingEndComment;
                    else
                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                } else if (isEndComment(childNode)) {
                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                }
            } while (childNode = childNode.nextSibling);
        }
        return captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: function(node) {
            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: function(node) {
            if (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            else {
                var virtualChildren = ko.virtualElements.childNodes(node);
                for (var i = 0, j = virtualChildren.length; i < j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: function(node, childNodes) {
            if (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            else {
                ko.virtualElements.emptyNode(node);
                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                for (var i = 0, j = childNodes.length; i < j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: function(containerNode, nodeToPrepend) {
            if (!isStartComment(containerNode)) {
                if (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                else
                    containerNode.appendChild(nodeToPrepend);
            } else {
                // Start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
            if (!insertAfterNode) {
                ko.virtualElements.prepend(containerNode, nodeToInsert);
            } else if (!isStartComment(containerNode)) {
                // Insert after insertion point
                if (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                else
                    containerNode.appendChild(nodeToInsert);
            } else {
                // Children of start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: function(node) {
            if (!isStartComment(node))
                return node.firstChild;
            if (!node.nextSibling || isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        nextSibling: function(node) {
            if (isStartComment(node))
                node = getMatchingEndComment(node);
            if (node.nextSibling && isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        virtualNodeBindingValue: function(node) {
            var regexMatch = isStartComment(node);
            return regexMatch ? regexMatch[1] : null;
        },

        normaliseVirtualElementDomStructure: function(elementVerified) {
            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
            // that are direct descendants of <ul> into the preceding <li>)
            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                return;

            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
            // must be intended to appear *after* that child, so move them there.
            var childNode = elementVerified.firstChild;
            if (childNode) {
                do {
                    if (childNode.nodeType === 1) {
                        var unbalancedTags = getUnbalancedChildTags(childNode);
                        if (unbalancedTags) {
                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                            var nodeToInsertBefore = childNode.nextSibling;
                            for (var i = 0; i < unbalancedTags.length; i++) {
                                if (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                else
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } while (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol('virtualElements', ko.virtualElements);
ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
(function() {
    var defaultBindingAttributeName = "data-bind";

    ko.bindingProvider = function() {
        this.bindingCache = {};
    };

    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName) != null;   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node) != null; // Comment node
                default: return false;
            }
        },

        'getBindings': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext);
            return bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'getBindingsString': function(node, bindingContext) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                default: return null;
            }
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'parseBindingsString': function(bindingsString, bindingContext, node) {
            try {
                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache);
                return bindingFunction(bindingContext, node);
            } catch (ex) {
                throw new Error("Unable to parse bindings.\nMessage: " + ex + ";\nBindings value: " + bindingsString);
            }
        }
    });

    ko.bindingProvider['instance'] = new ko.bindingProvider();

    function createBindingsStringEvaluatorViaCache(bindingsString, cache) {
        var cacheKey = bindingsString;
        return cache[cacheKey]
            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString));
    }

    function createBindingsStringEvaluator(bindingsString) {
        // Build the source for a function that evaluates "expression"
        // For each scope variable, add an extra level of "with" nesting
        // Example result: with(sc1) { with(sc0) { return (expression) } }
        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString),
            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
        return new Function("$context", "$element", functionBody);
    }
})();

ko.exportSymbol('bindingProvider', ko.bindingProvider);
(function () {
    ko.bindingHandlers = {};

    ko.bindingContext = function(dataItem, parentBindingContext, dataItemAlias) {
        if (parentBindingContext) {
            ko.utils.extend(this, parentBindingContext); // Inherit $root and any custom properties
            this['$parentContext'] = parentBindingContext;
            this['$parent'] = parentBindingContext['$data'];
            this['$parents'] = (parentBindingContext['$parents'] || []).slice(0);
            this['$parents'].unshift(this['$parent']);
        } else {
            this['$parents'] = [];
            this['$root'] = dataItem;
            // Export 'ko' in the binding context so it will be available in bindings and templates
            // even if 'ko' isn't exported as a global, such as when using an AMD loader.
            // See https://github.com/SteveSanderson/knockout/issues/490
            this['ko'] = ko;
        }
        this['$data'] = dataItem;
        if (dataItemAlias)
            this[dataItemAlias] = dataItem;
    }
    ko.bindingContext.prototype['createChildContext'] = function (dataItem, dataItemAlias) {
        return new ko.bindingContext(dataItem, this, dataItemAlias);
    };
    ko.bindingContext.prototype['extend'] = function(properties) {
        var clone = ko.utils.extend(new ko.bindingContext(), this);
        return ko.utils.extend(clone, properties);
    };

    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
        var validator = ko.virtualElements.allowedBindings[bindingName];
        if (!validator)
            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
    }

    function applyBindingsToDescendantsInternal (viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
        var currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        while (currentChild = nextInQueue) {
            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    function applyBindingsToNodeAndDescendantsInternal (viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement) {
        var shouldBindDescendants = true;

        // Perf optimisation: Apply bindings only if...
        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
        var isElement = (nodeVerified.nodeType === 1);
        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
        if (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants;

        if (shouldBindDescendants) {
            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
            //    hence bindingContextsMayDifferFromDomParentElement is false
            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
            //    hence bindingContextsMayDifferFromDomParentElement is true
            applyBindingsToDescendantsInternal(viewModel, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
        }
    }

    function applyBindingsToNodeInternal (node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement) {
        // Need to be sure that inits are only run once, and updates never run until all the inits have been run
        var initPhase = 0; // 0 = before all inits, 1 = during inits, 2 = after all inits

        // Each time the dependentObservable is evaluated (after data changes),
        // the binding attribute is reparsed so that it can pick out the correct
        // model properties in the context of the changed data.
        // DOM event callbacks need to be able to access this changed data,
        // so we need a single parsedBindings variable (shared by all callbacks
        // associated with this node's bindings) that all the closures can access.
        var parsedBindings;
        function makeValueAccessor(bindingKey) {
            return function () { return parsedBindings[bindingKey] }
        }
        function parsedBindingsAccessor() {
            return parsedBindings;
        }

        var bindingHandlerThatControlsDescendantBindings;
        ko.dependentObservable(
            function () {
                // Ensure we have a nonnull binding context to work with
                var bindingContextInstance = viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
                    ? viewModelOrBindingContext
                    : new ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext));
                var viewModel = bindingContextInstance['$data'];

                // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
                // we can easily recover it just by scanning up the node's ancestors in the DOM
                // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
                if (bindingContextMayDifferFromDomParentElement)
                    ko.storedBindingContextForNode(node, bindingContextInstance);

                // Use evaluatedBindings if given, otherwise fall back on asking the bindings provider to give us some bindings
                var evaluatedBindings = (typeof bindings == "function") ? bindings(bindingContextInstance, node) : bindings;
                parsedBindings = evaluatedBindings || ko.bindingProvider['instance']['getBindings'](node, bindingContextInstance);

                if (parsedBindings) {
                    // First run all the inits, so bindings can register for notification on changes
                    if (initPhase === 0) {
                        initPhase = 1;
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && node.nodeType === 8)
                                validateThatBindingIsAllowedForVirtualElements(bindingKey);

                            if (binding && typeof binding["init"] == "function") {
                                var handlerInitFn = binding["init"];
                                var initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);

                                // If this binding handler claims to control descendant bindings, make a note of this
                                if (initResult && initResult['controlsDescendantBindings']) {
                                    if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                        throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                    bindingHandlerThatControlsDescendantBindings = bindingKey;
                                }
                            }
                        }
                        initPhase = 2;
                    }

                    // ... then run all the updates, which might trigger changes even on the first evaluation
                    if (initPhase === 2) {
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && typeof binding["update"] == "function") {
                                var handlerUpdateFn = binding["update"];
                                handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);
                            }
                        }
                    }
                }
            },
            null,
            { disposeWhenNodeIsRemoved : node }
        );

        return {
            shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === undefined
        };
    };

    var storedBindingContextDomDataKey = "__ko_bindingContext__";
    ko.storedBindingContextForNode = function (node, bindingContext) {
        if (arguments.length == 2)
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
        else
            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
    }

    ko.applyBindingsToNode = function (node, bindings, viewModel) {
        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        return applyBindingsToNodeInternal(node, bindings, viewModel, true);
    };

    ko.applyBindingsToDescendants = function(viewModel, rootNode) {
        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
            applyBindingsToDescendantsInternal(viewModel, rootNode, true);
    };

    ko.applyBindings = function (viewModel, rootNode) {
        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

        applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, true);
    };

    // Retrieving binding context from arbitrary nodes
    ko.contextFor = function(node) {
        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
        switch (node.nodeType) {
            case 1:
            case 8:
                var context = ko.storedBindingContextForNode(node);
                if (context) return context;
                if (node.parentNode) return ko.contextFor(node.parentNode);
                break;
        }
        return undefined;
    };
    ko.dataFor = function(node) {
        var context = ko.contextFor(node);
        return context ? context['$data'] : undefined;
    };

    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
    ko.exportSymbol('applyBindings', ko.applyBindings);
    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
    ko.exportSymbol('contextFor', ko.contextFor);
    ko.exportSymbol('dataFor', ko.dataFor);
})();
var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
ko.bindingHandlers['attr'] = {
    'update': function(element, valueAccessor, allBindingsAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
        for (var attrName in value) {
            if (typeof attrName == "string") {
                var attrValue = ko.utils.unwrapObservable(value[attrName]);

                // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
                // when someProp is a "no value"-like value (strictly null, false, or undefined)
                // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
                var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
                if (toRemove)
                    element.removeAttribute(attrName);

                // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
                // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
                // but instead of figuring out the mode, we'll just set the attribute through the Javascript
                // property for IE <= 8.
                if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                    attrName = attrHtmlToJavascriptMap[attrName];
                    if (toRemove)
                        element.removeAttribute(attrName);
                    else
                        element[attrName] = attrValue;
                } else if (!toRemove) {
                    element.setAttribute(attrName, attrValue.toString());
                }

                // Treat "name" specially - although you can think of it as an attribute, it also needs
                // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
                // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
                // entirely, and there's no strong reason to allow for such casing in HTML.
                if (attrName === "name") {
                    ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
                }
            }
        }
    }
};
ko.bindingHandlers['checked'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        var updateHandler = function() {
            var valueToWrite;
            if (element.type == "checkbox") {
                valueToWrite = element.checked;
            } else if ((element.type == "radio") && (element.checked)) {
                valueToWrite = element.value;
            } else {
                return; // "checked" binding only responds to checkboxes and selected radio buttons
            }

            var modelValue = valueAccessor(), unwrappedValue = ko.utils.unwrapObservable(modelValue);
            if ((element.type == "checkbox") && (unwrappedValue instanceof Array)) {
                // For checkboxes bound to an array, we add/remove the checkbox value to that array
                // This works for both observable and non-observable arrays
                var existingEntryIndex = ko.utils.arrayIndexOf(unwrappedValue, element.value);
                if (element.checked && (existingEntryIndex < 0))
                    modelValue.push(element.value);
                else if ((!element.checked) && (existingEntryIndex >= 0))
                    modelValue.splice(existingEntryIndex, 1);
            } else {
                ko.expressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'checked', valueToWrite, true);
            }
        };
        ko.utils.registerEventHandler(element, "click", updateHandler);

        // IE 6 won't allow radio buttons to be selected unless they have a name
        if ((element.type == "radio") && !element.name)
            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
    },
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());

        if (element.type == "checkbox") {
            if (value instanceof Array) {
                // When bound to an array, the checkbox being checked represents its value being present in that array
                element.checked = ko.utils.arrayIndexOf(value, element.value) >= 0;
            } else {
                // When bound to anything other value (not an array), the checkbox being checked represents the value being trueish
                element.checked = value;
            }
        } else if (element.type == "radio") {
            element.checked = (element.value == value);
        }
    }
};
var classesWrittenByBindingKey = '__ko__cssValue';
ko.bindingHandlers['css'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (typeof value == "object") {
            for (var className in value) {
                var shouldHaveClass = ko.utils.unwrapObservable(value[className]);
                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
            }
        } else {
            value = String(value || ''); // Make sure we don't try to store or set a non-string value
            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
            element[classesWrittenByBindingKey] = value;
            ko.utils.toggleDomNodeCssClass(element, value, true);
        }
    }
};
ko.bindingHandlers['enable'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value && element.disabled)
            element.removeAttribute("disabled");
        else if ((!value) && (!element.disabled))
            element.disabled = true;
    }
};

ko.bindingHandlers['disable'] = {
    'update': function (element, valueAccessor) {
        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
    }
};
// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
function makeEventHandlerShortcut(eventName) {
    ko.bindingHandlers[eventName] = {
        'init': function(element, valueAccessor, allBindingsAccessor, viewModel) {
            var newValueAccessor = function () {
                var result = {};
                result[eventName] = valueAccessor();
                return result;
            };
            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindingsAccessor, viewModel);
        }
    }
}

ko.bindingHandlers['event'] = {
    'init' : function (element, valueAccessor, allBindingsAccessor, viewModel) {
        var eventsToHandle = valueAccessor() || {};
        for(var eventNameOutsideClosure in eventsToHandle) {
            (function() {
                var eventName = eventNameOutsideClosure; // Separate variable to be captured by event handler closure
                if (typeof eventName == "string") {
                    ko.utils.registerEventHandler(element, eventName, function (event) {
                        var handlerReturnValue;
                        var handlerFunction = valueAccessor()[eventName];
                        if (!handlerFunction)
                            return;
                        var allBindings = allBindingsAccessor();

                        try {
                            // Take all the event args, and prefix with the viewmodel
                            var argsForHandler = ko.utils.makeArray(arguments);
                            argsForHandler.unshift(viewModel);
                            handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                        } finally {
                            if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                                if (event.preventDefault)
                                    event.preventDefault();
                                else
                                    event.returnValue = false;
                            }
                        }

                        var bubble = allBindings[eventName + 'Bubble'] !== false;
                        if (!bubble) {
                            event.cancelBubble = true;
                            if (event.stopPropagation)
                                event.stopPropagation();
                        }
                    });
                }
            })();
        }
    }
};
// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
ko.bindingHandlers['foreach'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() {
            var modelValue = valueAccessor(),
                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here

            // If unwrappedValue is the array, pass in the wrapped value on its own
            // The value will be unwrapped and tracked within the template binding
            // (See https://github.com/SteveSanderson/knockout/issues/523)
            if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };

            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
            ko.utils.unwrapObservable(modelValue);
            return {
                'foreach': unwrappedValue['data'],
                'as': unwrappedValue['as'],
                'includeDestroyed': unwrappedValue['includeDestroyed'],
                'afterAdd': unwrappedValue['afterAdd'],
                'beforeRemove': unwrappedValue['beforeRemove'],
                'afterRender': unwrappedValue['afterRender'],
                'beforeMove': unwrappedValue['beforeMove'],
                'afterMove': unwrappedValue['afterMove'],
                'templateEngine': ko.nativeTemplateEngine.instance
            };
        };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['foreach'] = true;
var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
var hasfocusLastValue = '__ko_hasfocusLastValue';
ko.bindingHandlers['hasfocus'] = {
    'init': function(element, valueAccessor, allBindingsAccessor) {
        var handleElementFocusChange = function(isFocused) {
            // Where possible, ignore which event was raised and determine focus state using activeElement,
            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
            // from calling 'blur()' on the element when it loses focus.
            // Discussion at https://github.com/SteveSanderson/knockout/pull/352
            element[hasfocusUpdatingProperty] = true;
            var ownerDoc = element.ownerDocument;
            if ("activeElement" in ownerDoc) {
                isFocused = (ownerDoc.activeElement === element);
            }
            var modelValue = valueAccessor();
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'hasfocus', isFocused, true);

            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function
            element[hasfocusLastValue] = isFocused;
            element[hasfocusUpdatingProperty] = false;
        };
        var handleElementFocusIn = handleElementFocusChange.bind(null, true);
        var handleElementFocusOut = handleElementFocusChange.bind(null, false);

        ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
        ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
        ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
        ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
    },
    'update': function(element, valueAccessor) {
        var value = !!ko.utils.unwrapObservable(valueAccessor()); //force boolean to compare with last value
        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {
            value ? element.focus() : element.blur();
            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]); // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
        }
    }
};

ko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make "hasFocus" an alias
ko.bindingHandlers['html'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        // setHtml will unwrap the value if needed
        ko.utils.setHtml(element, valueAccessor());
    }
};
var withIfDomDataKey = '__ko_withIfBindingData';
// Makes a binding like with or if
function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
    ko.bindingHandlers[bindingKey] = {
        'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            ko.utils.domData.set(element, withIfDomDataKey, {});
            return { 'controlsDescendantBindings': true };
        },
        'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var withIfData = ko.utils.domData.get(element, withIfDomDataKey),
                dataValue = ko.utils.unwrapObservable(valueAccessor()),
                shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
                isFirstRender = !withIfData.savedNodes,
                needsRefresh = isFirstRender || isWith || (shouldDisplay !== withIfData.didDisplayOnLastUpdate);

            if (needsRefresh) {
                if (isFirstRender) {
                    withIfData.savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
                }

                if (shouldDisplay) {
                    if (!isFirstRender) {
                        ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(withIfData.savedNodes));
                    }
                    ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, dataValue) : bindingContext, element);
                } else {
                    ko.virtualElements.emptyNode(element);
                }

                withIfData.didDisplayOnLastUpdate = shouldDisplay;
            }
        }
    };
    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
    ko.virtualElements.allowedBindings[bindingKey] = true;
}

// Construct the actual binding handlers
makeWithIfBinding('if');
makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
makeWithIfBinding('with', true /* isWith */, false /* isNot */,
    function(bindingContext, dataValue) {
        return bindingContext['createChildContext'](dataValue);
    }
);
function ensureDropdownSelectionIsConsistentWithModelValue(element, modelValue, preferModelValue) {
    if (preferModelValue) {
        if (modelValue !== ko.selectExtensions.readValue(element))
            ko.selectExtensions.writeValue(element, modelValue);
    }

    // No matter which direction we're syncing in, we want the end result to be equality between dropdown value and model value.
    // If they aren't equal, either we prefer the dropdown value, or the model value couldn't be represented, so either way,
    // change the model value to match the dropdown.
    if (modelValue !== ko.selectExtensions.readValue(element))
        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
};

ko.bindingHandlers['options'] = {
    'update': function (element, valueAccessor, allBindingsAccessor) {
        if (ko.utils.tagNameLower(element) !== "select")
            throw new Error("options binding applies only to SELECT elements");

        var selectWasPreviouslyEmpty = element.length == 0;
        var previousSelectedValues = ko.utils.arrayMap(ko.utils.arrayFilter(element.childNodes, function (node) {
            return node.tagName && (ko.utils.tagNameLower(node) === "option") && node.selected;
        }), function (node) {
            return ko.selectExtensions.readValue(node) || node.innerText || node.textContent;
        });
        var previousScrollTop = element.scrollTop;

        var value = ko.utils.unwrapObservable(valueAccessor());
        var selectedValue = element.value;

        // Remove all existing <option>s.
        // Need to use .remove() rather than .removeChild() for <option>s otherwise IE behaves oddly (https://github.com/SteveSanderson/knockout/issues/134)
        while (element.length > 0) {
            ko.cleanNode(element.options[0]);
            element.remove(0);
        }

        if (value) {
            var allBindings = allBindingsAccessor(),
                includeDestroyed = allBindings['optionsIncludeDestroyed'];

            if (typeof value.length != "number")
                value = [value];
            if (allBindings['optionsCaption']) {
                var option = document.createElement("option");
                ko.utils.setHtml(option, allBindings['optionsCaption']);
                ko.selectExtensions.writeValue(option, undefined);
                element.appendChild(option);
            }

            for (var i = 0, j = value.length; i < j; i++) {
                // Skip destroyed items
                var arrayEntry = value[i];
                if (arrayEntry && arrayEntry['_destroy'] && !includeDestroyed)
                    continue;

                var option = document.createElement("option");

                function applyToObject(object, predicate, defaultValue) {
                    var predicateType = typeof predicate;
                    if (predicateType == "function")    // Given a function; run it against the data value
                        return predicate(object);
                    else if (predicateType == "string") // Given a string; treat it as a property name on the data value
                        return object[predicate];
                    else                                // Given no optionsText arg; use the data value itself
                        return defaultValue;
                }

                // Apply a value to the option element
                var optionValue = applyToObject(arrayEntry, allBindings['optionsValue'], arrayEntry);
                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));

                // Apply some text to the option element
                var optionText = applyToObject(arrayEntry, allBindings['optionsText'], optionValue);
                ko.utils.setTextContent(option, optionText);

                element.appendChild(option);
            }

            // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
            // That's why we first added them without selection. Now it's time to set the selection.
            var newOptions = element.getElementsByTagName("option");
            var countSelectionsRetained = 0;
            for (var i = 0, j = newOptions.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[i])) >= 0) {
                    ko.utils.setOptionNodeSelectionState(newOptions[i], true);
                    countSelectionsRetained++;
                }
            }

            element.scrollTop = previousScrollTop;

            if (selectWasPreviouslyEmpty && ('value' in allBindings)) {
                // Ensure consistency between model value and selected option.
                // If the dropdown is being populated for the first time here (or was otherwise previously empty),
                // the dropdown selection state is meaningless, so we preserve the model value.
                ensureDropdownSelectionIsConsistentWithModelValue(element, ko.utils.peekObservable(allBindings['value']), /* preferModelValue */ true);
            }

            // Workaround for IE9 bug
            ko.utils.ensureSelectElementIsRenderedCorrectly(element);
        }
    }
};
ko.bindingHandlers['options'].optionValueDomDataKey = '__ko.optionValueDomData__';
ko.bindingHandlers['selectedOptions'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        ko.utils.registerEventHandler(element, "change", function () {
            var value = valueAccessor(), valueToWrite = [];
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                if (node.selected)
                    valueToWrite.push(ko.selectExtensions.readValue(node));
            });
            ko.expressionRewriting.writeValueToProperty(value, allBindingsAccessor, 'value', valueToWrite);
        });
    },
    'update': function (element, valueAccessor) {
        if (ko.utils.tagNameLower(element) != "select")
            throw new Error("values binding applies only to SELECT elements");

        var newValue = ko.utils.unwrapObservable(valueAccessor());
        if (newValue && typeof newValue.length == "number") {
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
                ko.utils.setOptionNodeSelectionState(node, isSelected);
            });
        }
    }
};
ko.bindingHandlers['style'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        for (var styleName in value) {
            if (typeof styleName == "string") {
                var styleValue = ko.utils.unwrapObservable(value[styleName]);
                element.style[styleName] = styleValue || ""; // Empty string removes the value, whereas null/undefined have no effect
            }
        }
    }
};
ko.bindingHandlers['submit'] = {
    'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
        if (typeof valueAccessor() != "function")
            throw new Error("The value for a submit binding must be a function");
        ko.utils.registerEventHandler(element, "submit", function (event) {
            var handlerReturnValue;
            var value = valueAccessor();
            try { handlerReturnValue = value.call(viewModel, element); }
            finally {
                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                }
            }
        });
    }
};
ko.bindingHandlers['text'] = {
    'update': function (element, valueAccessor) {
        ko.utils.setTextContent(element, valueAccessor());
    }
};
ko.virtualElements.allowedBindings['text'] = true;
ko.bindingHandlers['uniqueName'] = {
    'init': function (element, valueAccessor) {
        if (valueAccessor()) {
            var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
            ko.utils.setElementName(element, name);
        }
    }
};
ko.bindingHandlers['uniqueName'].currentIndex = 0;
ko.bindingHandlers['value'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        // Always catch "change" event; possibly other events too if asked
        var eventsToCatch = ["change"];
        var requestedEventsToCatch = allBindingsAccessor()["valueUpdate"];
        var propertyChangedFired = false;
        if (requestedEventsToCatch) {
            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                requestedEventsToCatch = [requestedEventsToCatch];
            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
        }

        var valueUpdateHandler = function() {
            propertyChangedFired = false;
            var modelValue = valueAccessor();
            var elementValue = ko.selectExtensions.readValue(element);
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'value', elementValue);
        }

        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
            ko.utils.registerEventHandler(element, "blur", function() {
                if (propertyChangedFired) {
                    valueUpdateHandler();
                }
            });
        }

        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
            // This is useful, for example, to catch "keydown" events after the browser has updated the control
            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
            var handler = valueUpdateHandler;
            if (ko.utils.stringStartsWith(eventName, "after")) {
                handler = function() { setTimeout(valueUpdateHandler, 0) };
                eventName = eventName.substring("after".length);
            }
            ko.utils.registerEventHandler(element, eventName, handler);
        });
    },
    'update': function (element, valueAccessor) {
        var valueIsSelectOption = ko.utils.tagNameLower(element) === "select";
        var newValue = ko.utils.unwrapObservable(valueAccessor());
        var elementValue = ko.selectExtensions.readValue(element);
        var valueHasChanged = (newValue != elementValue);

        // JavaScript's 0 == "" behavious is unfortunate here as it prevents writing 0 to an empty text box (loose equality suggests the values are the same).
        // We don't want to do a strict equality comparison as that is more confusing for developers in certain cases, so we specifically special case 0 != "" here.
        if ((newValue === 0) && (elementValue !== 0) && (elementValue !== "0"))
            valueHasChanged = true;

        if (valueHasChanged) {
            var applyValueAction = function () { ko.selectExtensions.writeValue(element, newValue); };
            applyValueAction();

            // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
            // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
            // to apply the value as well.
            var alsoApplyAsynchronously = valueIsSelectOption;
            if (alsoApplyAsynchronously)
                setTimeout(applyValueAction, 0);
        }

        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
        // because you're not allowed to have a model value that disagrees with a visible UI selection.
        if (valueIsSelectOption && (element.length > 0))
            ensureDropdownSelectionIsConsistentWithModelValue(element, newValue, /* preferModelValue */ false);
    }
};
ko.bindingHandlers['visible'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        var isCurrentlyVisible = !(element.style.display == "none");
        if (value && !isCurrentlyVisible)
            element.style.display = "";
        else if ((!value) && isCurrentlyVisible)
            element.style.display = "none";
    }
};
// 'click' is just a shorthand for the usual full-length event:{click:handler}
makeEventHandlerShortcut('click');
// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.

ko.templateEngine = function () { };

ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    throw new Error("Override renderTemplateSource");
};

ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
};

ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};

ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options);
};

ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;
    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
};

ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);
};

ko.exportSymbol('templateEngine', ko.templateEngine);

ko.templateRewriting = (function () {
    var memoizeDataBindingAttributeSyntaxRegex = /(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi;
    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;

    function validateDataBindValuesForRewriting(keyValueArray) {
        var allValidators = ko.expressionRewriting.bindingRewriteValidators;
        for (var i = 0; i < keyValueArray.length; i++) {
            var key = keyValueArray[i]['key'];
            if (allValidators.hasOwnProperty(key)) {
                var validator = allValidators[key];

                if (typeof validator === "function") {
                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
                    if (possibleErrorMessage)
                        throw new Error(possibleErrorMessage);
                } else if (!validator) {
                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                }
            }
        }
    }

    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, templateEngine) {
        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
        validateDataBindValuesForRewriting(dataBindKeyValueArray);
        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray);

        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
        // extra indirection.
        var applyBindingsToNextSiblingScript =
            "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()})";
        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
    }

    return {
        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                templateEngine['rewriteTemplate'](template, function (htmlString) {
                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                }, templateDocument);
        },

        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[6], /* tagToRetain: */ arguments[1], templateEngine);
            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", templateEngine);
            });
        },

        applyMemoizedBindingsToNextSibling: function (bindings) {
            return ko.memoization.memoize(function (domNode, bindingContext) {
                if (domNode.nextSibling)
                    ko.applyBindingsToNode(domNode.nextSibling, bindings, bindingContext);
            });
        }
    }
})();


// Exported only because it has to be referenced by string lookup from within rewritten template
ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
(function() {
    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
    //
    // Two are provided by default:
    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
    //                                           without reading/writing the actual element text content, since it will be overwritten
    //                                           with the rendered template output.
    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
    // Template sources need to have the following functions:
    //   text() 			- returns the template text from your storage location
    //   text(value)		- writes the supplied template text to your storage location
    //   data(key)			- reads values stored using data(key, value) - see below
    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
    //
    // Optionally, template sources can also have the following functions:
    //   nodes()            - returns a DOM element containing the nodes of this template, where available
    //   nodes(value)       - writes the given DOM element to your storage location
    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
    //
    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
    // using and overriding "makeTemplateSource" to return an instance of your custom template source.

    ko.templateSources = {};

    // ---- ko.templateSources.domElement -----

    ko.templateSources.domElement = function(element) {
        this.domElement = element;
    }

    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
        var tagNameLower = ko.utils.tagNameLower(this.domElement),
            elemContentsProperty = tagNameLower === "script" ? "text"
                                 : tagNameLower === "textarea" ? "value"
                                 : "innerHTML";

        if (arguments.length == 0) {
            return this.domElement[elemContentsProperty];
        } else {
            var valueToWrite = arguments[0];
            if (elemContentsProperty === "innerHTML")
                ko.utils.setHtml(this.domElement, valueToWrite);
            else
                this.domElement[elemContentsProperty] = valueToWrite;
        }
    };

    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
        if (arguments.length === 1) {
            return ko.utils.domData.get(this.domElement, "templateSourceData_" + key);
        } else {
            ko.utils.domData.set(this.domElement, "templateSourceData_" + key, arguments[1]);
        }
    };

    // ---- ko.templateSources.anonymousTemplate -----
    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.

    var anonymousTemplatesDomDataKey = "__ko_anon_template__";
    ko.templateSources.anonymousTemplate = function(element) {
        this.domElement = element;
    }
    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            if (templateData.textData === undefined && templateData.containerData)
                templateData.textData = templateData.containerData.innerHTML;
            return templateData.textData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {textData: valueToWrite});
        }
    };
    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            return templateData.containerData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {containerData: valueToWrite});
        }
    };

    ko.exportSymbol('templateSources', ko.templateSources);
    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
})();
(function () {
    var _templateEngine;
    ko.setTemplateEngine = function (templateEngine) {
        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
            throw new Error("templateEngine must inherit from ko.templateEngine");
        _templateEngine = templateEngine;
    }

    function invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, action) {
        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            if (node.nodeType === 1 || node.nodeType === 8)
                action(node);
        }
    }

    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

        if (continuousNodeArray.length) {
            var firstNode = continuousNodeArray[0], lastNode = continuousNodeArray[continuousNodeArray.length - 1];

            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
            // whereas a regular applyBindings won't introduce new memoized nodes
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });
        }
    }

    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                        : null;
    }

    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
        options = options || {};
        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;
        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

        // Loosely check result is an array of DOM nodes
        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
            throw new Error("Template engine must return an array of DOM nodes");

        var haveAddedNodesToParent = false;
        switch (renderMode) {
            case "replaceChildren":
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "replaceNode":
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "ignoreTargetNode": break;
            default:
                throw new Error("Unknown renderMode: " + renderMode);
        }

        if (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            if (options['afterRender'])
                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
        }

        return renderedNodesArray;
    }

    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
        options = options || {};
        if ((options['templateEngine'] || _templateEngine) == undefined)
            throw new Error("Set a template engine before calling renderTemplate");
        renderMode = renderMode || "replaceChildren";

        if (targetNodeOrNodeArray) {
            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                function () {
                    // Ensure we've got a proper binding context to work with
                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                        ? dataOrBindingContext
                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));

                    // Support selecting template as a function of the data being rendered
                    var templateName = typeof(template) == 'function' ? template(bindingContext['$data'], bindingContext) : template;

                    var renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
                    if (renderMode == "replaceNode") {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                null,
                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
            );
        } else {
            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
            return ko.memoization.memoize(function (domNode) {
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
            });
        }
    };

    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
        var arrayItemContext;

        // Child items count (helper for current context)
        var length = ko.dependentObservable(function(){
            return (ko.utils.unwrapObservable(arrayOrObservableArray) || []).length;
        }, null, { 'disposeWhenNodeIsRemoved': targetNode });


        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
        var executeTemplateForArrayItem = function (arrayValue, index) {
            // Support selecting template as a function of the data being rendered
            arrayItemContext = parentBindingContext['createChildContext'](ko.utils.unwrapObservable(arrayValue), options['as']);
            arrayItemContext['$index'] = index;
            arrayItemContext['$length'] = length;
            var templateName = typeof(template) == 'function' ? template(arrayValue, arrayItemContext) : template;
            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
        }

        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            if (options['afterRender'])
                options['afterRender'](addedNodesArray, arrayValue);
        };

        return ko.dependentObservable(function () {
            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);

        }, null, { disposeWhenNodeIsRemoved: targetNode });
    };

    var templateComputedDomDataKey = '__ko__templateComputedDomDataKey__';
    function disposeOldComputedAndStoreNewOne(element, newComputed) {
        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
            oldComputed.dispose();
        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
    }

    ko.bindingHandlers['template'] = {
        'init': function(element, valueAccessor) {
            // Support anonymous templates
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            if ((typeof bindingValue != "string") && (!bindingValue['name']) && (element.nodeType == 1 || element.nodeType == 8)) {
                // It's an anonymous template - store the element contents, then clear the element
                var templateNodes = element.nodeType == 1 ? element.childNodes : ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            }
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var templateName = ko.utils.unwrapObservable(valueAccessor()),
                options = {},
                shouldDisplay = true,
                dataValue,
                templateComputed = null;

            if (typeof templateName != "string") {
                options = templateName;
                templateName = options['name'];

                // Support "if"/"ifnot" conditions
                if ('if' in options)
                    shouldDisplay = ko.utils.unwrapObservable(options['if']);
                if (shouldDisplay && 'ifnot' in options)
                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);

                dataValue = ko.utils.unwrapObservable(options['data']);
            }

            if ('foreach' in options) {
                // Render once for each data point (treating data set as empty if shouldDisplay==false)
                var dataArray = (shouldDisplay && options['foreach']) || [];
                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
            } else if (!shouldDisplay) {
                ko.virtualElements.emptyNode(element);
            } else {
                // Render once for this single data point (or use the viewModel if no data was provided)
                var innerBindingContext = ('data' in options) ?
                    bindingContext['createChildContext'](dataValue, options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
            }

            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
            disposeOldComputedAndStoreNewOne(element, templateComputed);
        }
    };

    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);

        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)

        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
            return null; // Named templates can be rewritten, so return "no error"
        return "This template engine does not support anonymous templates nested within its templates";
    };

    ko.virtualElements.allowedBindings['template'] = true;
})();

ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
ko.exportSymbol('renderTemplate', ko.renderTemplate);

ko.utils.compareArrays = (function () {
    var statusNotInOld = 'added', statusNotInNew = 'deleted';

    // Simple calculation based on Levenshtein distance.
    function compareArrays(oldArray, newArray, dontLimitMoves) {
        oldArray = oldArray || [];
        newArray = newArray || [];

        if (oldArray.length <= newArray.length)
            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, dontLimitMoves);
        else
            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, dontLimitMoves);
    }

    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, dontLimitMoves) {
        var myMin = Math.min,
            myMax = Math.max,
            editDistanceMatrix = [],
            smlIndex, smlIndexMax = smlArray.length,
            bigIndex, bigIndexMax = bigArray.length,
            compareRange = (bigIndexMax - smlIndexMax) || 1,
            maxDistance = smlIndexMax + bigIndexMax + 1,
            thisRow, lastRow,
            bigIndexMaxForRow, bigIndexMinForRow;

        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
            lastRow = thisRow;
            editDistanceMatrix.push(thisRow = []);
            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
            bigIndexMinForRow = myMax(0, smlIndex - 1);
            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
                if (!bigIndex)
                    thisRow[bigIndex] = smlIndex + 1;
                else if (!smlIndex)  // Top row - transform empty array into new array via additions
                    thisRow[bigIndex] = bigIndex + 1;
                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
                else {
                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
                }
            }
        }

        var editScript = [], meMinusOne, notInSml = [], notInBig = [];
        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
                notInSml.push(editScript[editScript.length] = {     // added
                    'status': statusNotInSml,
                    'value': bigArray[--bigIndex],
                    'index': bigIndex });
            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
                notInBig.push(editScript[editScript.length] = {     // deleted
                    'status': statusNotInBig,
                    'value': smlArray[--smlIndex],
                    'index': smlIndex });
            } else {
                editScript.push({
                    'status': "retained",
                    'value': bigArray[--bigIndex] });
                --smlIndex;
            }
        }

        if (notInSml.length && notInBig.length) {
            // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
            // smlIndexMax keeps the time complexity of this algorithm linear.
            var limitFailedCompares = smlIndexMax * 10, failedCompares,
                a, d, notInSmlItem, notInBigItem;
            // Go through the items that have been added and deleted and try to find matches between them.
            for (failedCompares = a = 0; (dontLimitMoves || failedCompares < limitFailedCompares) && (notInSmlItem = notInSml[a]); a++) {
                for (d = 0; notInBigItem = notInBig[d]; d++) {
                    if (notInSmlItem['value'] === notInBigItem['value']) {
                        notInSmlItem['moved'] = notInBigItem['index'];
                        notInBigItem['moved'] = notInSmlItem['index'];
                        notInBig.splice(d,1);       // This item is marked as moved; so remove it from notInBig list
                        failedCompares = d = 0;     // Reset failed compares count because we're checking for consecutive failures
                        break;
                    }
                }
                failedCompares += d;
            }
        }
        return editScript.reverse();
    }

    return compareArrays;
})();

ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);

(function () {
    // Objective:
    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
    //   previously mapped - retain those nodes, and just insert/delete other ones

    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
    // You can use this, for example, to activate bindings on those nodes.

    function fixUpNodesToBeMovedOrRemoved(contiguousNodeArray) {
        // Before moving, deleting, or replacing a set of nodes that were previously outputted by the "map" function, we have to reconcile
        // them against what is in the DOM right now. It may be that some of the nodes have already been removed from the document,
        // or that new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
        // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
        // So, this function translates the old "map" output array into its best guess of what set of current DOM nodes should be removed.
        //
        // Rules:
        //   [A] Any leading nodes that aren't in the document any more should be ignored
        //       These most likely correspond to memoization nodes that were already removed during binding
        //       See https://github.com/SteveSanderson/knockout/pull/440
        //   [B] We want to output a contiguous series of nodes that are still in the document. So, ignore any nodes that
        //       have already been removed, and include any nodes that have been inserted among the previous collection

        // Rule [A]
        while (contiguousNodeArray.length && !ko.utils.domNodeIsAttachedToDocument(contiguousNodeArray[0]))
            contiguousNodeArray.splice(0, 1);

        // Rule [B]
        if (contiguousNodeArray.length > 1) {
            // Build up the actual new contiguous node set
            var current = contiguousNodeArray[0], last = contiguousNodeArray[contiguousNodeArray.length - 1], newContiguousSet = [current];
            while (current !== last) {
                current = current.nextSibling;
                if (!current) // Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)
                    return;
                newContiguousSet.push(current);
            }

            // ... then mutate the input array to match this.
            // (The following line replaces the contents of contiguousNodeArray with newContiguousSet)
            Array.prototype.splice.apply(contiguousNodeArray, [0, contiguousNodeArray.length].concat(newContiguousSet));
        }
        return contiguousNodeArray;
    }

    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
        // Map this array value inside a dependentObservable so we re-map when any dependency changes
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index) || [];

            // On subsequent evaluations, just replace the previously-inserted DOM nodes
            if (mappedNodes.length > 0) {
                ko.utils.replaceDomNodes(fixUpNodesToBeMovedOrRemoved(mappedNodes), newMappedNodes);
                if (callbackAfterAddingNodes)
                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
            }

            // Replace the contents of the mappedNodes array, thereby updating the record
            // of which nodes would be deleted if valueToMap was itself later removed
            mappedNodes.splice(0, mappedNodes.length);
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
    }

    var lastMappingResultDomDataKey = "setDomNodeChildrenFromArrayMapping_lastMappingResult";

    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
        // Compare the provided array against the previous one
        array = array || [];
        options = options || {};
        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
        var editScript = ko.utils.compareArrays(lastArray, array);

        // Build the new mapping result
        var newMappingResult = [];
        var lastMappingResultIndex = 0;
        var newMappingResultIndex = 0;

        var nodesToDelete = [];
        var itemsToProcess = [];
        var itemsForBeforeRemoveCallbacks = [];
        var itemsForMoveCallbacks = [];
        var itemsForAfterAddCallbacks = [];
        var mapData;

        function itemMovedOrRetained(editScriptIndex, oldPosition) {
            mapData = lastMappingResult[oldPosition];
            if (newMappingResultIndex !== oldPosition)
                itemsForMoveCallbacks[editScriptIndex] = mapData;
            // Since updating the index might change the nodes, do so before calling fixUpNodesToBeMovedOrRemoved
            mapData.indexObservable(newMappingResultIndex++);
            fixUpNodesToBeMovedOrRemoved(mapData.mappedNodes);
            newMappingResult.push(mapData);
            itemsToProcess.push(mapData);
        }

        function callCallback(callback, items) {
            if (callback) {
                for (var i = 0, n = items.length; i < n; i++) {
                    if (items[i]) {
                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
                            callback(node, i, items[i].arrayEntry);
                        });
                    }
                }
            }
        }

        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
            movedIndex = editScriptItem['moved'];
            switch (editScriptItem['status']) {
                case "deleted":
                    if (movedIndex === undefined) {
                        mapData = lastMappingResult[lastMappingResultIndex];

                        // Stop tracking changes to the mapping for these nodes
                        if (mapData.dependentObservable)
                            mapData.dependentObservable.dispose();

                        // Queue these nodes for later removal
                        nodesToDelete.push.apply(nodesToDelete, fixUpNodesToBeMovedOrRemoved(mapData.mappedNodes));
                        if (options['beforeRemove']) {
                            itemsForBeforeRemoveCallbacks[i] = mapData;
                            itemsToProcess.push(mapData);
                        }
                    }
                    lastMappingResultIndex++;
                    break;

                case "retained":
                    itemMovedOrRetained(i, lastMappingResultIndex++);
                    break;

                case "added":
                    if (movedIndex !== undefined) {
                        itemMovedOrRetained(i, movedIndex);
                    } else {
                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
                        newMappingResult.push(mapData);
                        itemsToProcess.push(mapData);
                        if (!isFirstExecution)
                            itemsForAfterAddCallbacks[i] = mapData;
                    }
                    break;
            }
        }

        // Call beforeMove first before any changes have been made to the DOM
        callCallback(options['beforeMove'], itemsForMoveCallbacks);

        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);

        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
            // Get nodes for newly added items
            if (!mapData.mappedNodes)
                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));

            // Put nodes in the right place if they aren't there already
            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
                if (node !== nextNode)
                    ko.virtualElements.insertAfter(domNode, node, lastNode);
            }

            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
            if (!mapData.initialized && callbackAfterAddingNodes) {
                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
                mapData.initialized = true;
            }
        }

        // If there's a beforeRemove callback, call it after reordering.
        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
        // some sort of animation, which is why we first reorder the nodes that will be removed. If the
        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
        // Perhaps we'll make that change in the future if this scenario becomes more common.
        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);

        // Finally call afterMove and afterAdd callbacks
        callCallback(options['afterMove'], itemsForMoveCallbacks);
        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);

        // Store a copy of the array items we just considered so we can difference it next time
        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    }
})();

ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
ko.nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}

ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText);
    }
};

ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
(function() {
    ko.jqueryTmplTemplateEngine = function () {
        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
        // doesn't expose a version number, so we have to infer it.
        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
        // which KO internally refers to as version "2", so older versions are no longer detected.
        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
            if ((typeof(jQuery) == "undefined") || !(jQuery['tmpl']))
                return 0;
            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
            try {
                if (jQuery['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
                    return 2; // Final version of jquery.tmpl
                }
            } catch(ex) { /* Apparently not the version we were looking for */ }

            return 1; // Any older version that we don't support
        })();

        function ensureHasReferencedJQueryTemplates() {
            if (jQueryTmplVersion < 2)
                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
        }

        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
            return jQuery['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
        }

        this['renderTemplateSource'] = function(templateSource, bindingContext, options) {
            options = options || {};
            ensureHasReferencedJQueryTemplates();

            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                var templateText = templateSource['text']() || "";
                // Wrap in "with($whatever.koBindingContext) { ... }"
                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

                precompiled = jQuery['template'](null, templateText);
                templateSource['data']('precompiled', precompiled);
            }

            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
            var jQueryTemplateOptions = jQuery['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
            resultNodes['appendTo'](document.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work

            jQuery['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
            return resultNodes;
        };

        this['createJavaScriptEvaluatorBlock'] = function(script) {
            return "{{ko_code ((function() { return " + script + " })()) }}";
        };

        this['addTemplate'] = function(templateName, templateMarkup) {
            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "<" + "/script>");
        };

        if (jQueryTmplVersion > 0) {
            jQuery['tmpl']['tag']['ko_code'] = {
                open: "__.push($1 || '');"
            };
            jQuery['tmpl']['tag']['ko_with'] = {
                open: "with($1) {",
                close: "} "
            };
        }
    };

    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();

    // Use this one by default *only if jquery.tmpl is referenced*
    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);

    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
})();
});
})(window,document,navigator,window["jQuery"]);
})();
// REPEAT binding for Knockout http://knockoutjs.com/
// (c) Michael Best
// License: MIT (http://www.opensource.org/licenses/mit-license.php)
// Version 1.4.2

(function(factory) {
    if (typeof define === 'function' && define['amd']) {
        // [1] AMD anonymous module
        define(['knockout'], factory);
    } else {
        // [2] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko']);
    }
})(function(ko) {

if (!ko.bindingFlags) { ko.bindingFlags = {}; }

function findPropertyName(obj, equals) {
    for (var a in obj)
        if (obj.hasOwnProperty(a) && obj[a] === equals)
            return a;
}

var koProtoName = findPropertyName(ko.observable.fn, ko.observable);

ko.bindingHandlers['repeat'] = {
    'flags': ko.bindingFlags.contentBind,
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {

        // Read and set fixed options--these options cannot be changed
        var repeatParam = ko.utils.unwrapObservable(valueAccessor());
        if (repeatParam && typeof repeatParam == 'object' && !('length' in repeatParam)) {
            var repeatIndex = repeatParam['index'],
                repeatData = repeatParam['item'],
                repeatStep = repeatParam['step'],
                repeatReversed = repeatParam['reverse'],
                repeatBind = repeatParam['bind'],
                repeatInit = repeatParam['init'],
                repeatUpdate = repeatParam['update'];
        }
        // Set default values for options that need it
        repeatIndex = repeatIndex || '$index';
        repeatData = repeatData || ko.bindingHandlers['repeat']['itemName'] || '$item';
        repeatStep = repeatStep || 1;
        repeatReversed = repeatReversed || false;

        // First clean the element node and remove node's binding
        ko.cleanNode(element);
        element.removeAttribute('data-bind');

        // extract and remove a data-repeat-bind attribute, if present
        if (!repeatBind) {
            repeatBind = element.getAttribute('data-repeat-bind');
            if (repeatBind) {
                element.removeAttribute('data-repeat-bind');
            }
        }

        // Make a copy of the element node to be copied for each repetition
        var cleanNode = element.cloneNode(true);
        if (typeof repeatBind == "string") {
            cleanNode.setAttribute('data-bind', repeatBind);
            repeatBind = null;
        }

        // Original element is no longer needed: delete it and create a placeholder comment
        var parent = element.parentNode, placeholder = document.createComment('ko_repeatplaceholder');
        parent.replaceChild(placeholder, element);

        // Set up persistent data
        var lastRepeatCount = 0,
            notificationObservable = ko.observable(),
            repeatArray;

        if (repeatInit) {
            repeatInit(parent);
        }

        var subscribable = ko.dependentObservable(function() {
            function makeArrayItemAccessor(index) {
                var f = function(newValue) {
                    var item = repeatArray[index];
                    if (!arguments.length) {
                        notificationObservable();   // for dependency tracking
                        return ko.utils.unwrapObservable(item);
                    } else if (ko.isObservable(item)) {
                        return item(newValue);
                    } else {
                        repeatArray[index] = newValue;
                    }
                };
                // Pretend that our accessor function is an observable
                f[koProtoName] = ko.observable;
                return f;
            }

            function makeBinding(item, index, context) {
                return repeatArray
                    ? function() { return repeatBind.call(viewModel, item, index, context); }
                    : function() { return repeatBind.call(viewModel, index, context); }
            }

            // Read and set up variable options--these options can change and will update the binding
            var repeatParam = ko.utils.unwrapObservable(valueAccessor()), repeatCount = 0;
            if (repeatParam && typeof repeatParam == 'object') {
                if ('length' in repeatParam) {
                    repeatArray = repeatParam;
                    repeatCount = repeatArray['length'];
                } else {
                    if ('foreach' in repeatParam) {
                        repeatArray = ko.utils.unwrapObservable(repeatParam['foreach']);
                        repeatCount = repeatArray && repeatArray['length'] || 0;
                    }
                    // If a count value is provided (>0), always output that number of items
                    if ('count' in repeatParam)
                        repeatCount = ko.utils.unwrapObservable(repeatParam['count']) || repeatCount;
                    // If a limit is provided, don't output more than the limit
                    if ('limit' in repeatParam)
                        repeatCount = Math.min(repeatCount, ko.utils.unwrapObservable(repeatParam['limit'])) || repeatCount;
                }
            } else {
                repeatCount = repeatParam || 0;
            }

            // Remove nodes from end if array is shorter
            for (; lastRepeatCount > repeatCount; lastRepeatCount-=repeatStep) {
                ko.removeNode(repeatReversed ? placeholder.nextSibling : placeholder.previousSibling);
            }

            // Notify existing nodes of change
            notificationObservable["notifySubscribers"]();

            // Add nodes to end if array is longer (also initially populates nodes)
            for (; lastRepeatCount < repeatCount; lastRepeatCount+=repeatStep) {
                // Clone node and add to document
                var newNode = cleanNode.cloneNode(true);
                parent.insertBefore(newNode, repeatReversed ? placeholder.nextSibling : placeholder);
                newNode.setAttribute('data-repeat-index', lastRepeatCount);

                // Apply bindings to inserted node
                if (repeatArray && repeatData == '$data') {
                    var newContext = bindingContext.createChildContext(makeArrayItemAccessor(lastRepeatCount));
                } else {
                    var newContext = bindingContext.extend
                        ? bindingContext.extend()
                        : ko.utils.extend(new bindingContext.constructor(), bindingContext);
                    if (repeatArray)
                        newContext[repeatData] = makeArrayItemAccessor(lastRepeatCount);
                }
                newContext[repeatIndex] = lastRepeatCount;
                if (repeatBind) {
                    var result = ko.applyBindingsToNode(newNode, makeBinding(newContext[repeatData], lastRepeatCount, newContext), newContext, true),
                        shouldBindDescendants = result && result.shouldBindDescendants;
                }
                if (!repeatBind || (result && shouldBindDescendants !== false)) {
                    ko.applyBindings(newContext, newNode);
                }
            }
            if (repeatUpdate) {
                repeatUpdate(parent);
            }
        }, null, {'disposeWhenNodeIsRemoved': placeholder});

        return { 'controlsDescendantBindings': true, 'subscribable': subscribable };
    }
};
});
// Deferred Updates plugin for Knockout http://knockoutjs.com/
// (c) Michael Best, Steven Sanderson
// License: MIT (http://www.opensource.org/licenses/mit-license.php)
// Version 1.2.0

(function(ko, undefined) {

/*
 * Task manager for deferred tasks
 */
ko.tasks = (function() {
    var setImmediate = !!window['setImmediate'] ? 'setImmediate' : 'setTimeout';    // Use setImmediate function if available; otherwise use setTimeout
    var evaluatorHandler, evaluatorsArray = [], taskStack = [], indexProcessing;

    function pushTaskState() {
        taskStack.push(evaluatorsArray.length);
    }

    function popTaskState() {
        var originalLength = taskStack.pop();
        if (evaluatorsArray.length > originalLength)
            processEvaluators(originalLength);
    }

    function currentStart() {
        return taskStack.length ? taskStack[taskStack.length-1] : 0;
    }

    function processEvaluators(start) {
        try {
            // New items might be added to evaluatorsArray during this loop
            // So always check evaluatorsArray.length
            for (var i = start || 0; i < evaluatorsArray.length; i++) {
                indexProcessing = i;
                var evObj = evaluatorsArray[i], evaluator = evObj.evaluator;
                // Check/set a flag for the evaluator so we don't call it again if processEvaluators is called recursively
                if (!evObj.processed) {
                    evObj.processed = true;
                    evaluator.apply(evObj.object, evObj.args || []);
                }
            }
        } finally {
            if (start) {
                // Remove only items we've just processed (shorten array to *start* items)
                evaluatorsArray.splice(start, evaluatorsArray.length);
            } else {
                // Clear array and handler to indicate that we're finished
                evaluatorsArray = [];
                evaluatorHandler = undefined;
            }
            indexProcessing = undefined;
        }
    }

    // need to wrap function call because Firefox calls setTimeout callback with a parameter
    function processEvaluatorsCallback() {
        processEvaluators();
    }

    function isEvaluatorDuplicate(evaluator, extras) {
        for (var i = indexProcessing || currentStart(), j = evaluatorsArray.length; i < j; i++)
            if (evaluatorsArray[i].evaluator == evaluator && !evaluatorsArray[i].processed) {
                if (extras)
                    ko.utils.extend(evaluatorsArray[i], extras);
                return true;
            }
        return false;
    }

    var tasks = {
        processImmediate: function(evaluator, object, args) {
            pushTaskState();
            try {
                return evaluator.apply(object, args || []);
            } finally {
                popTaskState();
            }
        },

        processDelayed: function(evaluator, distinct, extras) {
            if ((distinct || distinct === undefined) && isEvaluatorDuplicate(evaluator, extras)) {
                // Don't add evaluator if distinct is set (or missing) and evaluator is already in list
                return false;
            }
            evaluatorsArray.push(ko.utils.extend({evaluator: evaluator}, extras || {}));
            if (!taskStack.length && !evaluatorHandler) {
                evaluatorHandler = window[setImmediate](processEvaluatorsCallback);
            }
            return true;
        },

        makeProcessedCallback: function(evaluator) {
            return function() {
                return tasks.processImmediate(evaluator, this, arguments);
            }
        }
    };

    ko.processDeferredBindingUpdatesForNode =       // deprecated (included for compatibility)
    ko.processAllDeferredBindingUpdates = function(node) {
        // New items might be added to evaluatorsArray during this loop
        // So always check evaluatorsArray.length
        for (var i = 0; i < evaluatorsArray.length; i++) {
            var evObj = evaluatorsArray[i];
            if (evObj.node && !evObj.processed) {
                evObj.processed = true;
                var evaluator = evaluatorsArray[i].evaluator;
                evaluator();
            }
        }
    };

    ko.processAllDeferredUpdates = processEvaluatorsCallback;

    ko.evaluateAsynchronously = function(evaluator, timeout) {
        return setTimeout(tasks.makeProcessedCallback(evaluator), timeout);
    };

    return tasks;
})();

function findNameMethodSignatureContaining(obj, match) {
    for (var a in obj)
        if (obj.hasOwnProperty(a) && obj[a].toString().indexOf(match) >= 0)
            return a;
}

function findPropertyName(obj, equals) {
    for (var a in obj)
        if (obj.hasOwnProperty(a) && obj[a] === equals)
            return a;
}

function findSubObjectWithProperty(obj, prop) {
    for (var a in obj)
        if (obj.hasOwnProperty(a) && obj[a] && obj[a][prop])
            return obj[a];
}


/*
 * Sniff out the names and objects of Knockout internals
 */

// Find ko.dependencyDetection and its methods
var depDet = findSubObjectWithProperty(ko, 'end'),
    depDetBeginName = findNameMethodSignatureContaining(depDet, '.push({'),
    depDetRegisterName = findNameMethodSignatureContaining(depDet, '.length');

// Find hidden properties and methods of ko.computed and its returned values
// Also find the minified name of ko.computed (so Knockout will also use the new version)
var oldComputed = ko.computed,
    computedName = findPropertyName(ko, oldComputed),
    koProtoName = findPropertyName(oldComputed.fn, oldComputed),
    computedProto = ko.computed(function() {}),
    peekName = findPropertyName(computedProto, computedProto.peek) || 'peek',
    isActiveName = findPropertyName(computedProto, computedProto.isActive) || 'isActive',
    getDependenciesCountName = findPropertyName(computedProto, computedProto.getDependenciesCount),
    hasWriteFunctionName = findPropertyName(computedProto, false),
    disposeName = findPropertyName(computedProto, computedProto.dispose),
    disposeWhenNodeIsRemovedName = 'disposeWhenNodeIsRemoved',
    disposeWhenName = 'disposeWhen';

// Find hidden names for disposeWhenNodeIsRemoved and disposeWhen by examining the function source
if (hasWriteFunctionName != 'hasWriteFunction') {
    var oldComputedStr = oldComputed.toString(), match1, match2;
    if (match1 = oldComputedStr.match(/.\.disposeWhenNodeIsRemoved\|\|.\.([^|]+)\|\|/))
        disposeWhenNodeIsRemovedName = match1[1];
    if (match2 = oldComputedStr.match(/.\.disposeWhen\|\|.\.([^|]+)\|\|/))
        disposeWhenName = match2[1];
}

// Find ko.utils.domNodeIsAttachedToDocument
var nodeInDocName = findNameMethodSignatureContaining(ko.utils, 'ocument)');

// Find the name of the ko.subscribable.fn.subscribe function
var subFnObj = ko.subscribable.fn,
    subFnName = findNameMethodSignatureContaining(subFnObj, '.bind(');

// Find the name of ko.subscription.dispose
var subscription = new ko.subscribable().subscribe(),
    subscriptionProto = subscription.constructor.prototype,
    subDisposeName = findPropertyName(subscriptionProto, subscription.dispose),
    oldSubDispose = subscriptionProto[subDisposeName];
subscription.dispose();
subscription = null;

/*
 * Add ko.ignoreDependencies
 */
ko.ignoreDependencies = function(callback, object, args) {
    try {
        depDet[depDetBeginName](function() {});
        return callback.apply(object, args || []);
    } finally {
        depDet.end();
    }
}

/*
 * Replace ko.subscribable.fn.subscribe with one where change events are deferred
 */
subFnObj.oldSubscribe = subFnObj[subFnName];    // Save old subscribe function
subFnObj[subFnName] = function (callback, callbackTarget, event, deferUpdates, computed) {
    event = event || 'change';
    if (!computed) {
        var newCallback = function(valueToNotify) {
            if (((newComputed.deferUpdates && deferUpdates !== false) || deferUpdates) && event == 'change')
                ko.tasks.processDelayed(callback, false, {object: callbackTarget, args: [valueToNotify, event]});
            else
                ko.ignoreDependencies(callback, callbackTarget, [valueToNotify, event]);
        };
    } else {
        var newCallback = function(valueToNotify) {
            callback(valueToNotify, event);
        };
        if (event == 'change') {
            this.dependents = this.dependents || [];
            this.dependents.push(computed);
        }
    }
    var subscription = this.oldSubscribe(newCallback, null, event);
    subscription.target = this;
    subscription.event = event;
    subscription.dependent = computed;
    return subscription;
}
// Provide a method to return a list a dependents (computed observables that depend on the subscribable)
subFnObj.getDependents = function() {
    return this.dependents ? this.dependents.slice(0) : [];
}
// Update dispose function to clean up pointers to dependents
subscriptionProto[subDisposeName] = function() {
    oldSubDispose.call(this);
    if (this.dependent && this.event == 'change')
        ko.utils.arrayRemoveItem(this.target.dependents, this.dependent);
}

/*
 * New ko.computed with support for deferred updates (and other fixes)
 */
var newComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    var _latestValue,
        _possiblyNeedsEvaluation = false,
        _needsEvaluation = true,
        _isBeingEvaluated = false,
        readFunction = evaluatorFunctionOrOptions;

    if (readFunction && typeof readFunction == "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = readFunction;
        readFunction = options["read"];
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (!readFunction)
            readFunction = options["read"];
    }
    // By here, "options" is always non-null
    if (typeof readFunction != "function")
        throw new Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    if (!evaluatorFunctionTarget)
        evaluatorFunctionTarget = options["owner"];

    var _subscriptionsToDependencies = [];
    function disposeAllSubscriptionsToDependencies() {
        ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) {
            subscription.dispose();
        });
        _subscriptionsToDependencies = [];
        _possiblyNeedsEvaluation = _needsEvaluation = false;
    }

    var evaluationTimeoutInstance = null;
    function evaluatePossiblyAsync(value, event) {
        var isDirtyEvent = (event == "dirty");
        var shouldNotify = isDirtyEvent && !_possiblyNeedsEvaluation && !_needsEvaluation;
        if (isDirtyEvent)
            _possiblyNeedsEvaluation = true;
        else
            _needsEvaluation = true;
        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(evaluationTimeoutInstance);
            evaluationTimeoutInstance = ko.evaluateAsynchronously(evaluateImmediate, throttleEvaluationTimeout);
        } else if ((newComputed.deferUpdates && dependentObservable.deferUpdates !== false) || dependentObservable.deferUpdates)
            shouldNotify = ko.tasks.processDelayed(evaluateImmediate, true, {node: disposeWhenNodeIsRemoved});
        else if (_needsEvaluation)
            shouldNotify = evaluateImmediate();

        if (shouldNotify && dependentObservable["notifySubscribers"]) {     // notifySubscribers won't exist on first evaluation (but there won't be any subscribers anyway)
            dependentObservable["notifySubscribers"](_latestValue, "dirty");
            if (!_possiblyNeedsEvaluation && throttleEvaluationTimeout)  // The notification might have triggered an evaluation
                clearTimeout(evaluationTimeoutInstance);
        }
    }

    function markAsChanged() {
        _needsEvaluation = true;
    }

    function addDependency(subscribable) {
        var event = "change";
        if (subscribable[koProtoName] === newComputed) {
            _subscriptionsToDependencies.push(subscribable.subscribe(markAsChanged, null, "change", false, dependentObservable));
            event = "dirty";
        }
        _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync, null, event, false, dependentObservable));
    }

    function getDependencies() {
        return ko.utils.arrayMap(_subscriptionsToDependencies, function(item) {return item.target;});
    }

    function evaluateImmediate(force) {
        if (_isBeingEvaluated || (!_needsEvaluation && !(force === true))) {    // test for exact *true* value since Firefox will pass an integer value when this function is called through setTimeout
            _possiblyNeedsEvaluation = _needsEvaluation;
            return false;
        }

        // disposeWhen won't be set until after initial evaluation
        if (disposeWhen && disposeWhen()) {
            dependentObservable.dispose();
            return false;
        }

        _isBeingEvaluated = true;
        try {
            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
            // Then, during evaluation, we cross off any that are in fact still being used.
            var disposalCandidates = getDependencies();

            depDet[depDetBeginName](function(subscribable) {
                var inOld, found = false;
                while ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0) {
                    disposalCandidates[inOld] = undefined; // Don't want to dispose this subscription, as it's still being used
                    found = true;
                }
                if (!found)
                    addDependency(subscribable); // Brand new subscription - add it
            });

            var newValue = readFunction.call(evaluatorFunctionTarget);

            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
            for (var i = disposalCandidates.length - 1; i >= 0; i--) {
                if (disposalCandidates[i])
                    _subscriptionsToDependencies.splice(i, 1)[0].dispose();
            }

            _possiblyNeedsEvaluation = _needsEvaluation = false;

            dependentObservable["notifySubscribers"](_latestValue, "beforeChange");
            _latestValue = newValue;
        } finally {
            depDet.end();
        }

        dependentObservable["notifySubscribers"](_latestValue);
        _isBeingEvaluated = false;
        return true;
    }

    function evaluateInitial() {
        _isBeingEvaluated = true;
        try {
            depDet[depDetBeginName](addDependency);
            _latestValue = readFunction.call(evaluatorFunctionTarget);
        } finally {
            depDet.end();
        }
        _needsEvaluation = _isBeingEvaluated = false;
    }

    function dependentObservable() {
        if (arguments.length > 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                // Turn off deferred updates for this observable during the write so that the 'write' is registered
                // immediately (assuming that the read function accesses any observables that are written to).
                var saveDeferValue = dependentObservable.deferUpdates;
                dependentObservable.deferUpdates = false;

                writeFunction.apply(evaluatorFunctionTarget, arguments);

                dependentObservable.deferUpdates = saveDeferValue;
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            if (_needsEvaluation || _possiblyNeedsEvaluation)
                evaluateImmediate(true);
            depDet[depDetRegisterName](dependentObservable);
            return _latestValue;
        }
    }

    function peek() {
        if (_needsEvaluation || _possiblyNeedsEvaluation)
            evaluateImmediate(true);
        return _latestValue;
    }

    function isActive() {
        return _needsEvaluation || _possiblyNeedsEvaluation || _subscriptionsToDependencies.length > 0;
    }

    // Need to set disposeWhenNodeIsRemoved here in case we get a notification during the initial evaluation
    var disposeWhenNodeIsRemoved = options[disposeWhenNodeIsRemovedName] || options.disposeWhenNodeIsRemoved || null;

    if (options['deferEvaluation'] !== true)
        evaluateInitial();

    var dispose = disposeAllSubscriptionsToDependencies;

    // Build "disposeWhenNodeIsRemoved" and "disposeWhenNodeIsRemovedCallback" option values.
    // But skip if isActive is false (there will never be any dependencies to dispose).
    // (Note: "disposeWhenNodeIsRemoved" option both proactively disposes as soon as the node is removed using ko.removeNode(),
    // plus adds a "disposeWhen" callback that, on each evaluation, disposes if the node was removed by some other means.)
    var disposeWhen = options[disposeWhenName] || options.disposeWhen || function() { return false; };
    if (disposeWhenNodeIsRemoved && isActive()) {
        dispose = function() {
            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee);
            disposeAllSubscriptionsToDependencies();
        };
        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);
        var existingDisposeWhenFunction = disposeWhen;
        disposeWhen = function () {
            return !ko.utils[nodeInDocName](disposeWhenNodeIsRemoved) || existingDisposeWhenFunction();
        }
    }

    // Set properties of returned function
    ko.subscribable.call(dependentObservable);
    ko.utils.extend(dependentObservable, newComputed.fn);

    dependentObservable[peekName] = dependentObservable.peek = peek;
    dependentObservable[getDependenciesCountName] = dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; };
    dependentObservable[hasWriteFunctionName] = dependentObservable.hasWriteFunction = typeof writeFunction === "function";
    dependentObservable[disposeName] = dependentObservable.dispose = function () { dispose(); };
    dependentObservable[isActiveName] = dependentObservable.isActive = isActive;
    dependentObservable.getDependencies = function() {
        return ko.utils.arrayMap(
            ko.utils.arrayFilter(
                _subscriptionsToDependencies,
                function(item) {return item.event == 'change'}
            ),
            function(item) {return item.target}
        );
    };

    return dependentObservable;
};

// Set ko.computed properties
newComputed[koProtoName] = oldComputed[koProtoName];
newComputed.fn = oldComputed.fn;
newComputed.fn[koProtoName] = newComputed;
newComputed.deferUpdates = true;

// Make all pointers to ko.computed point to the new one
ko[computedName] = ko.computed = ko.dependentObservable = newComputed;

// Clear objects references we don't need anymore
oldComputed = computedProto = null;

/*
 * New throttle extender
 */
ko.extenders['throttle'] = function(target, timeout) {
    // Throttling means two things:

    if (ko.isWriteableObservable(target)) {
        // (1) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = ko.evaluateAsynchronously(function() {
                    target(value);
                }, timeout);
            }
        });
    } else {
        // (2) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;
        return target;
    }
};

})(ko);
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);
//     Backbone.js 0.9.2

//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `global`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to slice/splice.
  var slice = Array.prototype.slice;
  var splice = Array.prototype.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both CommonJS and the browser.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '0.9.2';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.
  var $ = root.jQuery || root.Zepto || root.ender;

  // Set the JavaScript library that will be used for DOM manipulation and
  // Ajax calls (a.k.a. the `$` variable). By default Backbone will use: jQuery,
  // Zepto, or Ender; but the `setDomLibrary()` method lets you inject an
  // alternate JavaScript library (or a mock library for testing your views
  // outside of a browser).
  Backbone.setDomLibrary = function(lib) {
    $ = lib;
  };

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // -----------------

  // Regular expression used to split event strings
  var eventSplitter = /\s+/;

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback functions
  // to an event; trigger`-ing an event fires all callbacks in succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind one or more space separated events, `events`, to a `callback`
    // function. Passing `"all"` will bind the callback to all events fired.
    on: function(events, callback, context) {

      var calls, event, node, tail, list;
      if (!callback) return this;
      events = events.split(eventSplitter);
      calls = this._callbacks || (this._callbacks = {});

      // Create an immutable callback list, allowing traversal during
      // modification.  The tail is an empty object that will always be used
      // as the next node.
      while (event = events.shift()) {
        list = calls[event];
        node = list ? list.tail : {};
        node.next = tail = {};
        node.context = context;
        node.callback = callback;
        calls[event] = {tail: tail, next: list ? list.next : node};
      }

      return this;
    },

    // Remove one or many callbacks. If `context` is null, removes all callbacks
    // with that function. If `callback` is null, removes all callbacks for the
    // event. If `events` is null, removes all bound callbacks for all events.
    off: function(events, callback, context) {
      var event, calls, node, tail, cb, ctx;

      // No events, or removing *all* events.
      if (!(calls = this._callbacks)) return;
      if (!(events || callback || context)) {
        delete this._callbacks;
        return this;
      }

      // Loop through the listed events and contexts, splicing them out of the
      // linked list of callbacks if appropriate.
      events = events ? events.split(eventSplitter) : _.keys(calls);
      while (event = events.shift()) {
        node = calls[event];
        delete calls[event];
        if (!node || !(callback || context)) continue;
        // Create a new list, omitting the indicated callbacks.
        tail = node.tail;
        while ((node = node.next) !== tail) {
          cb = node.callback;
          ctx = node.context;
          if ((callback && cb !== callback) || (context && ctx !== context)) {
            this.on(event, cb, ctx);
          }
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(events) {
      var event, node, calls, tail, args, all, rest;
      if (!(calls = this._callbacks)) return this;
      all = calls.all;
      events = events.split(eventSplitter);
      rest = slice.call(arguments, 1);

      // For each event, walk through the linked list of callbacks twice,
      // first to trigger the event, then to trigger any `"all"` callbacks.
      while (event = events.shift()) {
        if (node = calls[event]) {
          tail = node.tail;
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, rest);
          }
        }
        if (node = all) {
          tail = node.tail;
          args = [event].concat(rest);
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, args);
          }
        }
      }

      return this;
    }

  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Backbone.Model
  // --------------

  // Create a new model, with defined attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    attributes || (attributes = {});
    if (options && options.parse) attributes = this.parse(attributes);
    if (defaults = getValue(this, 'defaults')) {
      attributes = _.extend({}, defaults, attributes);
    }
    if (options && options.collection) this.collection = options.collection;
    this.attributes = {};
    this._escapedAttributes = {};
    this.cid = _.uniqueId('c');
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this.set(attributes, {silent: true});
    // Reset change tracking.
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this._previousAttributes = _.clone(this.attributes);
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // A hash of attributes that have silently changed since the last time
    // `change` was called.  Will become pending attributes on the next call.
    _silent: null,

    // A hash of attributes that have changed since the last `'change'` event
    // began.
    _pending: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      var html;
      if (html = this._escapedAttributes[attr]) return html;
      var val = this.get(attr);
      return this._escapedAttributes[attr] = _.escape(val == null ? '' : '' + val);
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"` unless
    // you choose to silence it.
    set: function(key, value, options) {
      var attrs, attr, val;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (_.isObject(key) || key == null) {
        attrs = key;
        options = value;
      } else {
        attrs = {};
        attrs[key] = value;
      }

      // Extract attributes and options.
      options || (options = {});
      if (!attrs) return this;
      if (attrs instanceof Model) attrs = attrs.attributes;
      if (options.unset) for (attr in attrs) attrs[attr] = void 0;

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      var changes = options.changes = {};
      var now = this.attributes;
      var escaped = this._escapedAttributes;
      var prev = this._previousAttributes || {};

      // For each `set` attribute...
      for (attr in attrs) {
        val = attrs[attr];

        // If the new and current value differ, record the change.
        if (!_.isEqual(now[attr], val) || (options.unset && _.has(now, attr))) {
          delete escaped[attr];
          (options.silent ? this._silent : changes)[attr] = true;
        }

        // Update or delete the current value.
        options.unset ? delete now[attr] : now[attr] = val;

        // If the new and previous value differ, record the change.  If not,
        // then remove changes for this attribute.
        if (!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) {
          this.changed[attr] = val;
          if (!options.silent) this._pending[attr] = true;
        } else {
          delete this.changed[attr];
          delete this._pending[attr];
        }
      }

      // Fire the `"change"` events.
      if (!options.silent) this.change(options);
      return this;
    },

    // Remove an attribute from the model, firing `"change"` unless you choose
    // to silence it. `unset` is a noop if the attribute doesn't exist.
    unset: function(attr, options) {
      (options || (options = {})).unset = true;
      return this.set(attr, null, options);
    },

    // Clear all attributes on the model, firing `"change"` unless you choose
    // to silence it.
    clear: function(options) {
      (options || (options = {})).unset = true;
      return this.set(_.clone(this.attributes), options);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overriden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        if (!model.set(model.parse(resp, xhr), options)) return false;
        if (success) success(model, resp);
      };
      options.error = Backbone.wrapError(options.error, model, options);
      return (this.sync || Backbone.sync).call(this, 'read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, value, options) {
      var attrs, current;

      // Handle both `("key", value)` and `({key: value})` -style calls.
      if (_.isObject(key) || key == null) {
        attrs = key;
        options = value;
      } else {
        attrs = {};
        attrs[key] = value;
      }
      options = options ? _.clone(options) : {};

      // If we're "wait"-ing to set changed attributes, validate early.
      if (options.wait) {
        if (!this._validate(attrs, options)) return false;
        current = _.clone(this.attributes);
      }

      // Regular saves `set` attributes before persisting to the server.
      var silentOptions = _.extend({}, options, {silent: true});
      if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        var serverAttrs = model.parse(resp, xhr);
        if (options.wait) {
          delete options.wait;
          serverAttrs = _.extend(attrs || {}, serverAttrs);
        }
        if (!model.set(serverAttrs, options)) return false;
        if (success) {
          success(model, resp);
        } else {
          model.trigger('sync', model, resp, options);
        }
      };

      // Finish configuring and sending the Ajax request.
      options.error = Backbone.wrapError(options.error, model, options);
      var method = this.isNew() ? 'create' : 'update';
      var xhr = (this.sync || Backbone.sync).call(this, method, this, options);
      if (options.wait) this.set(current, silentOptions);
      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var triggerDestroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      if (this.isNew()) {
        triggerDestroy();
        return false;
      }

      options.success = function(resp) {
        if (options.wait) triggerDestroy();
        if (success) {
          success(model, resp);
        } else {
          model.trigger('sync', model, resp, options);
        }
      };

      options.error = Backbone.wrapError(options.error, model, options);
      var xhr = (this.sync || Backbone.sync).call(this, 'delete', this, options);
      if (!options.wait) triggerDestroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = getValue(this, 'urlRoot') || getValue(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) == '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, xhr) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Call this method to manually fire a `"change"` event for this model and
    // a `"change:attribute"` event for each changed attribute.
    // Calling this will cause all objects observing the model to update.
    change: function(options) {
      options || (options = {});
      var changing = this._changing;
      this._changing = true;

      // Silent changes become pending changes.
      for (var attr in this._silent) this._pending[attr] = true;

      // Silent changes are triggered.
      var changes = _.extend({}, options.changes, this._silent);
      this._silent = {};
      for (var attr in changes) {
        this.trigger('change:' + attr, this, this.get(attr), options);
      }
      if (changing) return this;

      // Continue firing `"change"` events while there are pending changes.
      while (!_.isEmpty(this._pending)) {
        this._pending = {};
        this.trigger('change', this, options);
        // Pending and silent changes still remain.
        for (var attr in this.changed) {
          if (this._pending[attr] || this._silent[attr]) continue;
          delete this.changed[attr];
        }
        this._previousAttributes = _.clone(this.attributes);
      }

      this._changing = false;
      return this;
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (!arguments.length) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false, old = this._previousAttributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (!arguments.length || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Check if the model is currently in a valid state. It's only possible to
    // get into an *invalid* state if you're using silent changes.
    isValid: function() {
      return !this.validate(this.attributes);
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. If a specific `error` callback has
    // been passed, call that instead of firing the general `"error"` event.
    _validate: function(attrs, options) {
      if (options.silent || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validate(attrs, options);
      if (!error) return true;
      if (options && options.error) {
        options.error(this, error, options);
      } else {
        this.trigger('error', this, error, options);
      }
      return false;
    }

  });

  // Backbone.Collection
  // -------------------

  // Provides a standard collection class for our sets of models, ordered
  // or unordered. If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, {silent: true, parse: options.parse});
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Add a model, or list of models to the set. Pass **silent** to avoid
    // firing the `add` event for every new model.
    add: function(models, options) {
      var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];

      // Begin by turning bare objects into model references, and preventing
      // invalid models or duplicate models from being added.
      for (i = 0, length = models.length; i < length; i++) {
        if (!(model = models[i] = this._prepareModel(models[i], options))) {
          throw new Error("Can't add an invalid model to a collection");
        }
        cid = model.cid;
        id = model.id;
        if (cids[cid] || this._byCid[cid] || ((id != null) && (ids[id] || this._byId[id]))) {
          dups.push(i);
          continue;
        }
        cids[cid] = ids[id] = model;
      }

      // Remove duplicates.
      i = dups.length;
      while (i--) {
        models.splice(dups[i], 1);
      }

      // Listen to added models' events, and index models for lookup by
      // `id` and by `cid`.
      for (i = 0, length = models.length; i < length; i++) {
        (model = models[i]).on('all', this._onModelEvent, this);
        this._byCid[model.cid] = model;
        if (model.id != null) this._byId[model.id] = model;
      }

      // Insert models into the collection, re-sorting if needed, and triggering
      // `add` events unless silenced.
      this.length += length;
      index = options.at != null ? options.at : this.models.length;
      splice.apply(this.models, [index, 0].concat(models));
      if (this.comparator) this.sort({silent: true});
      if (options.silent) return this;
      for (i = 0, length = this.models.length; i < length; i++) {
        if (!cids[(model = this.models[i]).cid]) continue;
        options.index = i;
        model.trigger('add', model, this, options);
      }
      return this;
    },

    // Remove a model, or a list of models from the set. Pass silent to avoid
    // firing the `remove` event for every model removed.
    remove: function(models, options) {
      var i, l, index, model;
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];
      for (i = 0, l = models.length; i < l; i++) {
        model = this.getByCid(models[i]) || this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byCid[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, options);
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Get a model from the set by id.
    get: function(id) {
      if (id == null) return void 0;
      return this._byId[id.id != null ? id.id : id];
    },

    // Get a model from the set by client id.
    getByCid: function(cid) {
      return cid && this._byCid[cid.cid || cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of `filter`.
    where: function(attrs) {
      if (_.isEmpty(attrs)) return [];
      return this.filter(function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      options || (options = {});
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      var boundComparator = _.bind(this.comparator, this);
      if (this.comparator.length == 1) {
        this.models = this.sortBy(boundComparator);
      } else {
        this.models.sort(boundComparator);
      }
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.map(this.models, function(model){ return model.get(attr); });
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any `add` or `remove` events. Fires `reset` when finished.
    reset: function(models, options) {
      models  || (models = []);
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `add: true` is passed, appends the
    // models to the collection instead of resetting.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === undefined) options.parse = true;
      var collection = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options);
        if (success) success(collection, resp);
      };
      options.error = Backbone.wrapError(options.error, collection, options);
      return (this.sync || Backbone.sync).call(this, 'read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      var coll = this;
      options = options ? _.clone(options) : {};
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!options.wait) coll.add(model, options);
      var success = options.success;
      options.success = function(nextModel, resp, xhr) {
        if (options.wait) coll.add(nextModel, options);
        if (success) {
          success(nextModel, resp);
        } else {
          nextModel.trigger('sync', model, resp, options);
        }
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, xhr) {
      return resp;
    },

    // Proxy to _'s chain. Can't be proxied the same way the rest of the
    // underscore methods are proxied because it relies on the underscore
    // constructor.
    chain: function () {
      return _(this.models).chain();
    },

    // Reset all internal state. Called when the collection is reset.
    _reset: function(options) {
      this.length = 0;
      this.models = [];
      this._byId  = {};
      this._byCid = {};
    },

    // Prepare a model or hash of attributes to be added to this collection.
    _prepareModel: function(model, options) {
      options || (options = {});
      if (!(model instanceof Model)) {
        var attrs = model;
        options.collection = this;
        model = new this.model(attrs, options);
        if (!model._validate(model.attributes, options)) model = false;
      } else if (!model.collection) {
        model.collection = this;
      }
      return model;
    },

    // Internal method to remove a model's ties to a collection.
    _removeReference: function(model) {
      if (this == model.collection) {
        delete model.collection;
      }
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event == 'add' || event == 'remove') && collection != this) return;
      if (event == 'destroy') {
        this.remove(model, options);
      }
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',
    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',
    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',
    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',
    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));
    };
  });

  // Backbone.Router
  // -------------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var namedParam    = /:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[-[\]{}()+?.,\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      Backbone.history || (Backbone.history = new History);
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (!callback) callback = this[name];
      Backbone.history.route(route, _.bind(function(fragment) {
        var args = this._extractParameters(route, fragment);
        callback && callback.apply(this, args);
        this.trigger.apply(this, ['route:' + name].concat(args));
        Backbone.history.trigger('route', this, name, args);
      }, this));
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      var routes = [];
      for (var route in this.routes) {
        routes.unshift([route, this.routes[route]]);
      }
      for (var i = 0, l = routes.length; i < l; i++) {
        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(namedParam, '([^\/]+)')
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted parameters.
    _extractParameters: function(route, fragment) {
      return route.exec(fragment).slice(1);
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on URL fragments. If the
  // browser does not support `onhashchange`, falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');
  };

  // Cached regex for cleaning leading hashes and slashes .
  var routeStripper = /^[#\/]/;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(windowOverride) {
      var loc = windowOverride ? windowOverride.location : window.location;
      var match = loc.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || forcePushState) {
          fragment = window.location.pathname;
          var search = window.location.search;
          if (search) fragment += search;
        } else {
          fragment = this.getHash();
        }
      }
      if (!fragment.indexOf(this.options.root)) fragment = fragment.substr(this.options.root.length);
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && window.history && window.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      if (oldIE) {
        this.iframe = $('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        $(window).bind('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        $(window).bind('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = window.location;
      var atRoot  = loc.pathname == this.options.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        window.location.replace(this.options.root + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        window.history.replaceState({}, document.title, loc.protocol + '//' + loc.host + this.options.root + this.fragment);
      }

      if (!this.options.silent) {
        return this.loadUrl();
      }
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current == this.fragment && this.iframe) current = this.getFragment(this.getHash(this.iframe));
      if (current == this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      var frag = (fragment || '').replace(routeStripper, '');
      if (this.fragment == frag) return;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        if (frag.indexOf(this.options.root) != 0) frag = this.options.root + frag;
        this.fragment = frag;
        window.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, frag);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this.fragment = frag;
        this._updateHash(window.location, frag, options.replace);
        if (this.iframe && (frag != this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a history entry on hash-tag change.
          // When replace is true, we don't want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, frag, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        window.location.assign(this.options.root + fragment);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        location.replace(location.toString().replace(/(javascript:|#).*$/, '') + '#' + fragment);
      } else {
        location.hash = fragment;
      }
    }
  });

  // Backbone.View
  // -------------

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view from the DOM. Note that the view isn't present in the
    // DOM by default, so calling this method may be a no-op.
    remove: function() {
      this.$el.remove();
      return this;
    },

    // For small amounts of DOM Elements, where a full-blown template isn't
    // needed, use **make** to manufacture elements, one at a time.
    //
    //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));
    //
    make: function(tagName, attributes, content) {
      var el = document.createElement(tagName);
      if (attributes) $(el).attr(attributes);
      if (content) $(el).html(content);
      return el;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = (element instanceof $) ? element : $(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = getValue(this, 'events')))) return;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) throw new Error('Method "' + events[key] + '" does not exist');
        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.bind(eventName, method);
        } else {
          this.$el.delegate(selector, eventName, method);
        }
      }
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.unbind('.delegateEvents' + this.cid);
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(model, collection, id, className)*, are
    // attached directly to the view.
    _configure: function(options) {
      if (this.options) options = _.extend({}, this.options, options);
      for (var i = 0, l = viewOptions.length; i < l; i++) {
        var attr = viewOptions[i];
        if (options[attr]) this[attr] = options[attr];
      }
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = getValue(this, 'attributes') || {};
        if (this.id) attrs.id = this.id;
        if (this.className) attrs['class'] = this.className;
        this.setElement(this.make(this.tagName, attrs), false);
      } else {
        this.setElement(this.el, false);
      }
    }

  });

  // The self-propagating extend function that Backbone classes use.
  var extend = function (protoProps, classProps) {
    var child = inherits(this, protoProps, classProps);
    child.extend = this.extend;
    return child;
  };

  // Set up inheritance for the model, collection, and view.
  Model.extend = Collection.extend = Router.extend = View.extend = extend;

  // Backbone.sync
  // -------------

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    options || (options = {});

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = getValue(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (!options.data && model && (method == 'create' || method == 'update')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(model.toJSON());
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (Backbone.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (Backbone.emulateHTTP) {
      if (type === 'PUT' || type === 'DELETE') {
        if (Backbone.emulateJSON) params.data._method = type;
        params.type = 'POST';
        params.beforeSend = function(xhr) {
          xhr.setRequestHeader('X-HTTP-Method-Override', type);
        };
      }
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !Backbone.emulateJSON) {
      params.processData = false;
    }

    // Make the request, allowing the user to override any Ajax options.
    return $.ajax(_.extend(params, options));
  };

  // Wrap an optional error callback with a fallback error event.
  Backbone.wrapError = function(onError, originalModel, options) {
    return function(model, resp) {
      resp = model === originalModel ? resp : model;
      if (onError) {
        onError(originalModel, resp, options);
      } else {
        originalModel.trigger('error', originalModel, resp, options);
      }
    };
  };

  // Helpers
  // -------

  // Shared empty constructor function to aid in prototype-chain creation.
  var ctor = function(){};

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var inherits = function(parent, protoProps, staticProps) {
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ parent.apply(this, arguments); };
    }

    // Inherit class (static) properties from parent.
    _.extend(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Add static properties to the constructor function, if supplied.
    if (staticProps) _.extend(child, staticProps);

    // Correctly set child's `prototype.constructor`.
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Helper function to get a value from a Backbone object as a property
  // or as a function.
  var getValue = function(object, prop) {
    if (!(object && object[prop])) return null;
    return _.isFunction(object[prop]) ? object[prop]() : object[prop];
  };

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

}).call(this);
/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.core.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){function c(b,c){var e=b.nodeName.toLowerCase();if("area"===e){var f=b.parentNode,g=f.name,h;return!b.href||!g||f.nodeName.toLowerCase()!=="map"?!1:(h=a("img[usemap=#"+g+"]")[0],!!h&&d(h))}return(/input|select|textarea|button|object/.test(e)?!b.disabled:"a"==e?b.href||c:c)&&d(b)}function d(b){return!a(b).parents().andSelf().filter(function(){return a.curCSS(this,"visibility")==="hidden"||a.expr.filters.hidden(this)}).length}a.ui=a.ui||{};if(a.ui.version)return;a.extend(a.ui,{version:"1.8.22",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}}),a.fn.extend({propAttr:a.fn.prop||a.fn.attr,_focus:a.fn.focus,focus:function(b,c){return typeof b=="number"?this.each(function(){var d=this;setTimeout(function(){a(d).focus(),c&&c.call(d)},b)}):this._focus.apply(this,arguments)},scrollParent:function(){var b;return a.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?b=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(a.curCSS(this,"position",1))&&/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0):b=this.parents().filter(function(){return/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0),/fixed/.test(this.css("position"))||!b.length?a(document):b},zIndex:function(c){if(c!==b)return this.css("zIndex",c);if(this.length){var d=a(this[0]),e,f;while(d.length&&d[0]!==document){e=d.css("position");if(e==="absolute"||e==="relative"||e==="fixed"){f=parseInt(d.css("zIndex"),10);if(!isNaN(f)&&f!==0)return f}d=d.parent()}}return 0},disableSelection:function(){return this.bind((a.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),a("<a>").outerWidth(1).jquery||a.each(["Width","Height"],function(c,d){function h(b,c,d,f){return a.each(e,function(){c-=parseFloat(a.curCSS(b,"padding"+this,!0))||0,d&&(c-=parseFloat(a.curCSS(b,"border"+this+"Width",!0))||0),f&&(c-=parseFloat(a.curCSS(b,"margin"+this,!0))||0)}),c}var e=d==="Width"?["Left","Right"]:["Top","Bottom"],f=d.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+d]=function(c){return c===b?g["inner"+d].call(this):this.each(function(){a(this).css(f,h(this,c)+"px")})},a.fn["outer"+d]=function(b,c){return typeof b!="number"?g["outer"+d].call(this,b):this.each(function(){a(this).css(f,h(this,b,!0,c)+"px")})}}),a.extend(a.expr[":"],{data:a.expr.createPseudo?a.expr.createPseudo(function(b){return function(c){return!!a.data(c,b)}}):function(b,c,d){return!!a.data(b,d[3])},focusable:function(b){return c(b,!isNaN(a.attr(b,"tabindex")))},tabbable:function(b){var d=a.attr(b,"tabindex"),e=isNaN(d);return(e||d>=0)&&c(b,!e)}}),a(function(){var b=document.body,c=b.appendChild(c=document.createElement("div"));c.offsetHeight,a.extend(c.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),a.support.minHeight=c.offsetHeight===100,a.support.selectstart="onselectstart"in c,b.removeChild(c).style.display="none"}),a.curCSS||(a.curCSS=a.css),a.extend(a.ui,{plugin:{add:function(b,c,d){var e=a.ui[b].prototype;for(var f in d)e.plugins[f]=e.plugins[f]||[],e.plugins[f].push([c,d[f]])},call:function(a,b,c){var d=a.plugins[b];if(!d||!a.element[0].parentNode)return;for(var e=0;e<d.length;e++)a.options[d[e][0]]&&d[e][1].apply(a.element,c)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(b,c){if(a(b).css("overflow")==="hidden")return!1;var d=c&&c==="left"?"scrollLeft":"scrollTop",e=!1;return b[d]>0?!0:(b[d]=1,e=b[d]>0,b[d]=0,e)},isOverAxis:function(a,b,c){return a>b&&a<b+c},isOver:function(b,c,d,e,f,g){return a.ui.isOverAxis(b,d,f)&&a.ui.isOverAxis(c,e,g)}})})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.widget.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){if(a.cleanData){var c=a.cleanData;a.cleanData=function(b){for(var d=0,e;(e=b[d])!=null;d++)try{a(e).triggerHandler("remove")}catch(f){}c(b)}}else{var d=a.fn.remove;a.fn.remove=function(b,c){return this.each(function(){return c||(!b||a.filter(b,[this]).length)&&a("*",this).add([this]).each(function(){try{a(this).triggerHandler("remove")}catch(b){}}),d.call(a(this),b,c)})}}a.widget=function(b,c,d){var e=b.split(".")[0],f;b=b.split(".")[1],f=e+"-"+b,d||(d=c,c=a.Widget),a.expr[":"][f]=function(c){return!!a.data(c,b)},a[e]=a[e]||{},a[e][b]=function(a,b){arguments.length&&this._createWidget(a,b)};var g=new c;g.options=a.extend(!0,{},g.options),a[e][b].prototype=a.extend(!0,g,{namespace:e,widgetName:b,widgetEventPrefix:a[e][b].prototype.widgetEventPrefix||b,widgetBaseClass:f},d),a.widget.bridge(b,a[e][b])},a.widget.bridge=function(c,d){a.fn[c]=function(e){var f=typeof e=="string",g=Array.prototype.slice.call(arguments,1),h=this;return e=!f&&g.length?a.extend.apply(null,[!0,e].concat(g)):e,f&&e.charAt(0)==="_"?h:(f?this.each(function(){var d=a.data(this,c),f=d&&a.isFunction(d[e])?d[e].apply(d,g):d;if(f!==d&&f!==b)return h=f,!1}):this.each(function(){var b=a.data(this,c);b?b.option(e||{})._init():a.data(this,c,new d(e,this))}),h)}},a.Widget=function(a,b){arguments.length&&this._createWidget(a,b)},a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:!1},_createWidget:function(b,c){a.data(c,this.widgetName,this),this.element=a(c),this.options=a.extend(!0,{},this.options,this._getCreateOptions(),b);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()}),this._create(),this._trigger("create"),this._init()},_getCreateOptions:function(){return a.metadata&&a.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName),this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled")},widget:function(){return this.element},option:function(c,d){var e=c;if(arguments.length===0)return a.extend({},this.options);if(typeof c=="string"){if(d===b)return this.options[c];e={},e[c]=d}return this._setOptions(e),this},_setOptions:function(b){var c=this;return a.each(b,function(a,b){c._setOption(a,b)}),this},_setOption:function(a,b){return this.options[a]=b,a==="disabled"&&this.widget()[b?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",b),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_trigger:function(b,c,d){var e,f,g=this.options[b];d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent;if(f)for(e in f)e in c||(c[e]=f[e]);return this.element.trigger(c,d),!(a.isFunction(g)&&g.call(this.element[0],c,d)===!1||c.isDefaultPrevented())}}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.mouse.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){var c=!1;a(document).mouseup(function(a){c=!1}),a.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var b=this;this.element.bind("mousedown."+this.widgetName,function(a){return b._mouseDown(a)}).bind("click."+this.widgetName,function(c){if(!0===a.data(c.target,b.widgetName+".preventClickEvent"))return a.removeData(c.target,b.widgetName+".preventClickEvent"),c.stopImmediatePropagation(),!1}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),a(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(b){if(c)return;this._mouseStarted&&this._mouseUp(b),this._mouseDownEvent=b;var d=this,e=b.which==1,f=typeof this.options.cancel=="string"&&b.target.nodeName?a(b.target).closest(this.options.cancel).length:!1;if(!e||f||!this._mouseCapture(b))return!0;this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){d.mouseDelayMet=!0},this.options.delay));if(this._mouseDistanceMet(b)&&this._mouseDelayMet(b)){this._mouseStarted=this._mouseStart(b)!==!1;if(!this._mouseStarted)return b.preventDefault(),!0}return!0===a.data(b.target,this.widgetName+".preventClickEvent")&&a.removeData(b.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(a){return d._mouseMove(a)},this._mouseUpDelegate=function(a){return d._mouseUp(a)},a(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),b.preventDefault(),c=!0,!0},_mouseMove:function(b){return!a.browser.msie||document.documentMode>=9||!!b.button?this._mouseStarted?(this._mouseDrag(b),b.preventDefault()):(this._mouseDistanceMet(b)&&this._mouseDelayMet(b)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,b)!==!1,this._mouseStarted?this._mouseDrag(b):this._mouseUp(b)),!this._mouseStarted):this._mouseUp(b)},_mouseUp:function(b){return a(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,b.target==this._mouseDownEvent.target&&a.data(b.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(b)),!1},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(a){return this.mouseDelayMet},_mouseStart:function(a){},_mouseDrag:function(a){},_mouseStop:function(a){},_mouseCapture:function(a){return!0}})})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.position.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.ui=a.ui||{};var c=/left|center|right/,d=/top|center|bottom/,e="center",f={},g=a.fn.position,h=a.fn.offset;a.fn.position=function(b){if(!b||!b.of)return g.apply(this,arguments);b=a.extend({},b);var h=a(b.of),i=h[0],j=(b.collision||"flip").split(" "),k=b.offset?b.offset.split(" "):[0,0],l,m,n;return i.nodeType===9?(l=h.width(),m=h.height(),n={top:0,left:0}):i.setTimeout?(l=h.width(),m=h.height(),n={top:h.scrollTop(),left:h.scrollLeft()}):i.preventDefault?(b.at="left top",l=m=0,n={top:b.of.pageY,left:b.of.pageX}):(l=h.outerWidth(),m=h.outerHeight(),n=h.offset()),a.each(["my","at"],function(){var a=(b[this]||"").split(" ");a.length===1&&(a=c.test(a[0])?a.concat([e]):d.test(a[0])?[e].concat(a):[e,e]),a[0]=c.test(a[0])?a[0]:e,a[1]=d.test(a[1])?a[1]:e,b[this]=a}),j.length===1&&(j[1]=j[0]),k[0]=parseInt(k[0],10)||0,k.length===1&&(k[1]=k[0]),k[1]=parseInt(k[1],10)||0,b.at[0]==="right"?n.left+=l:b.at[0]===e&&(n.left+=l/2),b.at[1]==="bottom"?n.top+=m:b.at[1]===e&&(n.top+=m/2),n.left+=k[0],n.top+=k[1],this.each(function(){var c=a(this),d=c.outerWidth(),g=c.outerHeight(),h=parseInt(a.curCSS(this,"marginLeft",!0))||0,i=parseInt(a.curCSS(this,"marginTop",!0))||0,o=d+h+(parseInt(a.curCSS(this,"marginRight",!0))||0),p=g+i+(parseInt(a.curCSS(this,"marginBottom",!0))||0),q=a.extend({},n),r;b.my[0]==="right"?q.left-=d:b.my[0]===e&&(q.left-=d/2),b.my[1]==="bottom"?q.top-=g:b.my[1]===e&&(q.top-=g/2),f.fractions||(q.left=Math.round(q.left),q.top=Math.round(q.top)),r={left:q.left-h,top:q.top-i},a.each(["left","top"],function(c,e){a.ui.position[j[c]]&&a.ui.position[j[c]][e](q,{targetWidth:l,targetHeight:m,elemWidth:d,elemHeight:g,collisionPosition:r,collisionWidth:o,collisionHeight:p,offset:k,my:b.my,at:b.at})}),a.fn.bgiframe&&c.bgiframe(),c.offset(a.extend(q,{using:b.using}))})},a.ui.position={fit:{left:function(b,c){var d=a(window),e=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft();b.left=e>0?b.left-e:Math.max(b.left-c.collisionPosition.left,b.left)},top:function(b,c){var d=a(window),e=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop();b.top=e>0?b.top-e:Math.max(b.top-c.collisionPosition.top,b.top)}},flip:{left:function(b,c){if(c.at[0]===e)return;var d=a(window),f=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft(),g=c.my[0]==="left"?-c.elemWidth:c.my[0]==="right"?c.elemWidth:0,h=c.at[0]==="left"?c.targetWidth:-c.targetWidth,i=-2*c.offset[0];b.left+=c.collisionPosition.left<0?g+h+i:f>0?g+h+i:0},top:function(b,c){if(c.at[1]===e)return;var d=a(window),f=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop(),g=c.my[1]==="top"?-c.elemHeight:c.my[1]==="bottom"?c.elemHeight:0,h=c.at[1]==="top"?c.targetHeight:-c.targetHeight,i=-2*c.offset[1];b.top+=c.collisionPosition.top<0?g+h+i:f>0?g+h+i:0}}},a.offset.setOffset||(a.offset.setOffset=function(b,c){/static/.test(a.curCSS(b,"position"))&&(b.style.position="relative");var d=a(b),e=d.offset(),f=parseInt(a.curCSS(b,"top",!0),10)||0,g=parseInt(a.curCSS(b,"left",!0),10)||0,h={top:c.top-e.top+f,left:c.left-e.left+g};"using"in c?c.using.call(b,h):d.css(h)},a.fn.offset=function(b){var c=this[0];return!c||!c.ownerDocument?null:b?a.isFunction(b)?this.each(function(c){a(this).offset(b.call(this,c,a(this).offset()))}):this.each(function(){a.offset.setOffset(this,b)}):h.call(this)}),function(){var b=document.getElementsByTagName("body")[0],c=document.createElement("div"),d,e,g,h,i;d=document.createElement(b?"div":"body"),g={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},b&&a.extend(g,{position:"absolute",left:"-1000px",top:"-1000px"});for(var j in g)d.style[j]=g[j];d.appendChild(c),e=b||document.documentElement,e.insertBefore(d,e.firstChild),c.style.cssText="position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;",h=a(c).offset(function(a,b){return b}).offset(),d.innerHTML="",e.removeChild(d),i=h.top+h.left+(b?2e3:0),f.fractions=i>21&&i<22}()})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.draggable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.draggable",a.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1},_create:function(){this.options.helper=="original"&&!/^(?:r|a|f)/.test(this.element.css("position"))&&(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},destroy:function(){if(!this.element.data("draggable"))return;return this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy(),this},_mouseCapture:function(b){var c=this.options;return this.helper||c.disabled||a(b.target).is(".ui-resizable-handle")?!1:(this.handle=this._getHandle(b),this.handle?(c.iframeFix&&a(c.iframeFix===!0?"iframe":c.iframeFix).each(function(){a('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(a(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(b){var c=this.options;return this.helper=this._createHelper(b),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),a.ui.ddmanager&&(a.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},a.extend(this.offset,{click:{left:b.pageX-this.offset.left,top:b.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(b),this.originalPageX=b.pageX,this.originalPageY=b.pageY,c.cursorAt&&this._adjustOffsetFromHelper(c.cursorAt),c.containment&&this._setContainment(),this._trigger("start",b)===!1?(this._clear(),!1):(this._cacheHelperProportions(),a.ui.ddmanager&&!c.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b),this._mouseDrag(b,!0),a.ui.ddmanager&&a.ui.ddmanager.dragStart(this,b),!0)},_mouseDrag:function(b,c){this.position=this._generatePosition(b),this.positionAbs=this._convertPositionTo("absolute");if(!c){var d=this._uiHash();if(this._trigger("drag",b,d)===!1)return this._mouseUp({}),!1;this.position=d.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";return a.ui.ddmanager&&a.ui.ddmanager.drag(this,b),!1},_mouseStop:function(b){var c=!1;a.ui.ddmanager&&!this.options.dropBehaviour&&(c=a.ui.ddmanager.drop(this,b)),this.dropped&&(c=this.dropped,this.dropped=!1);var d=this.element[0],e=!1;while(d&&(d=d.parentNode))d==document&&(e=!0);if(!e&&this.options.helper==="original")return!1;if(this.options.revert=="invalid"&&!c||this.options.revert=="valid"&&c||this.options.revert===!0||a.isFunction(this.options.revert)&&this.options.revert.call(this.element,c)){var f=this;a(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){f._trigger("stop",b)!==!1&&f._clear()})}else this._trigger("stop",b)!==!1&&this._clear();return!1},_mouseUp:function(b){return this.options.iframeFix===!0&&a("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),a.ui.ddmanager&&a.ui.ddmanager.dragStop(this,b),a.ui.mouse.prototype._mouseUp.call(this,b)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(b){var c=!this.options.handle||!a(this.options.handle,this.element).length?!0:!1;return a(this.options.handle,this.element).find("*").andSelf().each(function(){this==b.target&&(c=!0)}),c},_createHelper:function(b){var c=this.options,d=a.isFunction(c.helper)?a(c.helper.apply(this.element[0],[b])):c.helper=="clone"?this.element.clone().removeAttr("id"):this.element;return d.parents("body").length||d.appendTo(c.appendTo=="parent"?this.element[0].parentNode:c.appendTo),d[0]!=this.element[0]&&!/(fixed|absolute)/.test(d.css("position"))&&d.css("position","absolute"),d},_adjustOffsetFromHelper:function(b){typeof b=="string"&&(b=b.split(" ")),a.isArray(b)&&(b={left:+b[0],top:+b[1]||0}),"left"in b&&(this.offset.click.left=b.left+this.margins.left),"right"in b&&(this.offset.click.left=this.helperProportions.width-b.right+this.margins.left),"top"in b&&(this.offset.click.top=b.top+this.margins.top),"bottom"in b&&(this.offset.click.top=this.helperProportions.height-b.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var b=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&a.ui.contains(this.scrollParent[0],this.offsetParent[0])&&(b.left+=this.scrollParent.scrollLeft(),b.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&a.browser.msie)b={top:0,left:0};return{top:b.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:b.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var b=this.options;b.containment=="parent"&&(b.containment=this.helper[0].parentNode);if(b.containment=="document"||b.containment=="window")this.containment=[b.containment=="document"?0:a(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,b.containment=="document"?0:a(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,(b.containment=="document"?0:a(window).scrollLeft())+a(b.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(b.containment=="document"?0:a(window).scrollTop())+(a(b.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(b.containment)&&b.containment.constructor!=Array){var c=a(b.containment),d=c[0];if(!d)return;var e=c.offset(),f=a(d).css("overflow")!="hidden";this.containment=[(parseInt(a(d).css("borderLeftWidth"),10)||0)+(parseInt(a(d).css("paddingLeft"),10)||0),(parseInt(a(d).css("borderTopWidth"),10)||0)+(parseInt(a(d).css("paddingTop"),10)||0),(f?Math.max(d.scrollWidth,d.offsetWidth):d.offsetWidth)-(parseInt(a(d).css("borderLeftWidth"),10)||0)-(parseInt(a(d).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(f?Math.max(d.scrollHeight,d.offsetHeight):d.offsetHeight)-(parseInt(a(d).css("borderTopWidth"),10)||0)-(parseInt(a(d).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=c}else b.containment.constructor==Array&&(this.containment=b.containment)},_convertPositionTo:function(b,c){c||(c=this.position);var d=b=="absolute"?1:-1,e=this.options,f=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,g=/(html|body)/i.test(f[0].tagName);return{top:c.top+this.offset.relative.top*d+this.offset.parent.top*d-(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():g?0:f.scrollTop())*d),left:c.left+this.offset.relative.left*d+this.offset.parent.left*d-(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():g?0:f.scrollLeft())*d)}},_generatePosition:function(b){var c=this.options,d=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(d[0].tagName),f=b.pageX,g=b.pageY;if(this.originalPosition){var h;if(this.containment){if(this.relative_container){var i=this.relative_container.offset();h=[this.containment[0]+i.left,this.containment[1]+i.top,this.containment[2]+i.left,this.containment[3]+i.top]}else h=this.containment;b.pageX-this.offset.click.left<h[0]&&(f=h[0]+this.offset.click.left),b.pageY-this.offset.click.top<h[1]&&(g=h[1]+this.offset.click.top),b.pageX-this.offset.click.left>h[2]&&(f=h[2]+this.offset.click.left),b.pageY-this.offset.click.top>h[3]&&(g=h[3]+this.offset.click.top)}if(c.grid){var j=c.grid[1]?this.originalPageY+Math.round((g-this.originalPageY)/c.grid[1])*c.grid[1]:this.originalPageY;g=h?j-this.offset.click.top<h[1]||j-this.offset.click.top>h[3]?j-this.offset.click.top<h[1]?j+c.grid[1]:j-c.grid[1]:j:j;var k=c.grid[0]?this.originalPageX+Math.round((f-this.originalPageX)/c.grid[0])*c.grid[0]:this.originalPageX;f=h?k-this.offset.click.left<h[0]||k-this.offset.click.left>h[2]?k-this.offset.click.left<h[0]?k+c.grid[0]:k-c.grid[0]:k:k}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:d.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:d.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(b,c,d){return d=d||this._uiHash(),a.ui.plugin.call(this,b,[c,d]),b=="drag"&&(this.positionAbs=this._convertPositionTo("absolute")),a.Widget.prototype._trigger.call(this,b,c,d)},plugins:{},_uiHash:function(a){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),a.extend(a.ui.draggable,{version:"1.8.22"}),a.ui.plugin.add("draggable","connectToSortable",{start:function(b,c){var d=a(this).data("draggable"),e=d.options,f=a.extend({},c,{item:d.element});d.sortables=[],a(e.connectToSortable).each(function(){var c=a.data(this,"sortable");c&&!c.options.disabled&&(d.sortables.push({instance:c,shouldRevert:c.options.revert}),c.refreshPositions(),c._trigger("activate",b,f))})},stop:function(b,c){var d=a(this).data("draggable"),e=a.extend({},c,{item:d.element});a.each(d.sortables,function(){this.instance.isOver?(this.instance.isOver=0,d.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=!0),this.instance._mouseStop(b),this.instance.options.helper=this.instance.options._helper,d.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",b,e))})},drag:function(b,c){var d=a(this).data("draggable"),e=this,f=function(b){var c=this.offset.click.top,d=this.offset.click.left,e=this.positionAbs.top,f=this.positionAbs.left,g=b.height,h=b.width,i=b.top,j=b.left;return a.ui.isOver(e+c,f+d,i,j,g,h)};a.each(d.sortables,function(f){this.instance.positionAbs=d.positionAbs,this.instance.helperProportions=d.helperProportions,this.instance.offset.click=d.offset.click,this.instance._intersectsWith(this.instance.containerCache)?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=a(e).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return c.helper[0]},b.target=this.instance.currentItem[0],this.instance._mouseCapture(b,!0),this.instance._mouseStart(b,!0,!0),this.instance.offset.click.top=d.offset.click.top,this.instance.offset.click.left=d.offset.click.left,this.instance.offset.parent.left-=d.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=d.offset.parent.top-this.instance.offset.parent.top,d._trigger("toSortable",b),d.dropped=this.instance.element,d.currentItem=d.element,this.instance.fromOutside=d),this.instance.currentItem&&this.instance._mouseDrag(b)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",b,this.instance._uiHash(this.instance)),this.instance._mouseStop(b,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),d._trigger("fromSortable",b),d.dropped=!1)})}}),a.ui.plugin.add("draggable","cursor",{start:function(b,c){var d=a("body"),e=a(this).data("draggable").options;d.css("cursor")&&(e._cursor=d.css("cursor")),d.css("cursor",e.cursor)},stop:function(b,c){var d=a(this).data("draggable").options;d._cursor&&a("body").css("cursor",d._cursor)}}),a.ui.plugin.add("draggable","opacity",{start:function(b,c){var d=a(c.helper),e=a(this).data("draggable").options;d.css("opacity")&&(e._opacity=d.css("opacity")),d.css("opacity",e.opacity)},stop:function(b,c){var d=a(this).data("draggable").options;d._opacity&&a(c.helper).css("opacity",d._opacity)}}),a.ui.plugin.add("draggable","scroll",{start:function(b,c){var d=a(this).data("draggable");d.scrollParent[0]!=document&&d.scrollParent[0].tagName!="HTML"&&(d.overflowOffset=d.scrollParent.offset())},drag:function(b,c){var d=a(this).data("draggable"),e=d.options,f=!1;if(d.scrollParent[0]!=document&&d.scrollParent[0].tagName!="HTML"){if(!e.axis||e.axis!="x")d.overflowOffset.top+d.scrollParent[0].offsetHeight-b.pageY<e.scrollSensitivity?d.scrollParent[0].scrollTop=f=d.scrollParent[0].scrollTop+e.scrollSpeed:b.pageY-d.overflowOffset.top<e.scrollSensitivity&&(d.scrollParent[0].scrollTop=f=d.scrollParent[0].scrollTop-e.scrollSpeed);if(!e.axis||e.axis!="y")d.overflowOffset.left+d.scrollParent[0].offsetWidth-b.pageX<e.scrollSensitivity?d.scrollParent[0].scrollLeft=f=d.scrollParent[0].scrollLeft+e.scrollSpeed:b.pageX-d.overflowOffset.left<e.scrollSensitivity&&(d.scrollParent[0].scrollLeft=f=d.scrollParent[0].scrollLeft-e.scrollSpeed)}else{if(!e.axis||e.axis!="x")b.pageY-a(document).scrollTop()<e.scrollSensitivity?f=a(document).scrollTop(a(document).scrollTop()-e.scrollSpeed):a(window).height()-(b.pageY-a(document).scrollTop())<e.scrollSensitivity&&(f=a(document).scrollTop(a(document).scrollTop()+e.scrollSpeed));if(!e.axis||e.axis!="y")b.pageX-a(document).scrollLeft()<e.scrollSensitivity?f=a(document).scrollLeft(a(document).scrollLeft()-e.scrollSpeed):a(window).width()-(b.pageX-a(document).scrollLeft())<e.scrollSensitivity&&(f=a(document).scrollLeft(a(document).scrollLeft()+e.scrollSpeed))}f!==!1&&a.ui.ddmanager&&!e.dropBehaviour&&a.ui.ddmanager.prepareOffsets(d,b)}}),a.ui.plugin.add("draggable","snap",{start:function(b,c){var d=a(this).data("draggable"),e=d.options;d.snapElements=[],a(e.snap.constructor!=String?e.snap.items||":data(draggable)":e.snap).each(function(){var b=a(this),c=b.offset();this!=d.element[0]&&d.snapElements.push({item:this,width:b.outerWidth(),height:b.outerHeight(),top:c.top,left:c.left})})},drag:function(b,c){var d=a(this).data("draggable"),e=d.options,f=e.snapTolerance,g=c.offset.left,h=g+d.helperProportions.width,i=c.offset.top,j=i+d.helperProportions.height;for(var k=d.snapElements.length-1;k>=0;k--){var l=d.snapElements[k].left,m=l+d.snapElements[k].width,n=d.snapElements[k].top,o=n+d.snapElements[k].height;if(!(l-f<g&&g<m+f&&n-f<i&&i<o+f||l-f<g&&g<m+f&&n-f<j&&j<o+f||l-f<h&&h<m+f&&n-f<i&&i<o+f||l-f<h&&h<m+f&&n-f<j&&j<o+f)){d.snapElements[k].snapping&&d.options.snap.release&&d.options.snap.release.call(d.element,b,a.extend(d._uiHash(),{snapItem:d.snapElements[k].item})),d.snapElements[k].snapping=!1;continue}if(e.snapMode!="inner"){var p=Math.abs(n-j)<=f,q=Math.abs(o-i)<=f,r=Math.abs(l-h)<=f,s=Math.abs(m-g)<=f;p&&(c.position.top=d._convertPositionTo("relative",{top:n-d.helperProportions.height,left:0}).top-d.margins.top),q&&(c.position.top=d._convertPositionTo("relative",{top:o,left:0}).top-d.margins.top),r&&(c.position.left=d._convertPositionTo("relative",{top:0,left:l-d.helperProportions.width}).left-d.margins.left),s&&(c.position.left=d._convertPositionTo("relative",{top:0,left:m}).left-d.margins.left)}var t=p||q||r||s;if(e.snapMode!="outer"){var p=Math.abs(n-i)<=f,q=Math.abs(o-j)<=f,r=Math.abs(l-g)<=f,s=Math.abs(m-h)<=f;p&&(c.position.top=d._convertPositionTo("relative",{top:n,left:0}).top-d.margins.top),q&&(c.position.top=d._convertPositionTo("relative",{top:o-d.helperProportions.height,left:0}).top-d.margins.top),r&&(c.position.left=d._convertPositionTo("relative",{top:0,left:l}).left-d.margins.left),s&&(c.position.left=d._convertPositionTo("relative",{top:0,left:m-d.helperProportions.width}).left-d.margins.left)}!d.snapElements[k].snapping&&(p||q||r||s||t)&&d.options.snap.snap&&d.options.snap.snap.call(d.element,b,a.extend(d._uiHash(),{snapItem:d.snapElements[k].item})),d.snapElements[k].snapping=p||q||r||s||t}}}),a.ui.plugin.add("draggable","stack",{start:function(b,c){var d=a(this).data("draggable").options,e=a.makeArray(a(d.stack)).sort(function(b,c){return(parseInt(a(b).css("zIndex"),10)||0)-(parseInt(a(c).css("zIndex"),10)||0)});if(!e.length)return;var f=parseInt(e[0].style.zIndex)||0;a(e).each(function(a){this.style.zIndex=f+a}),this[0].style.zIndex=f+e.length}}),a.ui.plugin.add("draggable","zIndex",{start:function(b,c){var d=a(c.helper),e=a(this).data("draggable").options;d.css("zIndex")&&(e._zIndex=d.css("zIndex")),d.css("zIndex",e.zIndex)},stop:function(b,c){var d=a(this).data("draggable").options;d._zIndex&&a(c.helper).css("zIndex",d._zIndex)}})})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.droppable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.droppable",{widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect"},_create:function(){var b=this.options,c=b.accept;this.isover=0,this.isout=1,this.accept=a.isFunction(c)?c:function(a){return a.is(c)},this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight},a.ui.ddmanager.droppables[b.scope]=a.ui.ddmanager.droppables[b.scope]||[],a.ui.ddmanager.droppables[b.scope].push(this),b.addClasses&&this.element.addClass("ui-droppable")},destroy:function(){var b=a.ui.ddmanager.droppables[this.options.scope];for(var c=0;c<b.length;c++)b[c]==this&&b.splice(c,1);return this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable"),this},_setOption:function(b,c){b=="accept"&&(this.accept=a.isFunction(c)?c:function(a){return a.is(c)}),a.Widget.prototype._setOption.apply(this,arguments)},_activate:function(b){var c=a.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),c&&this._trigger("activate",b,this.ui(c))},_deactivate:function(b){var c=a.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),c&&this._trigger("deactivate",b,this.ui(c))},_over:function(b){var c=a.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return;this.accept.call(this.element[0],c.currentItem||c.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",b,this.ui(c)))},_out:function(b){var c=a.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return;this.accept.call(this.element[0],c.currentItem||c.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",b,this.ui(c)))},_drop:function(b,c){var d=c||a.ui.ddmanager.current;if(!d||(d.currentItem||d.element)[0]==this.element[0])return!1;var e=!1;return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var b=a.data(this,"droppable");if(b.options.greedy&&!b.options.disabled&&b.options.scope==d.options.scope&&b.accept.call(b.element[0],d.currentItem||d.element)&&a.ui.intersect(d,a.extend(b,{offset:b.element.offset()}),b.options.tolerance))return e=!0,!1}),e?!1:this.accept.call(this.element[0],d.currentItem||d.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",b,this.ui(d)),this.element):!1},ui:function(a){return{draggable:a.currentItem||a.element,helper:a.helper,position:a.position,offset:a.positionAbs}}}),a.extend(a.ui.droppable,{version:"1.8.22"}),a.ui.intersect=function(b,c,d){if(!c.offset)return!1;var e=(b.positionAbs||b.position.absolute).left,f=e+b.helperProportions.width,g=(b.positionAbs||b.position.absolute).top,h=g+b.helperProportions.height,i=c.offset.left,j=i+c.proportions.width,k=c.offset.top,l=k+c.proportions.height;switch(d){case"fit":return i<=e&&f<=j&&k<=g&&h<=l;case"intersect":return i<e+b.helperProportions.width/2&&f-b.helperProportions.width/2<j&&k<g+b.helperProportions.height/2&&h-b.helperProportions.height/2<l;case"pointer":var m=(b.positionAbs||b.position.absolute).left+(b.clickOffset||b.offset.click).left,n=(b.positionAbs||b.position.absolute).top+(b.clickOffset||b.offset.click).top,o=a.ui.isOver(n,m,k,i,c.proportions.height,c.proportions.width);return o;case"touch":return(g>=k&&g<=l||h>=k&&h<=l||g<k&&h>l)&&(e>=i&&e<=j||f>=i&&f<=j||e<i&&f>j);default:return!1}},a.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(b,c){var d=a.ui.ddmanager.droppables[b.options.scope]||[],e=c?c.type:null,f=(b.currentItem||b.element).find(":data(droppable)").andSelf();g:for(var h=0;h<d.length;h++){if(d[h].options.disabled||b&&!d[h].accept.call(d[h].element[0],b.currentItem||b.element))continue;for(var i=0;i<f.length;i++)if(f[i]==d[h].element[0]){d[h].proportions.height=0;continue g}d[h].visible=d[h].element.css("display")!="none";if(!d[h].visible)continue;e=="mousedown"&&d[h]._activate.call(d[h],c),d[h].offset=d[h].element.offset(),d[h].proportions={width:d[h].element[0].offsetWidth,height:d[h].element[0].offsetHeight}}},drop:function(b,c){var d=!1;return a.each(a.ui.ddmanager.droppables[b.options.scope]||[],function(){if(!this.options)return;!this.options.disabled&&this.visible&&a.ui.intersect(b,this,this.options.tolerance)&&(d=this._drop.call(this,c)||d),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],b.currentItem||b.element)&&(this.isout=1,this.isover=0,this._deactivate.call(this,c))}),d},dragStart:function(b,c){b.element.parents(":not(body,html)").bind("scroll.droppable",function(){b.options.refreshPositions||a.ui.ddmanager.prepareOffsets(b,c)})},drag:function(b,c){b.options.refreshPositions&&a.ui.ddmanager.prepareOffsets(b,c),a.each(a.ui.ddmanager.droppables[b.options.scope]||[],function(){if(this.options.disabled||this.greedyChild||!this.visible)return;var d=a.ui.intersect(b,this,this.options.tolerance),e=!d&&this.isover==1?"isout":d&&this.isover==0?"isover":null;if(!e)return;var f;if(this.options.greedy){var g=this.element.parents(":data(droppable):eq(0)");g.length&&(f=a.data(g[0],"droppable"),f.greedyChild=e=="isover"?1:0)}f&&e=="isover"&&(f.isover=0,f.isout=1,f._out.call(f,c)),this[e]=1,this[e=="isout"?"isover":"isout"]=0,this[e=="isover"?"_over":"_out"].call(this,c),f&&e=="isout"&&(f.isout=0,f.isover=1,f._over.call(f,c))})},dragStop:function(b,c){b.element.parents(":not(body,html)").unbind("scroll.droppable"),b.options.refreshPositions||a.ui.ddmanager.prepareOffsets(b,c)}}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.resizable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.resizable",a.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1e3},_create:function(){var b=this,c=this.options;this.element.addClass("ui-resizable"),a.extend(this,{_aspectRatio:!!c.aspectRatio,aspectRatio:c.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:c.helper||c.ghost||c.animate?c.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(a('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("resizable",this.element.data("resizable")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=c.handles||(a(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se");if(this.handles.constructor==String){this.handles=="all"&&(this.handles="n,e,s,w,se,sw,ne,nw");var d=this.handles.split(",");this.handles={};for(var e=0;e<d.length;e++){var f=a.trim(d[e]),g="ui-resizable-"+f,h=a('<div class="ui-resizable-handle '+g+'"></div>');h.css({zIndex:c.zIndex}),"se"==f&&h.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[f]=".ui-resizable-"+f,this.element.append(h)}}this._renderAxis=function(b){b=b||this.element;for(var c in this.handles){this.handles[c].constructor==String&&(this.handles[c]=a(this.handles[c],this.element).show());if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var d=a(this.handles[c],this.element),e=0;e=/sw|ne|nw|se|n|s/.test(c)?d.outerHeight():d.outerWidth();var f=["padding",/ne|nw|n/.test(c)?"Top":/se|sw|s/.test(c)?"Bottom":/^e$/.test(c)?"Right":"Left"].join("");b.css(f,e),this._proportionallyResize()}if(!a(this.handles[c]).length)continue}},this._renderAxis(this.element),this._handles=a(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){if(!b.resizing){if(this.className)var a=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=a&&a[1]?a[1]:"se"}}),c.autoHide&&(this._handles.hide(),a(this.element).addClass("ui-resizable-autohide").hover(function(){if(c.disabled)return;a(this).removeClass("ui-resizable-autohide"),b._handles.show()},function(){if(c.disabled)return;b.resizing||(a(this).addClass("ui-resizable-autohide"),b._handles.hide())})),this._mouseInit()},destroy:function(){this._mouseDestroy();var b=function(b){a(b).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){b(this.element);var c=this.element;c.after(this.originalElement.css({position:c.css("position"),width:c.outerWidth(),height:c.outerHeight(),top:c.css("top"),left:c.css("left")})).remove()}return this.originalElement.css("resize",this.originalResizeStyle),b(this.originalElement),this},_mouseCapture:function(b){var c=!1;for(var d in this.handles)a(this.handles[d])[0]==b.target&&(c=!0);return!this.options.disabled&&c},_mouseStart:function(b){var d=this.options,e=this.element.position(),f=this.element;this.resizing=!0,this.documentScroll={top:a(document).scrollTop(),left:a(document).scrollLeft()},(f.is(".ui-draggable")||/absolute/.test(f.css("position")))&&f.css({position:"absolute",top:e.top,left:e.left}),this._renderProxy();var g=c(this.helper.css("left")),h=c(this.helper.css("top"));d.containment&&(g+=a(d.containment).scrollLeft()||0,h+=a(d.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:g,top:h},this.size=this._helper?{width:f.outerWidth(),height:f.outerHeight()}:{width:f.width(),height:f.height()},this.originalSize=this._helper?{width:f.outerWidth(),height:f.outerHeight()}:{width:f.width(),height:f.height()},this.originalPosition={left:g,top:h},this.sizeDiff={width:f.outerWidth()-f.width(),height:f.outerHeight()-f.height()},this.originalMousePosition={left:b.pageX,top:b.pageY},this.aspectRatio=typeof d.aspectRatio=="number"?d.aspectRatio:this.originalSize.width/this.originalSize.height||1;var i=a(".ui-resizable-"+this.axis).css("cursor");return a("body").css("cursor",i=="auto"?this.axis+"-resize":i),f.addClass("ui-resizable-resizing"),this._propagate("start",b),!0},_mouseDrag:function(b){var c=this.helper,d=this.options,e={},f=this,g=this.originalMousePosition,h=this.axis,i=b.pageX-g.left||0,j=b.pageY-g.top||0,k=this._change[h];if(!k)return!1;var l=k.apply(this,[b,i,j]),m=a.browser.msie&&a.browser.version<7,n=this.sizeDiff;this._updateVirtualBoundaries(b.shiftKey);if(this._aspectRatio||b.shiftKey)l=this._updateRatio(l,b);return l=this._respectSize(l,b),this._propagate("resize",b),c.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"}),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),this._updateCache(l),this._trigger("resize",b,this.ui()),!1},_mouseStop:function(b){this.resizing=!1;var c=this.options,d=this;if(this._helper){var e=this._proportionallyResizeElements,f=e.length&&/textarea/i.test(e[0].nodeName),g=f&&a.ui.hasScroll(e[0],"left")?0:d.sizeDiff.height,h=f?0:d.sizeDiff.width,i={width:d.helper.width()-h,height:d.helper.height()-g},j=parseInt(d.element.css("left"),10)+(d.position.left-d.originalPosition.left)||null,k=parseInt(d.element.css("top"),10)+(d.position.top-d.originalPosition.top)||null;c.animate||this.element.css(a.extend(i,{top:k,left:j})),d.helper.height(d.size.height),d.helper.width(d.size.width),this._helper&&!c.animate&&this._proportionallyResize()}return a("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",b),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(a){var b=this.options,c,e,f,g,h;h={minWidth:d(b.minWidth)?b.minWidth:0,maxWidth:d(b.maxWidth)?b.maxWidth:Infinity,minHeight:d(b.minHeight)?b.minHeight:0,maxHeight:d(b.maxHeight)?b.maxHeight:Infinity};if(this._aspectRatio||a)c=h.minHeight*this.aspectRatio,f=h.minWidth/this.aspectRatio,e=h.maxHeight*this.aspectRatio,g=h.maxWidth/this.aspectRatio,c>h.minWidth&&(h.minWidth=c),f>h.minHeight&&(h.minHeight=f),e<h.maxWidth&&(h.maxWidth=e),g<h.maxHeight&&(h.maxHeight=g);this._vBoundaries=h},_updateCache:function(a){var b=this.options;this.offset=this.helper.offset(),d(a.left)&&(this.position.left=a.left),d(a.top)&&(this.position.top=a.top),d(a.height)&&(this.size.height=a.height),d(a.width)&&(this.size.width=a.width)},_updateRatio:function(a,b){var c=this.options,e=this.position,f=this.size,g=this.axis;return d(a.height)?a.width=a.height*this.aspectRatio:d(a.width)&&(a.height=a.width/this.aspectRatio),g=="sw"&&(a.left=e.left+(f.width-a.width),a.top=null),g=="nw"&&(a.top=e.top+(f.height-a.height),a.left=e.left+(f.width-a.width)),a},_respectSize:function(a,b){var c=this.helper,e=this._vBoundaries,f=this._aspectRatio||b.shiftKey,g=this.axis,h=d(a.width)&&e.maxWidth&&e.maxWidth<a.width,i=d(a.height)&&e.maxHeight&&e.maxHeight<a.height,j=d(a.width)&&e.minWidth&&e.minWidth>a.width,k=d(a.height)&&e.minHeight&&e.minHeight>a.height;j&&(a.width=e.minWidth),k&&(a.height=e.minHeight),h&&(a.width=e.maxWidth),i&&(a.height=e.maxHeight);var l=this.originalPosition.left+this.originalSize.width,m=this.position.top+this.size.height,n=/sw|nw|w/.test(g),o=/nw|ne|n/.test(g);j&&n&&(a.left=l-e.minWidth),h&&n&&(a.left=l-e.maxWidth),k&&o&&(a.top=m-e.minHeight),i&&o&&(a.top=m-e.maxHeight);var p=!a.width&&!a.height;return p&&!a.left&&a.top?a.top=null:p&&!a.top&&a.left&&(a.left=null),a},_proportionallyResize:function(){var b=this.options;if(!this._proportionallyResizeElements.length)return;var c=this.helper||this.element;for(var d=0;d<this._proportionallyResizeElements.length;d++){var e=this._proportionallyResizeElements[d];if(!this.borderDif){var f=[e.css("borderTopWidth"),e.css("borderRightWidth"),e.css("borderBottomWidth"),e.css("borderLeftWidth")],g=[e.css("paddingTop"),e.css("paddingRight"),e.css("paddingBottom"),e.css("paddingLeft")];this.borderDif=a.map(f,function(a,b){var c=parseInt(a,10)||0,d=parseInt(g[b],10)||0;return c+d})}if(!a.browser.msie||!a(c).is(":hidden")&&!a(c).parents(":hidden").length)e.css({height:c.height()-this.borderDif[0]-this.borderDif[2]||0,width:c.width()-this.borderDif[1]-this.borderDif[3]||0});else continue}},_renderProxy:function(){var b=this.element,c=this.options;this.elementOffset=b.offset();if(this._helper){this.helper=this.helper||a('<div style="overflow:hidden;"></div>');var d=a.browser.msie&&a.browser.version<7,e=d?1:0,f=d?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+f,height:this.element.outerHeight()+f,position:"absolute",left:this.elementOffset.left-e+"px",top:this.elementOffset.top-e+"px",zIndex:++c.zIndex}),this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(a,b,c){return{width:this.originalSize.width+b}},w:function(a,b,c){var d=this.options,e=this.originalSize,f=this.originalPosition;return{left:f.left+b,width:e.width-b}},n:function(a,b,c){var d=this.options,e=this.originalSize,f=this.originalPosition;return{top:f.top+c,height:e.height-c}},s:function(a,b,c){return{height:this.originalSize.height+c}},se:function(b,c,d){return a.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,c,d]))},sw:function(b,c,d){return a.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,c,d]))},ne:function(b,c,d){return a.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,c,d]))},nw:function(b,c,d){return a.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,c,d]))}},_propagate:function(b,c){a.ui.plugin.call(this,b,[c,this.ui()]),b!="resize"&&this._trigger(b,c,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),a.extend(a.ui.resizable,{version:"1.8.22"}),a.ui.plugin.add("resizable","alsoResize",{start:function(b,c){var d=a(this).data("resizable"),e=d.options,f=function(b){a(b).each(function(){var b=a(this);b.data("resizable-alsoresize",{width:parseInt(b.width(),10),height:parseInt(b.height(),10),left:parseInt(b.css("left"),10),top:parseInt(b.css("top"),10)})})};typeof e.alsoResize=="object"&&!e.alsoResize.parentNode?e.alsoResize.length?(e.alsoResize=e.alsoResize[0],f(e.alsoResize)):a.each(e.alsoResize,function(a){f(a)}):f(e.alsoResize)},resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.originalSize,g=d.originalPosition,h={height:d.size.height-f.height||0,width:d.size.width-f.width||0,top:d.position.top-g.top||0,left:d.position.left-g.left||0},i=function(b,d){a(b).each(function(){var b=a(this),e=a(this).data("resizable-alsoresize"),f={},g=d&&d.length?d:b.parents(c.originalElement[0]).length?["width","height"]:["width","height","top","left"];a.each(g,function(a,b){var c=(e[b]||0)+(h[b]||0);c&&c>=0&&(f[b]=c||null)}),b.css(f)})};typeof e.alsoResize=="object"&&!e.alsoResize.nodeType?a.each(e.alsoResize,function(a,b){i(a,b)}):i(e.alsoResize)},stop:function(b,c){a(this).removeData("resizable-alsoresize")}}),a.ui.plugin.add("resizable","animate",{stop:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d._proportionallyResizeElements,g=f.length&&/textarea/i.test(f[0].nodeName),h=g&&a.ui.hasScroll(f[0],"left")?0:d.sizeDiff.height,i=g?0:d.sizeDiff.width,j={width:d.size.width-i,height:d.size.height-h},k=parseInt(d.element.css("left"),10)+(d.position.left-d.originalPosition.left)||null,l=parseInt(d.element.css("top"),10)+(d.position.top-d.originalPosition.top)||null;d.element.animate(a.extend(j,l&&k?{top:l,left:k}:{}),{duration:e.animateDuration,easing:e.animateEasing,step:function(){var c={width:parseInt(d.element.css("width"),10),height:parseInt(d.element.css("height"),10),top:parseInt(d.element.css("top"),10),left:parseInt(d.element.css("left"),10)};f&&f.length&&a(f[0]).css({width:c.width,height:c.height}),d._updateCache(c),d._propagate("resize",b)}})}}),a.ui.plugin.add("resizable","containment",{start:function(b,d){var e=a(this).data("resizable"),f=e.options,g=e.element,h=f.containment,i=h instanceof a?h.get(0):/parent/.test(h)?g.parent().get(0):h;if(!i)return;e.containerElement=a(i);if(/document/.test(h)||h==document)e.containerOffset={left:0,top:0},e.containerPosition={left:0,top:0},e.parentData={element:a(document),left:0,top:0,width:a(document).width(),height:a(document).height()||document.body.parentNode.scrollHeight};else{var j=a(i),k=[];a(["Top","Right","Left","Bottom"]).each(function(a,b){k[a]=c(j.css("padding"+b))}),e.containerOffset=j.offset(),e.containerPosition=j.position(),e.containerSize={height:j.innerHeight()-k[3],width:j.innerWidth()-k[1]};var l=e.containerOffset,m=e.containerSize.height,n=e.containerSize.width,o=a.ui.hasScroll(i,"left")?i.scrollWidth:n,p=a.ui.hasScroll(i)?i.scrollHeight:m;e.parentData={element:i,left:l.left,top:l.top,width:o,height:p}}},resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.containerSize,g=d.containerOffset,h=d.size,i=d.position,j=d._aspectRatio||b.shiftKey,k={top:0,left:0},l=d.containerElement;l[0]!=document&&/static/.test(l.css("position"))&&(k=g),i.left<(d._helper?g.left:0)&&(d.size.width=d.size.width+(d._helper?d.position.left-g.left:d.position.left-k.left),j&&(d.size.height=d.size.width/d.aspectRatio),d.position.left=e.helper?g.left:0),i.top<(d._helper?g.top:0)&&(d.size.height=d.size.height+(d._helper?d.position.top-g.top:d.position.top),j&&(d.size.width=d.size.height*d.aspectRatio),d.position.top=d._helper?g.top:0),d.offset.left=d.parentData.left+d.position.left,d.offset.top=d.parentData.top+d.position.top;var m=Math.abs((d._helper?d.offset.left-k.left:d.offset.left-k.left)+d.sizeDiff.width),n=Math.abs((d._helper?d.offset.top-k.top:d.offset.top-g.top)+d.sizeDiff.height),o=d.containerElement.get(0)==d.element.parent().get(0),p=/relative|absolute/.test(d.containerElement.css("position"));o&&p&&(m-=d.parentData.left),m+d.size.width>=d.parentData.width&&(d.size.width=d.parentData.width-m,j&&(d.size.height=d.size.width/d.aspectRatio)),n+d.size.height>=d.parentData.height&&(d.size.height=d.parentData.height-n,j&&(d.size.width=d.size.height*d.aspectRatio))},stop:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.position,g=d.containerOffset,h=d.containerPosition,i=d.containerElement,j=a(d.helper),k=j.offset(),l=j.outerWidth()-d.sizeDiff.width,m=j.outerHeight()-d.sizeDiff.height;d._helper&&!e.animate&&/relative/.test(i.css("position"))&&a(this).css({left:k.left-h.left-g.left,width:l,height:m}),d._helper&&!e.animate&&/static/.test(i.css("position"))&&a(this).css({left:k.left-h.left-g.left,width:l,height:m})}}),a.ui.plugin.add("resizable","ghost",{start:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.size;d.ghost=d.originalElement.clone(),d.ghost.css({opacity:.25,display:"block",position:"relative",height:f.height,width:f.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof e.ghost=="string"?e.ghost:""),d.ghost.appendTo(d.helper)},resize:function(b,c){var d=a(this).data("resizable"),e=d.options;d.ghost&&d.ghost.css({position:"relative",height:d.size.height,width:d.size.width})},stop:function(b,c){var d=a(this).data("resizable"),e=d.options;d.ghost&&d.helper&&d.helper.get(0).removeChild(d.ghost.get(0))}}),a.ui.plugin.add("resizable","grid",{resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.size,g=d.originalSize,h=d.originalPosition,i=d.axis,j=e._aspectRatio||b.shiftKey;e.grid=typeof e.grid=="number"?[e.grid,e.grid]:e.grid;var k=Math.round((f.width-g.width)/(e.grid[0]||1))*(e.grid[0]||1),l=Math.round((f.height-g.height)/(e.grid[1]||1))*(e.grid[1]||1);/^(se|s|e)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l):/^(ne)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l,d.position.top=h.top-l):/^(sw)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l,d.position.left=h.left-k):(d.size.width=g.width+k,d.size.height=g.height+l,d.position.top=h.top-l,d.position.left=h.left-k)}});var c=function(a){return parseInt(a,10)||0},d=function(a){return!isNaN(parseInt(a,10))}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.selectable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.selectable",a.ui.mouse,{options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch"},_create:function(){var b=this;this.element.addClass("ui-selectable"),this.dragged=!1;var c;this.refresh=function(){c=a(b.options.filter,b.element[0]),c.addClass("ui-selectee"),c.each(function(){var b=a(this),c=b.offset();a.data(this,"selectable-item",{element:this,$element:b,left:c.left,top:c.top,right:c.left+b.outerWidth(),bottom:c.top+b.outerHeight(),startselected:!1,selected:b.hasClass("ui-selected"),selecting:b.hasClass("ui-selecting"),unselecting:b.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=c.addClass("ui-selectee"),this._mouseInit(),this.helper=a("<div class='ui-selectable-helper'></div>")},destroy:function(){return this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable"),this._mouseDestroy(),this},_mouseStart:function(b){var c=this;this.opos=[b.pageX,b.pageY];if(this.options.disabled)return;var d=this.options;this.selectees=a(d.filter,this.element[0]),this._trigger("start",b),a(d.appendTo).append(this.helper),this.helper.css({left:b.clientX,top:b.clientY,width:0,height:0}),d.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var d=a.data(this,"selectable-item");d.startselected=!0,!b.metaKey&&!b.ctrlKey&&(d.$element.removeClass("ui-selected"),d.selected=!1,d.$element.addClass("ui-unselecting"),d.unselecting=!0,c._trigger("unselecting",b,{unselecting:d.element}))}),a(b.target).parents().andSelf().each(function(){var d=a.data(this,"selectable-item");if(d){var e=!b.metaKey&&!b.ctrlKey||!d.$element.hasClass("ui-selected");return d.$element.removeClass(e?"ui-unselecting":"ui-selected").addClass(e?"ui-selecting":"ui-unselecting"),d.unselecting=!e,d.selecting=e,d.selected=e,e?c._trigger("selecting",b,{selecting:d.element}):c._trigger("unselecting",b,{unselecting:d.element}),!1}})},_mouseDrag:function(b){var c=this;this.dragged=!0;if(this.options.disabled)return;var d=this.options,e=this.opos[0],f=this.opos[1],g=b.pageX,h=b.pageY;if(e>g){var i=g;g=e,e=i}if(f>h){var i=h;h=f,f=i}return this.helper.css({left:e,top:f,width:g-e,height:h-f}),this.selectees.each(function(){var i=a.data(this,"selectable-item");if(!i||i.element==c.element[0])return;var j=!1;d.tolerance=="touch"?j=!(i.left>g||i.right<e||i.top>h||i.bottom<f):d.tolerance=="fit"&&(j=i.left>e&&i.right<g&&i.top>f&&i.bottom<h),j?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,c._trigger("selecting",b,{selecting:i.element}))):(i.selecting&&((b.metaKey||b.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),c._trigger("unselecting",b,{unselecting:i.element}))),i.selected&&!b.metaKey&&!b.ctrlKey&&!i.startselected&&(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,c._trigger("unselecting",b,{unselecting:i.element})))}),!1},_mouseStop:function(b){var c=this;this.dragged=!1;var d=this.options;return a(".ui-unselecting",this.element[0]).each(function(){var d=a.data(this,"selectable-item");d.$element.removeClass("ui-unselecting"),d.unselecting=!1,d.startselected=!1,c._trigger("unselected",b,{unselected:d.element})}),a(".ui-selecting",this.element[0]).each(function(){var d=a.data(this,"selectable-item");d.$element.removeClass("ui-selecting").addClass("ui-selected"),d.selecting=!1,d.selected=!0,d.startselected=!0,c._trigger("selected",b,{selected:d.element})}),this._trigger("stop",b),this.helper.remove(),!1}}),a.extend(a.ui.selectable,{version:"1.8.22"})})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.sortable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.sortable",a.ui.mouse,{widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3},_create:function(){var a=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?a.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},destroy:function(){a.Widget.prototype.destroy.call(this),this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var b=this.items.length-1;b>=0;b--)this.items[b].item.removeData(this.widgetName+"-item");return this},_setOption:function(b,c){b==="disabled"?(this.options[b]=c,this.widget()[c?"addClass":"removeClass"]("ui-sortable-disabled")):a.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(b,c){var d=this;if(this.reverting)return!1;if(this.options.disabled||this.options.type=="static")return!1;this._refreshItems(b);var e=null,f=this,g=a(b.target).parents().each(function(){if(a.data(this,d.widgetName+"-item")==f)return e=a(this),!1});a.data(b.target,d.widgetName+"-item")==f&&(e=a(b.target));if(!e)return!1;if(this.options.handle&&!c){var h=!1;a(this.options.handle,e).find("*").andSelf().each(function(){this==b.target&&(h=!0)});if(!h)return!1}return this.currentItem=e,this._removeCurrentsFromItems(),!0},_mouseStart:function(b,c,d){var e=this.options,f=this;this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(b),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},a.extend(this.offset,{click:{left:b.pageX-this.offset.left,top:b.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(b),this.originalPageX=b.pageX,this.originalPageY=b.pageY,e.cursorAt&&this._adjustOffsetFromHelper(e.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!=this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),e.containment&&this._setContainment(),e.cursor&&(a("body").css("cursor")&&(this._storedCursor=a("body").css("cursor")),a("body").css("cursor",e.cursor)),e.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",e.opacity)),e.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",e.zIndex)),this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",b,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions();if(!d)for(var g=this.containers.length-1;g>=0;g--)this.containers[g]._trigger("activate",b,f._uiHash(this));return a.ui.ddmanager&&(a.ui.ddmanager.current=this),a.ui.ddmanager&&!e.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(b),!0},_mouseDrag:function(b){this.position=this._generatePosition(b),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs);if(this.options.scroll){var c=this.options,d=!1;this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-b.pageY<c.scrollSensitivity?this.scrollParent[0].scrollTop=d=this.scrollParent[0].scrollTop+c.scrollSpeed:b.pageY-this.overflowOffset.top<c.scrollSensitivity&&(this.scrollParent[0].scrollTop=d=this.scrollParent[0].scrollTop-c.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-b.pageX<c.scrollSensitivity?this.scrollParent[0].scrollLeft=d=this.scrollParent[0].scrollLeft+c.scrollSpeed:b.pageX-this.overflowOffset.left<c.scrollSensitivity&&(this.scrollParent[0].scrollLeft=d=this.scrollParent[0].scrollLeft-c.scrollSpeed)):(b.pageY-a(document).scrollTop()<c.scrollSensitivity?d=a(document).scrollTop(a(document).scrollTop()-c.scrollSpeed):a(window).height()-(b.pageY-a(document).scrollTop())<c.scrollSensitivity&&(d=a(document).scrollTop(a(document).scrollTop()+c.scrollSpeed)),b.pageX-a(document).scrollLeft()<c.scrollSensitivity?d=a(document).scrollLeft(a(document).scrollLeft()-c.scrollSpeed):a(window).width()-(b.pageX-a(document).scrollLeft())<c.scrollSensitivity&&(d=a(document).scrollLeft(a(document).scrollLeft()+c.scrollSpeed))),d!==!1&&a.ui.ddmanager&&!c.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(var e=this.items.length-1;e>=0;e--){var f=this.items[e],g=f.item[0],h=this._intersectsWithPointer(f);if(!h)continue;if(g!=this.currentItem[0]&&this.placeholder[h==1?"next":"prev"]()[0]!=g&&!a.ui.contains(this.placeholder[0],g)&&(this.options.type=="semi-dynamic"?!a.ui.contains(this.element[0],g):!0)){this.direction=h==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(f))this._rearrange(b,f);else break;this._trigger("change",b,this._uiHash());break}}return this._contactContainers(b),a.ui.ddmanager&&a.ui.ddmanager.drag(this,b),this._trigger("sort",b,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(b,c){if(!b)return;a.ui.ddmanager&&!this.options.dropBehaviour&&a.ui.ddmanager.drop(this,b);if(this.options.revert){var d=this,e=d.placeholder.offset();d.reverting=!0,a(this.helper).animate({left:e.left-this.offset.parent.left-d.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:e.top-this.offset.parent.top-d.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){d._clear(b)})}else this._clear(b,c);return!1},cancel:function(){var b=this;if(this.dragging){this._mouseUp({target:null}),this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("deactivate",null,b._uiHash(this)),this.containers[c].containerCache.over&&(this.containers[c]._trigger("out",null,b._uiHash(this)),this.containers[c].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),a.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?a(this.domPosition.prev).after(this.currentItem):a(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(b){var c=this._getItemsAsjQuery(b&&b.connected),d=[];return b=b||{},a(c).each(function(){var c=(a(b.item||this).attr(b.attribute||"id")||"").match(b.expression||/(.+)[-=_](.+)/);c&&d.push((b.key||c[1]+"[]")+"="+(b.key&&b.expression?c[1]:c[2]))}),!d.length&&b.key&&d.push(b.key+"="),d.join("&")},toArray:function(b){var c=this._getItemsAsjQuery(b&&b.connected),d=[];return b=b||{},c.each(function(){d.push(a(b.item||this).attr(b.attribute||"id")||"")}),d},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,d=this.positionAbs.top,e=d+this.helperProportions.height,f=a.left,g=f+a.width,h=a.top,i=h+a.height,j=this.offset.click.top,k=this.offset.click.left,l=d+j>h&&d+j<i&&b+k>f&&b+k<g;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>a[this.floating?"width":"height"]?l:f<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<g&&h<d+this.helperProportions.height/2&&e-this.helperProportions.height/2<i},_intersectsWithPointer:function(b){var c=this.options.axis==="x"||a.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,b.top,b.height),d=this.options.axis==="y"||a.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,b.left,b.width),e=c&&d,f=this._getDragVerticalDirection(),g=this._getDragHorizontalDirection();return e?this.floating?g&&g=="right"||f=="down"?2:1:f&&(f=="down"?2:1):!1},_intersectsWithSides:function(b){var c=a.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,b.top+b.height/2,b.height),d=a.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,b.left+b.width/2,b.width),e=this._getDragVerticalDirection(),f=this._getDragHorizontalDirection();return this.floating&&f?f=="right"&&d||f=="left"&&!d:e&&(e=="down"&&c||e=="up"&&!c)},_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){return this._refreshItems(a),this.refreshPositions(),this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(b){var c=this,d=[],e=[],f=this._connectWith();if(f&&b)for(var g=f.length-1;g>=0;g--){var h=a(f[g]);for(var i=h.length-1;i>=0;i--){var j=a.data(h[i],this.widgetName);j&&j!=this&&!j.options.disabled&&e.push([a.isFunction(j.options.items)?j.options.items.call(j.element):a(j.options.items,j.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),j])}}e.push([a.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):a(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]);for(var g=e.length-1;g>=0;g--)e[g][0].each(function(){d.push(this)});return a(d)},_removeCurrentsFromItems:function(){var a=this.currentItem.find(":data("+this.widgetName+"-item)");for(var b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(b){this.items=[],this.containers=[this];var c=this.items,d=this,e=[[a.isFunction(this.options.items)?this.options.items.call(this.element[0],b,{item:this.currentItem}):a(this.options.items,this.element),this]],f=this._connectWith();if(f&&this.ready)for(var g=f.length-1;g>=0;g--){var h=a(f[g]);for(var i=h.length-1;i>=0;i--){var j=a.data(h[i],this.widgetName);j&&j!=this&&!j.options.disabled&&(e.push([a.isFunction(j.options.items)?j.options.items.call(j.element[0],b,{item:this.currentItem}):a(j.options.items,j.element),j]),this.containers.push(j))}}for(var g=e.length-1;g>=0;g--){var k=e[g][1],l=e[g][0];for(var i=0,m=l.length;i<m;i++){var n=a(l[i]);n.data(this.widgetName+"-item",k),c.push({item:n,instance:k,width:0,height:0,left:0,top:0})}}},refreshPositions:function(b){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());for(var c=this.items.length-1;c>=0;c--){var d=this.items[c];if(d.instance!=this.currentContainer&&this.currentContainer&&d.item[0]!=this.currentItem[0])continue;var e=this.options.toleranceElement?a(this.options.toleranceElement,d.item):d.item;b||(d.width=e.outerWidth(),d.height=e.outerHeight());var f=e.offset();d.left=f.left,d.top=f.top}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(var c=this.containers.length-1;c>=0;c--){var f=this.containers[c].element.offset();this.containers[c].containerCache.left=f.left,this.containers[c].containerCache.top=f.top,this.containers[c].containerCache.width=this.containers[c].element.outerWidth(),this.containers[c].containerCache.height=this.containers[c].element.outerHeight()}return this},_createPlaceholder:function(b){var c=b||this,d=c.options;if(!d.placeholder||d.placeholder.constructor==String){var e=d.placeholder;d.placeholder={element:function(){var b=a(document.createElement(c.currentItem[0].nodeName)).addClass(e||c.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];return e||(b.style.visibility="hidden"),b},update:function(a,b){if(e&&!d.forcePlaceholderSize)return;b.height()||b.height(c.currentItem.innerHeight()-parseInt(c.currentItem.css("paddingTop")||0,10)-parseInt(c.currentItem.css("paddingBottom")||0,10)),b.width()||b.width(c.currentItem.innerWidth()-parseInt(c.currentItem.css("paddingLeft")||0,10)-parseInt(c.currentItem.css("paddingRight")||0,10))}}}c.placeholder=a(d.placeholder.element.call(c.element,c.currentItem)),c.currentItem.after(c.placeholder),d.placeholder.update(c,c.placeholder)},_contactContainers:function(b){var c=null,d=null;for(var e=this.containers.length-1;e>=0;e--){if(a.ui.contains(this.currentItem[0],this.containers[e].element[0]))continue;if(this._intersectsWith(this.containers[e].containerCache)){if(c&&a.ui.contains(this.containers[e].element[0],c.element[0]))continue;c=this.containers[e],d=e}else this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",b,this._uiHash(this)),this.containers[e].containerCache.over=0)}if(!c)return;if(this.containers.length===1)this.containers[d]._trigger("over",b,this._uiHash(this)),this.containers[d].containerCache.over=1;else if(this.currentContainer!=this.containers[d]){var f=1e4,g=null,h=this.positionAbs[this.containers[d].floating?"left":"top"];for(var i=this.items.length-1;i>=0;i--){if(!a.ui.contains(this.containers[d].element[0],this.items[i].item[0]))continue;var j=this.containers[d].floating?this.items[i].item.offset().left:this.items[i].item.offset().top;Math.abs(j-h)<f&&(f=Math.abs(j-h),g=this.items[i],this.direction=j-h>0?"down":"up")}if(!g&&!this.options.dropOnEmpty)return;this.currentContainer=this.containers[d],g?this._rearrange(b,g,null,!0):this._rearrange(b,null,this.containers[d].element,!0),this._trigger("change",b,this._uiHash()),this.containers[d]._trigger("change",b,this._uiHash(this)),this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[d]._trigger("over",b,this._uiHash(this)),this.containers[d].containerCache.over=1}},_createHelper:function(b){var c=this.options,d=a.isFunction(c.helper)?a(c.helper.apply(this.element[0],[b,this.currentItem])):c.helper=="clone"?this.currentItem.clone():this.currentItem;return d.parents("body").length||a(c.appendTo!="parent"?c.appendTo:this.currentItem[0].parentNode)[0].appendChild(d[0]),d[0]==this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(d[0].style.width==""||c.forceHelperSize)&&d.width(this.currentItem.width()),(d[0].style.height==""||c.forceHelperSize)&&d.height(this.currentItem.height()),d},_adjustOffsetFromHelper:function(b){typeof b=="string"&&(b=b.split(" ")),a.isArray(b)&&(b={left:+b[0],top:+b[1]||0}),"left"in b&&(this.offset.click.left=b.left+this.margins.left),"right"in b&&(this.offset.click.left=this.helperProportions.width-b.right+this.margins.left),"top"in b&&(this.offset.click.top=b.top+this.margins.top),"bottom"in b&&(this.offset.click.top=this.helperProportions.height-b.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var b=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&a.ui.contains(this.scrollParent[0],this.offsetParent[0])&&(b.left+=this.scrollParent.scrollLeft(),b.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&a.browser.msie)b={top:0,left:0};return{top:b.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:b.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var b=this.options;b.containment=="parent"&&(b.containment=this.helper[0].parentNode);if(b.containment=="document"||b.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,a(b.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a(b.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(b.containment)){var c=a(b.containment)[0],d=a(b.containment).offset(),e=a(c).css("overflow")!="hidden";this.containment=[d.left+(parseInt(a(c).css("borderLeftWidth"),10)||0)+(parseInt(a(c).css("paddingLeft"),10)||0)-this.margins.left,d.top+(parseInt(a(c).css("borderTopWidth"),10)||0)+(parseInt(a(c).css("paddingTop"),10)||0)-this.margins.top,d.left+(e?Math.max(c.scrollWidth,c.offsetWidth):c.offsetWidth)-(parseInt(a(c).css("borderLeftWidth"),10)||0)-(parseInt(a(c).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,d.top+(e?Math.max(c.scrollHeight,c.offsetHeight):c.offsetHeight)-(parseInt(a(c).css("borderTopWidth"),10)||0)-(parseInt(a(c).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(b,c){c||(c=this.position);var d=b=="absolute"?1:-1,e=this.options,f=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,g=/(html|body)/i.test(f[0].tagName);return{top:c.top+this.offset.relative.top*d+this.offset.parent.top*d-(a.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():g?0:f.scrollTop())*d),left:c.left+this.offset.relative.left*d+this.offset.parent.left*d-(a.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():g?0:f.scrollLeft())*d)}},_generatePosition:function(b){var c=this.options,d=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(d[0].tagName);this.cssPosition=="relative"&&(this.scrollParent[0]==document||this.scrollParent[0]==this.offsetParent[0])&&(this.offset.relative=this._getRelativeOffset());var f=b.pageX,g=b.pageY;if(this.originalPosition){this.containment&&(b.pageX-this.offset.click.left<this.containment[0]&&(f=this.containment[0]+this.offset.click.left),b.pageY-this.offset.click.top<this.containment[1]&&(g=this.containment[1]+this.offset.click.top),b.pageX-this.offset.click.left>this.containment[2]&&(f=this.containment[2]+this.offset.click.left),b.pageY-this.offset.click.top>this.containment[3]&&(g=this.containment[3]+this.offset.click.top));if(c.grid){var h=this.originalPageY+Math.round((g-this.originalPageY)/c.grid[1])*c.grid[1];g=this.containment?h-this.offset.click.top<this.containment[1]||h-this.offset.click.top>this.containment[3]?h-this.offset.click.top<this.containment[1]?h+c.grid[1]:h-c.grid[1]:h:h;var i=this.originalPageX+Math.round((f-this.originalPageX)/c.grid[0])*c.grid[0];f=this.containment?i-this.offset.click.left<this.containment[0]||i-this.offset.click.left>this.containment[2]?i-this.offset.click.left<this.containment[0]?i+c.grid[0]:i-c.grid[0]:i:i}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(a.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:d.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(a.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:d.scrollLeft())}},_rearrange:function(a,b,c,d){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],this.direction=="down"?b.item[0]:b.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var e=this,f=this.counter;window.setTimeout(function(){f==e.counter&&e.refreshPositions(!d)},0)},_clear:function(b,c){this.reverting=!1;var d=[],e=this;!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var f in this._storedCSS)if(this._storedCSS[f]=="auto"||this._storedCSS[f]=="static")this._storedCSS[f]="";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!c&&d.push(function(a){this._trigger("receive",a,this._uiHash(this.fromOutside))}),(this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!c&&d.push(function(a){this._trigger("update",a,this._uiHash())});if(!a.ui.contains(this.element[0],this.currentItem[0])){c||d.push(function(a){this._trigger("remove",a,this._uiHash())});for(var f=this.containers.length-1;f>=0;f--)a.ui.contains(this.containers[f].element[0],this.currentItem[0])&&!c&&(d.push(function(a){return function(b){a._trigger("receive",b,this._uiHash(this))}}.call(this,this.containers[f])),d.push(function(a){return function(b){a._trigger("update",b,this._uiHash(this))}}.call(this,this.containers[f])))}for(var f=this.containers.length-1;f>=0;f--)c||d.push(function(a){return function(b){a._trigger("deactivate",b,this._uiHash(this))}}.call(this,this.containers[f])),this.containers[f].containerCache.over&&(d.push(function(a){return function(b){a._trigger("out",b,this._uiHash(this))}}.call(this,this.containers[f])),this.containers[f].containerCache.over=0);this._storedCursor&&a("body").css("cursor",this._storedCursor),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex),this.dragging=!1;if(this.cancelHelperRemoval){if(!c){this._trigger("beforeStop",b,this._uiHash());for(var f=0;f<d.length;f++)d[f].call(this,b);this._trigger("stop",b,this._uiHash())}return this.fromOutside=!1,!1}c||this._trigger("beforeStop",b,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!=this.currentItem[0]&&this.helper.remove(),this.helper=null;if(!c){for(var f=0;f<d.length;f++)d[f].call(this,b);this._trigger("stop",b,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){a.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(b){var c=b||this;return{helper:c.helper,placeholder:c.placeholder||a([]),position:c.position,originalPosition:c.originalPosition,offset:c.positionAbs,item:c.currentItem,sender:b?b.element:null}}}),a.extend(a.ui.sortable,{version:"1.8.22"})})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.slider.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){var c=5;a.widget("ui.slider",a.ui.mouse,{widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null},_create:function(){var b=this,d=this.options,e=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f="<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",g=d.values&&d.values.length||1,h=[];this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"+(d.disabled?" ui-slider-disabled ui-disabled":"")),this.range=a([]),d.range&&(d.range===!0&&(d.values||(d.values=[this._valueMin(),this._valueMin()]),d.values.length&&d.values.length!==2&&(d.values=[d.values[0],d.values[0]])),this.range=a("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(d.range==="min"||d.range==="max"?" ui-slider-range-"+d.range:"")));for(var i=e.length;i<g;i+=1)h.push(f);this.handles=e.add(a(h.join("")).appendTo(b.element)),this.handle=this.handles.eq(0),this.handles.add(this.range).filter("a").click(function(a){a.preventDefault()}).hover(function(){d.disabled||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}).focus(function(){d.disabled?a(this).blur():(a(".ui-slider .ui-state-focus").removeClass("ui-state-focus"),a(this).addClass("ui-state-focus"))}).blur(function(){a(this).removeClass("ui-state-focus")}),this.handles.each(function(b){a(this).data("index.ui-slider-handle",b)}),this.handles.keydown(function(d){var e=a(this).data("index.ui-slider-handle"),f,g,h,i;if(b.options.disabled)return;switch(d.keyCode){case a.ui.keyCode.HOME:case a.ui.keyCode.END:case a.ui.keyCode.PAGE_UP:case a.ui.keyCode.PAGE_DOWN:case a.ui.keyCode.UP:case a.ui.keyCode.RIGHT:case a.ui.keyCode.DOWN:case a.ui.keyCode.LEFT:d.preventDefault();if(!b._keySliding){b._keySliding=!0,a(this).addClass("ui-state-active"),f=b._start(d,e);if(f===!1)return}}i=b.options.step,b.options.values&&b.options.values.length?g=h=b.values(e):g=h=b.value();switch(d.keyCode){case a.ui.keyCode.HOME:h=b._valueMin();break;case a.ui.keyCode.END:h=b._valueMax();break;case a.ui.keyCode.PAGE_UP:h=b._trimAlignValue(g+(b._valueMax()-b._valueMin())/c);break;case a.ui.keyCode.PAGE_DOWN:h=b._trimAlignValue(g-(b._valueMax()-b._valueMin())/c);break;case a.ui.keyCode.UP:case a.ui.keyCode.RIGHT:if(g===b._valueMax())return;h=b._trimAlignValue(g+i);break;case a.ui.keyCode.DOWN:case a.ui.keyCode.LEFT:if(g===b._valueMin())return;h=b._trimAlignValue(g-i)}b._slide(d,e,h)}).keyup(function(c){var d=a(this).data("index.ui-slider-handle");b._keySliding&&(b._keySliding=!1,b._stop(c,d),b._change(c,d),a(this).removeClass("ui-state-active"))}),this._refreshValue(),this._animateOff=!1},destroy:function(){return this.handles.remove(),this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider"),this._mouseDestroy(),this},_mouseCapture:function(b){var c=this.options,d,e,f,g,h,i,j,k,l;return c.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),d={x:b.pageX,y:b.pageY},e=this._normValueFromMouse(d),f=this._valueMax()-this._valueMin()+1,h=this,this.handles.each(function(b){var c=Math.abs(e-h.values(b));f>c&&(f=c,g=a(this),i=b)}),c.range===!0&&this.values(1)===c.min&&(i+=1,g=a(this.handles[i])),j=this._start(b,i),j===!1?!1:(this._mouseSliding=!0,h._handleIndex=i,g.addClass("ui-state-active").focus(),k=g.offset(),l=!a(b.target).parents().andSelf().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:b.pageX-k.left-g.width()/2,top:b.pageY-k.top-g.height()/2-(parseInt(g.css("borderTopWidth"),10)||0)-(parseInt(g.css("borderBottomWidth"),10)||0)+(parseInt(g.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(b,i,e),this._animateOff=!0,!0))},_mouseStart:function(a){return!0},_mouseDrag:function(a){var b={x:a.pageX,y:a.pageY},c=this._normValueFromMouse(b);return this._slide(a,this._handleIndex,c),!1},_mouseStop:function(a){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(a,this._handleIndex),this._change(a,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b,c,d,e,f;return this.orientation==="horizontal"?(b=this.elementSize.width,c=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(b=this.elementSize.height,c=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),d=c/b,d>1&&(d=1),d<0&&(d=0),this.orientation==="vertical"&&(d=1-d),e=this._valueMax()-this._valueMin(),f=this._valueMin()+d*e,this._trimAlignValue(f)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};return this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("start",a,c)},_slide:function(a,b,c){var d,e,f;this.options.values&&this.options.values.length?(d=this.values(b?0:1),this.options.values.length===2&&this.options.range===!0&&(b===0&&c>d||b===1&&c<d)&&(c=d),c!==this.values(b)&&(e=this.values(),e[b]=c,f=this._trigger("slide",a,{handle:this.handles[b],value:c,values:e}),d=this.values(b?0:1),f!==!1&&this.values(b,c,!0))):c!==this.value()&&(f=this._trigger("slide",a,{handle:this.handles[b],value:c}),f!==!1&&this.value(c))},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=this._trimAlignValue(a),this._refreshValue(),this._change(null,0);return}return this._value()},values:function(b,c){var d,e,f;if(arguments.length>1){this.options.values[b]=this._trimAlignValue(c),this._refreshValue(),this._change(null,b);return}if(!arguments.length)return this._values();if(!a.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(b):this.value();d=this.options.values,e=arguments[0];for(f=0;f<d.length;f+=1)d[f]=this._trimAlignValue(e[f]),this._change(null,f);this._refreshValue()},_setOption:function(b,c){var d,e=0;a.isArray(this.options.values)&&(e=this.options.values.length),a.Widget.prototype._setOption.apply(this,arguments);switch(b){case"disabled":c?(this.handles.filter(".ui-state-focus").blur(),this.handles.removeClass("ui-state-hover"),this.handles.propAttr("disabled",!0),this.element.addClass("ui-disabled")):(this.handles.propAttr("disabled",!1),this.element.removeClass("ui-disabled"));break;case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue();break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":this._animateOff=!0,this._refreshValue();for(d=0;d<e;d+=1)this._change(null,d);this._animateOff=!1}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a),a},_values:function(a){var b,c,d;if(arguments.length)return b=this.options.values[a],b=this._trimAlignValue(b),b;c=this.options.values.slice();for(d=0;d<c.length;d+=1)c[d]=this._trimAlignValue(c[d]);return c},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b,d=a-c;return Math.abs(c)*2>=b&&(d+=c>0?b:-b),parseFloat(d.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var b=this.options.range,c=this.options,d=this,e=this._animateOff?!1:c.animate,f,g={},h,i,j,k;this.options.values&&this.options.values.length?this.handles.each(function(b,i){f=(d.values(b)-d._valueMin())/(d._valueMax()-d._valueMin())*100,g[d.orientation==="horizontal"?"left":"bottom"]=f+"%",a(this).stop(1,1)[e?"animate":"css"](g,c.animate),d.options.range===!0&&(d.orientation==="horizontal"?(b===0&&d.range.stop(1,1)[e?"animate":"css"]({left:f+"%"},c.animate),b===1&&d.range[e?"animate":"css"]({width:f-h+"%"},{queue:!1,duration:c.animate})):(b===0&&d.range.stop(1,1)[e?"animate":"css"]({bottom:f+"%"},c.animate),b===1&&d.range[e?"animate":"css"]({height:f-h+"%"},{queue:!1,duration:c.animate}))),h=f}):(i=this.value(),j=this._valueMin(),k=this._valueMax(),f=k!==j?(i-j)/(k-j)*100:0,g[d.orientation==="horizontal"?"left":"bottom"]=f+"%",this.handle.stop(1,1)[e?"animate":"css"](g,c.animate),b==="min"&&this.orientation==="horizontal"&&this.range.stop(1,1)[e?"animate":"css"]({width:f+"%"},c.animate),b==="max"&&this.orientation==="horizontal"&&this.range[e?"animate":"css"]({width:100-f+"%"},{queue:!1,duration:c.animate}),b==="min"&&this.orientation==="vertical"&&this.range.stop(1,1)[e?"animate":"css"]({height:f+"%"},c.animate),b==="max"&&this.orientation==="vertical"&&this.range[e?"animate":"css"]({height:100-f+"%"},{queue:!1,duration:c.animate}))}}),a.extend(a.ui.slider,{version:"1.8.22"})})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.core.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
jQuery.effects||function(a,b){function c(b){var c;return b&&b.constructor==Array&&b.length==3?b:(c=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(b))?[parseInt(c[1],10),parseInt(c[2],10),parseInt(c[3],10)]:(c=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(b))?[parseFloat(c[1])*2.55,parseFloat(c[2])*2.55,parseFloat(c[3])*2.55]:(c=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(b))?[parseInt(c[1],16),parseInt(c[2],16),parseInt(c[3],16)]:(c=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(b))?[parseInt(c[1]+c[1],16),parseInt(c[2]+c[2],16),parseInt(c[3]+c[3],16)]:(c=/rgba\(0, 0, 0, 0\)/.exec(b))?e.transparent:e[a.trim(b).toLowerCase()]}function d(b,d){var e;do{e=(a.curCSS||a.css)(b,d);if(e!=""&&e!="transparent"||a.nodeName(b,"body"))break;d="backgroundColor"}while(b=b.parentNode);return c(e)}function h(){var a=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,b={},c,d;if(a&&a.length&&a[0]&&a[a[0]]){var e=a.length;while(e--)c=a[e],typeof a[c]=="string"&&(d=c.replace(/\-(\w)/g,function(a,b){return b.toUpperCase()}),b[d]=a[c])}else for(c in a)typeof a[c]=="string"&&(b[c]=a[c]);return b}function i(b){var c,d;for(c in b)d=b[c],(d==null||a.isFunction(d)||c in g||/scrollbar/.test(c)||!/color/i.test(c)&&isNaN(parseFloat(d)))&&delete b[c];return b}function j(a,b){var c={_:0},d;for(d in b)a[d]!=b[d]&&(c[d]=b[d]);return c}function k(b,c,d,e){typeof b=="object"&&(e=c,d=null,c=b,b=c.effect),a.isFunction(c)&&(e=c,d=null,c={});if(typeof c=="number"||a.fx.speeds[c])e=d,d=c,c={};return a.isFunction(d)&&(e=d,d=null),c=c||{},d=d||c.duration,d=a.fx.off?0:typeof d=="number"?d:d in a.fx.speeds?a.fx.speeds[d]:a.fx.speeds._default,e=e||c.complete,[b,c,d,e]}function l(b){return!b||typeof b=="number"||a.fx.speeds[b]?!0:typeof b=="string"&&!a.effects[b]?!0:!1}a.effects={},a.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor","borderTopColor","borderColor","color","outlineColor"],function(b,e){a.fx.step[e]=function(a){a.colorInit||(a.start=d(a.elem,e),a.end=c(a.end),a.colorInit=!0),a.elem.style[e]="rgb("+Math.max(Math.min(parseInt(a.pos*(a.end[0]-a.start[0])+a.start[0],10),255),0)+","+Math.max(Math.min(parseInt(a.pos*(a.end[1]-a.start[1])+a.start[1],10),255),0)+","+Math.max(Math.min(parseInt(a.pos*(a.end[2]-a.start[2])+a.start[2],10),255),0)+")"}});var e={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},f=["add","remove","toggle"],g={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};a.effects.animateClass=function(b,c,d,e){return a.isFunction(d)&&(e=d,d=null),this.queue(function(){var g=a(this),k=g.attr("style")||" ",l=i(h.call(this)),m,n=g.attr("class")||"";a.each(f,function(a,c){b[c]&&g[c+"Class"](b[c])}),m=i(h.call(this)),g.attr("class",n),g.animate(j(l,m),{queue:!1,duration:c,easing:d,complete:function(){a.each(f,function(a,c){b[c]&&g[c+"Class"](b[c])}),typeof g.attr("style")=="object"?(g.attr("style").cssText="",g.attr("style").cssText=k):g.attr("style",k),e&&e.apply(this,arguments),a.dequeue(this)}})})},a.fn.extend({_addClass:a.fn.addClass,addClass:function(b,c,d,e){return c?a.effects.animateClass.apply(this,[{add:b},c,d,e]):this._addClass(b)},_removeClass:a.fn.removeClass,removeClass:function(b,c,d,e){return c?a.effects.animateClass.apply(this,[{remove:b},c,d,e]):this._removeClass(b)},_toggleClass:a.fn.toggleClass,toggleClass:function(c,d,e,f,g){return typeof d=="boolean"||d===b?e?a.effects.animateClass.apply(this,[d?{add:c}:{remove:c},e,f,g]):this._toggleClass(c,d):a.effects.animateClass.apply(this,[{toggle:c},d,e,f])},switchClass:function(b,c,d,e,f){return a.effects.animateClass.apply(this,[{add:c,remove:b},d,e,f])}}),a.extend(a.effects,{version:"1.8.22",save:function(a,b){for(var c=0;c<b.length;c++)b[c]!==null&&a.data("ec.storage."+b[c],a[0].style[b[c]])},restore:function(a,b){for(var c=0;c<b.length;c++)b[c]!==null&&a.css(b[c],a.data("ec.storage."+b[c]))},setMode:function(a,b){return b=="toggle"&&(b=a.is(":hidden")?"show":"hide"),b},getBaseline:function(a,b){var c,d;switch(a[0]){case"top":c=0;break;case"middle":c=.5;break;case"bottom":c=1;break;default:c=a[0]/b.height}switch(a[1]){case"left":d=0;break;case"center":d=.5;break;case"right":d=1;break;default:d=a[1]/b.width}return{x:d,y:c}},createWrapper:function(b){if(b.parent().is(".ui-effects-wrapper"))return b.parent();var c={width:b.outerWidth(!0),height:b.outerHeight(!0),"float":b.css("float")},d=a("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),e=document.activeElement;try{e.id}catch(f){e=document.body}return b.wrap(d),(b[0]===e||a.contains(b[0],e))&&a(e).focus(),d=b.parent(),b.css("position")=="static"?(d.css({position:"relative"}),b.css({position:"relative"})):(a.extend(c,{position:b.css("position"),zIndex:b.css("z-index")}),a.each(["top","left","bottom","right"],function(a,d){c[d]=b.css(d),isNaN(parseInt(c[d],10))&&(c[d]="auto")}),b.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),d.css(c).show()},removeWrapper:function(b){var c,d=document.activeElement;return b.parent().is(".ui-effects-wrapper")?(c=b.parent().replaceWith(b),(b[0]===d||a.contains(b[0],d))&&a(d).focus(),c):b},setTransition:function(b,c,d,e){return e=e||{},a.each(c,function(a,c){var f=b.cssUnit(c);f[0]>0&&(e[c]=f[0]*d+f[1])}),e}}),a.fn.extend({effect:function(b,c,d,e){var f=k.apply(this,arguments),g={options:f[1],duration:f[2],callback:f[3]},h=g.options.mode,i=a.effects[b];return a.fx.off||!i?h?this[h](g.duration,g.callback):this.each(function(){g.callback&&g.callback.call(this)}):i.call(this,g)},_show:a.fn.show,show:function(a){if(l(a))return this._show.apply(this,arguments);var b=k.apply(this,arguments);return b[1].mode="show",this.effect.apply(this,b)},_hide:a.fn.hide,hide:function(a){if(l(a))return this._hide.apply(this,arguments);var b=k.apply(this,arguments);return b[1].mode="hide",this.effect.apply(this,b)},__toggle:a.fn.toggle,toggle:function(b){if(l(b)||typeof b=="boolean"||a.isFunction(b))return this.__toggle.apply(this,arguments);var c=k.apply(this,arguments);return c[1].mode="toggle",this.effect.apply(this,c)},cssUnit:function(b){var c=this.css(b),d=[];return a.each(["em","px","%","pt"],function(a,b){c.indexOf(b)>0&&(d=[parseFloat(c),b])}),d}}),a.easing.jswing=a.easing.swing,a.extend(a.easing,{def:"easeOutQuad",swing:function(b,c,d,e,f){return a.easing[a.easing.def](b,c,d,e,f)},easeInQuad:function(a,b,c,d,e){return d*(b/=e)*b+c},easeOutQuad:function(a,b,c,d,e){return-d*(b/=e)*(b-2)+c},easeInOutQuad:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b+c:-d/2*(--b*(b-2)-1)+c},easeInCubic:function(a,b,c,d,e){return d*(b/=e)*b*b+c},easeOutCubic:function(a,b,c,d,e){return d*((b=b/e-1)*b*b+1)+c},easeInOutCubic:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b+c:d/2*((b-=2)*b*b+2)+c},easeInQuart:function(a,b,c,d,e){return d*(b/=e)*b*b*b+c},easeOutQuart:function(a,b,c,d,e){return-d*((b=b/e-1)*b*b*b-1)+c},easeInOutQuart:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b*b+c:-d/2*((b-=2)*b*b*b-2)+c},easeInQuint:function(a,b,c,d,e){return d*(b/=e)*b*b*b*b+c},easeOutQuint:function(a,b,c,d,e){return d*((b=b/e-1)*b*b*b*b+1)+c},easeInOutQuint:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b*b*b+c:d/2*((b-=2)*b*b*b*b+2)+c},easeInSine:function(a,b,c,d,e){return-d*Math.cos(b/e*(Math.PI/2))+d+c},easeOutSine:function(a,b,c,d,e){return d*Math.sin(b/e*(Math.PI/2))+c},easeInOutSine:function(a,b,c,d,e){return-d/2*(Math.cos(Math.PI*b/e)-1)+c},easeInExpo:function(a,b,c,d,e){return b==0?c:d*Math.pow(2,10*(b/e-1))+c},easeOutExpo:function(a,b,c,d,e){return b==e?c+d:d*(-Math.pow(2,-10*b/e)+1)+c},easeInOutExpo:function(a,b,c,d,e){return b==0?c:b==e?c+d:(b/=e/2)<1?d/2*Math.pow(2,10*(b-1))+c:d/2*(-Math.pow(2,-10*--b)+2)+c},easeInCirc:function(a,b,c,d,e){return-d*(Math.sqrt(1-(b/=e)*b)-1)+c},easeOutCirc:function(a,b,c,d,e){return d*Math.sqrt(1-(b=b/e-1)*b)+c},easeInOutCirc:function(a,b,c,d,e){return(b/=e/2)<1?-d/2*(Math.sqrt(1-b*b)-1)+c:d/2*(Math.sqrt(1-(b-=2)*b)+1)+c},easeInElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e)==1)return c+d;g||(g=e*.3);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return-(h*Math.pow(2,10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g))+c},easeOutElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e)==1)return c+d;g||(g=e*.3);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*b)*Math.sin((b*e-f)*2*Math.PI/g)+d+c},easeInOutElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e/2)==2)return c+d;g||(g=e*.3*1.5);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return b<1?-0.5*h*Math.pow(2,10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g)+c:h*Math.pow(2,-10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g)*.5+d+c},easeInBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),e*(c/=f)*c*((g+1)*c-g)+d},easeOutBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),e*((c=c/f-1)*c*((g+1)*c+g)+1)+d},easeInOutBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),(c/=f/2)<1?e/2*c*c*(((g*=1.525)+1)*c-g)+d:e/2*((c-=2)*c*(((g*=1.525)+1)*c+g)+2)+d},easeInBounce:function(b,c,d,e,f){return e-a.easing.easeOutBounce(b,f-c,0,e,f)+d},easeOutBounce:function(a,b,c,d,e){return(b/=e)<1/2.75?d*7.5625*b*b+c:b<2/2.75?d*(7.5625*(b-=1.5/2.75)*b+.75)+c:b<2.5/2.75?d*(7.5625*(b-=2.25/2.75)*b+.9375)+c:d*(7.5625*(b-=2.625/2.75)*b+.984375)+c},easeInOutBounce:function(b,c,d,e,f){return c<f/2?a.easing.easeInBounce(b,c*2,0,e,f)*.5+d:a.easing.easeOutBounce(b,c*2-f,0,e,f)*.5+e*.5+d}})}(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.blind.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.blind=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.direction||"vertical";a.effects.save(c,d),c.show();var g=a.effects.createWrapper(c).css({overflow:"hidden"}),h=f=="vertical"?"height":"width",i=f=="vertical"?g.height():g.width();e=="show"&&g.css(h,0);var j={};j[h]=e=="show"?i:0,g.animate(j,b.duration,b.options.easing,function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.bounce.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.bounce=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"effect"),f=b.options.direction||"up",g=b.options.distance||20,h=b.options.times||5,i=b.duration||250;/show|hide/.test(e)&&d.push("opacity"),a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var j=f=="up"||f=="down"?"top":"left",k=f=="up"||f=="left"?"pos":"neg",g=b.options.distance||(j=="top"?c.outerHeight(!0)/3:c.outerWidth(!0)/3);e=="show"&&c.css("opacity",0).css(j,k=="pos"?-g:g),e=="hide"&&(g=g/(h*2)),e!="hide"&&h--;if(e=="show"){var l={opacity:1};l[j]=(k=="pos"?"+=":"-=")+g,c.animate(l,i/2,b.options.easing),g=g/2,h--}for(var m=0;m<h;m++){var n={},p={};n[j]=(k=="pos"?"-=":"+=")+g,p[j]=(k=="pos"?"+=":"-=")+g,c.animate(n,i/2,b.options.easing).animate(p,i/2,b.options.easing),g=e=="hide"?g*2:g/2}if(e=="hide"){var l={opacity:0};l[j]=(k=="pos"?"-=":"+=")+g,c.animate(l,i/2,b.options.easing,function(){c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)})}else{var n={},p={};n[j]=(k=="pos"?"-=":"+=")+g,p[j]=(k=="pos"?"+=":"-=")+g,c.animate(n,i/2,b.options.easing).animate(p,i/2,b.options.easing,function(){a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)})}c.queue("fx",function(){c.dequeue()}),c.dequeue()})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.clip.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.clip=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right","height","width"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.direction||"vertical";a.effects.save(c,d),c.show();var g=a.effects.createWrapper(c).css({overflow:"hidden"}),h=c[0].tagName=="IMG"?g:c,i={size:f=="vertical"?"height":"width",position:f=="vertical"?"top":"left"},j=f=="vertical"?h.height():h.width();e=="show"&&(h.css(i.size,0),h.css(i.position,j/2));var k={};k[i.size]=e=="show"?j:0,k[i.position]=e=="show"?0:j/2,h.animate(k,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()}})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.drop.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.drop=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right","opacity"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.direction||"left";a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var g=f=="up"||f=="down"?"top":"left",h=f=="up"||f=="left"?"pos":"neg",i=b.options.distance||(g=="top"?c.outerHeight(!0)/2:c.outerWidth(!0)/2);e=="show"&&c.css("opacity",0).css(g,h=="pos"?-i:i);var j={opacity:e=="show"?1:0};j[g]=(e=="show"?h=="pos"?"+=":"-=":h=="pos"?"-=":"+=")+i,c.animate(j,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.explode.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.explode=function(b){return this.queue(function(){var c=b.options.pieces?Math.round(Math.sqrt(b.options.pieces)):3,d=b.options.pieces?Math.round(Math.sqrt(b.options.pieces)):3;b.options.mode=b.options.mode=="toggle"?a(this).is(":visible")?"hide":"show":b.options.mode;var e=a(this).show().css("visibility","hidden"),f=e.offset();f.top-=parseInt(e.css("marginTop"),10)||0,f.left-=parseInt(e.css("marginLeft"),10)||0;var g=e.outerWidth(!0),h=e.outerHeight(!0);for(var i=0;i<c;i++)for(var j=0;j<d;j++)e.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-j*(g/d),top:-i*(h/c)}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:g/d,height:h/c,left:f.left+j*(g/d)+(b.options.mode=="show"?(j-Math.floor(d/2))*(g/d):0),top:f.top+i*(h/c)+(b.options.mode=="show"?(i-Math.floor(c/2))*(h/c):0),opacity:b.options.mode=="show"?0:1}).animate({left:f.left+j*(g/d)+(b.options.mode=="show"?0:(j-Math.floor(d/2))*(g/d)),top:f.top+i*(h/c)+(b.options.mode=="show"?0:(i-Math.floor(c/2))*(h/c)),opacity:b.options.mode=="show"?1:0},b.duration||500);setTimeout(function(){b.options.mode=="show"?e.css({visibility:"visible"}):e.css({visibility:"visible"}).hide(),b.callback&&b.callback.apply(e[0]),e.dequeue(),a("div.ui-effects-explode").remove()},b.duration||500)})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.fade.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.fade=function(b){return this.queue(function(){var c=a(this),d=a.effects.setMode(c,b.options.mode||"hide");c.animate({opacity:d},{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.fold.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.fold=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.size||15,g=!!b.options.horizFirst,h=b.duration?b.duration/2:a.fx.speeds._default/2;a.effects.save(c,d),c.show();var i=a.effects.createWrapper(c).css({overflow:"hidden"}),j=e=="show"!=g,k=j?["width","height"]:["height","width"],l=j?[i.width(),i.height()]:[i.height(),i.width()],m=/([0-9]+)%/.exec(f);m&&(f=parseInt(m[1],10)/100*l[e=="hide"?0:1]),e=="show"&&i.css(g?{height:0,width:f}:{height:f,width:0});var n={},p={};n[k[0]]=e=="show"?l[0]:f,p[k[1]]=e=="show"?l[1]:0,i.animate(n,h,b.options.easing).animate(p,h,b.options.easing,function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.highlight.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.highlight=function(b){return this.queue(function(){var c=a(this),d=["backgroundImage","backgroundColor","opacity"],e=a.effects.setMode(c,b.options.mode||"show"),f={backgroundColor:c.css("backgroundColor")};e=="hide"&&(f.opacity=0),a.effects.save(c,d),c.show().css({backgroundImage:"none",backgroundColor:b.options.color||"#ffff99"}).animate(f,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),e=="show"&&!a.support.opacity&&this.style.removeAttribute("filter"),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.pulsate.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.pulsate=function(b){return this.queue(function(){var c=a(this),d=a.effects.setMode(c,b.options.mode||"show"),e=(b.options.times||5)*2-1,f=b.duration?b.duration/2:a.fx.speeds._default/2,g=c.is(":visible"),h=0;g||(c.css("opacity",0).show(),h=1),(d=="hide"&&g||d=="show"&&!g)&&e--;for(var i=0;i<e;i++)c.animate({opacity:h},f,b.options.easing),h=(h+1)%2;c.animate({opacity:h},f,b.options.easing,function(){h==0&&c.hide(),b.callback&&b.callback.apply(this,arguments)}),c.queue("fx",function(){c.dequeue()}).dequeue()})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.scale.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.puff=function(b){return this.queue(function(){var c=a(this),d=a.effects.setMode(c,b.options.mode||"hide"),e=parseInt(b.options.percent,10)||150,f=e/100,g={height:c.height(),width:c.width()};a.extend(b.options,{fade:!0,mode:d,percent:d=="hide"?e:100,from:d=="hide"?g:{height:g.height*f,width:g.width*f}}),c.effect("scale",b.options,b.duration,b.callback),c.dequeue()})},a.effects.scale=function(b){return this.queue(function(){var c=a(this),d=a.extend(!0,{},b.options),e=a.effects.setMode(c,b.options.mode||"effect"),f=parseInt(b.options.percent,10)||(parseInt(b.options.percent,10)==0?0:e=="hide"?0:100),g=b.options.direction||"both",h=b.options.origin;e!="effect"&&(d.origin=h||["middle","center"],d.restore=!0);var i={height:c.height(),width:c.width()};c.from=b.options.from||(e=="show"?{height:0,width:0}:i);var j={y:g!="horizontal"?f/100:1,x:g!="vertical"?f/100:1};c.to={height:i.height*j.y,width:i.width*j.x},b.options.fade&&(e=="show"&&(c.from.opacity=0,c.to.opacity=1),e=="hide"&&(c.from.opacity=1,c.to.opacity=0)),d.from=c.from,d.to=c.to,d.mode=e,c.effect("size",d,b.duration,b.callback),c.dequeue()})},a.effects.size=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right","width","height","overflow","opacity"],e=["position","top","bottom","left","right","overflow","opacity"],f=["width","height","overflow"],g=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],i=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],j=a.effects.setMode(c,b.options.mode||"effect"),k=b.options.restore||!1,l=b.options.scale||"both",m=b.options.origin,n={height:c.height(),width:c.width()};c.from=b.options.from||n,c.to=b.options.to||n;if(m){var p=a.effects.getBaseline(m,n);c.from.top=(n.height-c.from.height)*p.y,c.from.left=(n.width-c.from.width)*p.x,c.to.top=(n.height-c.to.height)*p.y,c.to.left=(n.width-c.to.width)*p.x}var q={from:{y:c.from.height/n.height,x:c.from.width/n.width},to:{y:c.to.height/n.height,x:c.to.width/n.width}};if(l=="box"||l=="both")q.from.y!=q.to.y&&(d=d.concat(h),c.from=a.effects.setTransition(c,h,q.from.y,c.from),c.to=a.effects.setTransition(c,h,q.to.y,c.to)),q.from.x!=q.to.x&&(d=d.concat(i),c.from=a.effects.setTransition(c,i,q.from.x,c.from),c.to=a.effects.setTransition(c,i,q.to.x,c.to));(l=="content"||l=="both")&&q.from.y!=q.to.y&&(d=d.concat(g),c.from=a.effects.setTransition(c,g,q.from.y,c.from),c.to=a.effects.setTransition(c,g,q.to.y,c.to)),a.effects.save(c,k?d:e),c.show(),a.effects.createWrapper(c),c.css("overflow","hidden").css(c.from);if(l=="content"||l=="both")h=h.concat(["marginTop","marginBottom"]).concat(g),i=i.concat(["marginLeft","marginRight"]),f=d.concat(h).concat(i),c.find("*[width]").each(function(){var c=a(this);k&&a.effects.save(c,f);var d={height:c.height(),width:c.width()};c.from={height:d.height*q.from.y,width:d.width*q.from.x},c.to={height:d.height*q.to.y,width:d.width*q.to.x},q.from.y!=q.to.y&&(c.from=a.effects.setTransition(c,h,q.from.y,c.from),c.to=a.effects.setTransition(c,h,q.to.y,c.to)),q.from.x!=q.to.x&&(c.from=a.effects.setTransition(c,i,q.from.x,c.from),c.to=a.effects.setTransition(c,i,q.to.x,c.to)),c.css(c.from),c.animate(c.to,b.duration,b.options.easing,function(){k&&a.effects.restore(c,f)})});c.animate(c.to,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){c.to.opacity===0&&c.css("opacity",c.from.opacity),j=="hide"&&c.hide(),a.effects.restore(c,k?d:e),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.shake.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.shake=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"effect"),f=b.options.direction||"left",g=b.options.distance||20,h=b.options.times||3,i=b.duration||b.options.duration||140;a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var j=f=="up"||f=="down"?"top":"left",k=f=="up"||f=="left"?"pos":"neg",l={},m={},n={};l[j]=(k=="pos"?"-=":"+=")+g,m[j]=(k=="pos"?"+=":"-=")+g*2,n[j]=(k=="pos"?"-=":"+=")+g*2,c.animate(l,i,b.options.easing);for(var p=1;p<h;p++)c.animate(m,i,b.options.easing).animate(n,i,b.options.easing);c.animate(m,i,b.options.easing).animate(l,i/2,b.options.easing,function(){a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)}),c.queue("fx",function(){c.dequeue()}),c.dequeue()})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.slide.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.slide=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"show"),f=b.options.direction||"left";a.effects.save(c,d),c.show(),a.effects.createWrapper(c).css({overflow:"hidden"});var g=f=="up"||f=="down"?"top":"left",h=f=="up"||f=="left"?"pos":"neg",i=b.options.distance||(g=="top"?c.outerHeight(!0):c.outerWidth(!0));e=="show"&&c.css(g,h=="pos"?isNaN(i)?"-"+i:-i:i);var j={};j[g]=(e=="show"?h=="pos"?"+=":"-=":h=="pos"?"-=":"+=")+i,c.animate(j,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}})(jQuery);;/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.transfer.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.transfer=function(b){return this.queue(function(){var c=a(this),d=a(b.options.to),e=d.offset(),f={top:e.top,left:e.left,height:d.innerHeight(),width:d.innerWidth()},g=c.offset(),h=a('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(b.options.className).css({top:g.top,left:g.left,height:c.innerHeight(),width:c.innerWidth(),position:"absolute"}).animate(f,b.duration,b.options.easing,function(){h.remove(),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()})})}})(jQuery);;
/*
* jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
*
* Uses the built in easing capabilities added In jQuery 1.1
* to offer multiple easing options
*
* TERMS OF USE - jQuery Easing
*
* Open source under the BSD License.
*
* Copyright  2008 George McGinley Smith
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
* Redistributions of source code must retain the above copyright notice, this list of
* conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list
* of conditions and the following disclaimer in the documentation and/or other materials
* provided with the distribution.
*
* Neither the name of the author nor the names of contributors may be used to endorse
* or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
* GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/
// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];
jQuery.extend( jQuery.easing,
{
def: 'easeOutQuad',
swing: function (x, t, b, c, d) {
//alert(jQuery.easing.default);
return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
}
});/**
*  Ajax Autocomplete for jQuery, version 1.1.5
*  (c) 2010 Tomas Kirda, Vytautas Pranskunas
*
*  Ajax Autocomplete for jQuery is freely distributable under the terms of an MIT-style license.
*  For details, see the web site: http://www.devbridge.com/projects/autocomplete/jquery/
*
*  Last Review: 07/24/2012
*/

/*jslint onevar: true, evil: true, nomen: true, eqeqeq: true, bitwise: true, regexp: true, newcap: true, immed: true */
/*global window: true, document: true, clearInterval: true, setInterval: true, jQuery: true */

(function ($) {

	var reEscape = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'].join('|\\') + ')', 'g');

	function fnFormatResult(value, data, currentValue, showCode) {
		var pattern = '(' + currentValue.replace(reEscape, '\\$1') + ')',
		    newValue = data.name.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>'),
            result = '<span class="city">' + data.name + ', </span><span class="country">'+ data.country +'</span>';
        if (showCode)
            result += '<span class="code">' + data.code + '</span>';
        return result;
	}

	function Autocomplete(el, options) {
		this.el = $(el);
		this.el.attr('autocomplete', 'off');
		this.suggestions = [];
		this.data = [];
		this.badQueries = [];
		this.selectedIndex = -1;
		this.currentValue = this.el.val();
		this.intervalId = 0;
		this.cachedResponse = [];
		this.onChangeInterval = null;
		this.onChange = null;
		this.ignoreValueChange = false;
		this.serviceUrl = options.serviceUrl;
		this.isLocal = false;
		this.options = {
            showCode: true,
			autoSubmit: false,
			minChars: 1,
			maxHeight: 300,
			deferRequestBy: 0,
			width: 0,
			highlight: true,
			params: {},
			fnFormatResult: fnFormatResult,
			delimiter: null,
			zIndex: 9999
		};
		this.initialize();
		this.setOptions(options);
		this.el.data('autocomplete', this);
	}

	$.fn.autocomplete = function (options, optionName) {

		var autocompleteControl;

		if (typeof options == 'string') {
			autocompleteControl = this.data('autocomplete');
			if (typeof autocompleteControl[options] == 'function') {
				autocompleteControl[options](optionName);
			}
		} else {
			autocompleteControl = new Autocomplete(this.get(0) || $('<input />'), options);
		}
		return autocompleteControl;
	};


	Autocomplete.prototype = {

		killerFn: null,

		initialize: function () {

			var me, uid, autocompleteElId;
			me = this;
			uid = Math.floor(Math.random() * 0x100000).toString(16);
			autocompleteElId = 'Autocomplete_' + uid;

			this.killerFn = function (e) {
				if ($(e.target).parents('.autocomplete').size() === 0) {
					me.killSuggestions();
					me.disableKillerFn();
				}
			};

			if (!this.options.width) { this.options.width = this.el.innerWidth()-1; }
			this.mainContainerId = 'AutocompleteContainter_' + uid;

			$('<div id="' + this.mainContainerId + '" style="position:absolute;z-index:9999;"><div class="autocomplete-w1"><div class="left"></div><div class="center"></div><div class="right"></div><div class="autocomplete" id="' + autocompleteElId + '" style="display:none;"></div></div></div>').appendTo('body');

			this.container = $('#' + autocompleteElId);
			this.fixPosition();
			if (window.opera) {
				this.el.keypress(function (e) { me.onKeyPress(e); });
			} else {
				this.el.keydown(function (e) { me.onKeyPress(e); });
			}
			this.el.keyup(function (e) { me.onKeyUp(e); });
			this.el.blur(function () { me.enableKillerFn(); });
			this.el.focus(function () { me.fixPosition(); });
			this.el.change(function () { me.onValueChanged(); });
		},

		extendOptions: function (options) {
			$.extend(this.options, options);
		},

		setOptions: function (options) {
			var o = this.options;
			this.extendOptions(options);
			if (o.lookup || o.isLocal) {
				this.isLocal = true;
				if ($.isArray(o.lookup)) { o.lookup = { suggestions: o.lookup, data: [] }; }
			}
			$('#' + this.mainContainerId).css({ zIndex: o.zIndex });
			this.container.css({/* maxHeight: o.maxHeight + 'px',*/ width: o.width + 1 });
		},

		clearCache: function () {
			this.cachedResponse = [];
			this.badQueries = [];
		},

		disable: function () {
			this.disabled = true;
		},

		enable: function () {
			this.disabled = false;
		},

		fixPosition: function () {
			var offset = this.el.offset();
			$('#' + this.mainContainerId).css({ top: (offset.top + this.el.innerHeight()) + 'px', left: offset.left + 'px' });
		},

		enableKillerFn: function () {
			var me = this;
			$(document).bind('click', me.killerFn);
		},

		disableKillerFn: function () {
			var me = this;
			$(document).unbind('click', me.killerFn);
		},

		killSuggestions: function () {
			var me = this;
			this.stopKillSuggestions();
			this.intervalId = window.setInterval(function () { me.hide(); me.stopKillSuggestions(); }, 300);
		},

		stopKillSuggestions: function () {
			window.clearInterval(this.intervalId);
		},

		onValueChanged: function () {
			this.change(this.selectedIndex);
		},

		onKeyPress: function (e) {
			if (this.disabled || !this.enabled) { return; }
			// return will exit the function
			// and event will not be prevented
			switch (e.keyCode) {
				case 27: //KEY_ESC:
					this.el.val(this.currentValue);
					this.hide();
					break;
				case 9: //KEY_TAB:
				case 13: //KEY_RETURN:
					if (this.selectedIndex === -1) {
						this.hide();
						return;
					}
					this.select(this.selectedIndex);
					if (e.keyCode === 9) { return; }
					break;
				case 38: //KEY_UP:
					this.moveUp();
					break;
				case 40: //KEY_DOWN:
					this.moveDown();
					break;
				default:
					return;
			}
			e.stopImmediatePropagation();
			e.preventDefault();
		},

		onKeyUp: function (e) {
			if (this.disabled) { return; }
			switch (e.keyCode) {
				case 38: //KEY_UP:
				case 40: //KEY_DOWN:
					return;
			}
			clearInterval(this.onChangeInterval);
			if (this.currentValue !== this.el.val()) {
				if (this.options.deferRequestBy > 0) {
					// Defer lookup in case when value changes very quickly:
					var me = this;
					this.onChangeInterval = setInterval(function () { me.onValueChange(e); }, this.options.deferRequestBy);
				} else {
					this.onValueChange(e);
				}
			}
		},

		onValueChange: function (e) {
			clearInterval(this.onChangeInterval);
			this.currentValue = this.el.val();
			var q = this.getQuery(this.currentValue);
			this.selectedIndex = -1;
			if (this.ignoreValueChange) {
				this.ignoreValueChange = false;
				return;
			}
			if (q === '' || q.length < this.options.minChars) {
				this.hide();
			} else {
				this.getSuggestions(q, e);
			}
		},

		getQuery: function (val) {
			var d, arr;
			d = this.options.delimiter;
			if (!d) { return $.trim(val); }
			arr = val.split(d);
			return $.trim(arr[arr.length - 1]);
		},

		getSuggestionsLocal: function (q) {
			var ret, arr, len, val, i;
			arr = this.options.lookup;
			len = arr.suggestions.length;
			ret = { suggestions: [], data: [] };
			q = q.toLowerCase();
			for (i = 0; i < len; i++) {
				val = arr.suggestions[i];
				if (val.toLowerCase().indexOf(q) === 0) {
					ret.suggestions.push(val);
					ret.data.push(arr.data[i]);
				}
			}
			return ret;
		},

		getSuggestions: function (q, e) {

			var cr, me;
			cr = this.isLocal ? this.getSuggestionsLocal(q) : this.cachedResponse[q]; //dadeta this.options.isLocal ||
			if (cr && $.isArray(cr.suggestions)) {
				this.suggestions = cr.suggestions;
				this.data = cr.data;
				this.suggest(e);
			} else if (!this.isBadQuery(q)) {
				me = this;
				me.options.params.query = q;
				$.get(this.serviceUrl, me.options.params, function (txt) { me.processResponse(txt); }, 'jsonp');
			}
		},

		isBadQuery: function (q) {
			var i = this.badQueries.length;
			while (i--) {
				if (q.indexOf(this.badQueries[i]) === 0) { return true; }
			}
			return false;
		},

		hide: function () {
			this.enabled = false;
			this.selectedIndex = -1;
			this.container.hide();
		},

		suggest: function (e) {

			if (this.suggestions.length === 0) {
				this.hide();
				return;
			}

			var me, len, div, f, v, i, s, mOver, mClick;
			me = this;
			len = this.suggestions.length;
			f = this.options.fnFormatResult;
			v = this.getQuery(this.currentValue);
			mOver = function (xi) { return function () { me.activate(xi); }; };
			mClick = function (xi) { return function () { me.select(xi); }; };
			this.container.hide().empty();
			for (i = 0; i < len; i++) {
				s = this.suggestions[i];
				div = $((me.selectedIndex === i ? '<div class="selected"' : '<div') + ' title="' + s + '">' + f(s, this.data[i], v, this.options.showCode) + '</div>');
				div.mouseover(mOver(i));
				div.click(mClick(i));
				this.container.append(div);
			}
            if (len==1)
            {
                if (!((e) && (e.type =='keyup') && (e.keyCode==8)))
                    this.select(0);
            }
            else
            {
                this.enabled = true;
                this.container.show();
               /* if (!((e) && (e.type =='keyup') && (e.keyCode==8)))
                    this.activate(0);*/
            }
		},

		processResponse: function (text) {
			var response = text
			if (!$.isArray(response.data)) { response.data = []; }
			if (!this.options.noCache) {
				this.cachedResponse[response.query] = response;
				if (response && response.suggestions && response.suggestions.length === 0)
                {
                    this.badQueries.push(response.query);
                }
			}
			if (response.query === this.getQuery(this.currentValue)) {
				this.suggestions = response.suggestions;
				this.data = response.data;
                var e = $.Event('processRespond');
				this.suggest(e);
			}
		},

		activate: function (index) {
			var divs, activeItem;
			divs = this.container.children();
			// Clear previous selection:
			if (this.selectedIndex !== -1 && divs.length > this.selectedIndex) {
				$(divs.get(this.selectedIndex)).removeClass();
			}
			this.selectedIndex = index;
			if (this.selectedIndex !== -1 && divs.length > this.selectedIndex) {
				activeItem = divs.get(this.selectedIndex);
				$(activeItem).addClass('selected');
                this.onActivate(this.selectedIndex);
			}
			return activeItem;
		},

		deactivate: function (div, index) {
			div.className = '';
			if (this.selectedIndex === index) { this.selectedIndex = -1; }
		},

		select: function (i) {
			var selectedValue, f;
			selectedValue = this.suggestions[i];
			if (selectedValue) {
				this.el.val(selectedValue);
				if (this.options.autoSubmit) {
					f = this.el.parents('form');
					if (f.length > 0) { f.get(0).submit(); }
				}
				this.ignoreValueChange = true;
				this.hide();
				this.onSelect(i);
			}
            this.el.trigger('autocompleted');
		},

		change: function (i) {
			var selectedValue, fn, me;
			me = this;
			selectedValue = this.suggestions[i];
			if (selectedValue) {
				var s, d;
				s = me.suggestions[i];
				d = me.data[i];
				me.el.val(me.getValue(s));
			}
			else {
				s = '';
				d = -1;
			}

			fn = me.options.onChange;
			if ($.isFunction(fn)) { fn(s, d, me.el); }
		},

		moveUp: function () {
			if (this.selectedIndex === -1) { return; }
			if (this.selectedIndex === 0) {
				this.container.children().get(0).className = '';
				this.selectedIndex = -1;
                this.el.val('');
                this.el.trigger('change');
				this.el.val(this.currentValue);
				return;
			}
			this.adjustScroll(this.selectedIndex - 1);
		},

		moveDown: function () {
			if (this.selectedIndex === (this.suggestions.length - 1)) { return; }
			this.adjustScroll(this.selectedIndex + 1);
		},

		adjustScroll: function (i) {
			var activeItem, offsetTop, upperBound, lowerBound;
			activeItem = this.activate(i);
			offsetTop = activeItem.offsetTop;
			upperBound = this.container.scrollTop();
			lowerBound = upperBound + this.options.maxHeight - 25;
			if (offsetTop < upperBound) {
				this.container.scrollTop(offsetTop);
			} else if (offsetTop > lowerBound) {
				this.container.scrollTop(offsetTop - this.options.maxHeight + 25);
			}
			this.el.val(this.data[i].name);
		},

		onSelect: function (i) {
			var me, fn, s, d;
			me = this;
			fn = me.options.onSelect;
			s = me.suggestions[i];
			d = me.data[i];
			me.el.val(me.getValue(s));
			if ($.isFunction(fn)) { fn(s, d, me.el); }
		},

        onActivate: function (i) {
            var me, fn, s, d;
            me = this;
            fn = me.options.onActivate;
            s = me.suggestions[i];
            d = me.data[i];
            me.el.val(me.getValue(s));
            if ($.isFunction(fn)) { fn(s, d, me.el); }
        },

		getValue: function (value) {
			var del, currVal, arr, me;
			me = this;
			del = me.options.delimiter;
			if (!del) { return value; }
			currVal = me.currentValue;
			arr = currVal.split(del);
			if (arr.length === 1) { return value; }
			return currVal.substr(0, currVal.length - arr[arr.length - 1].length) + value;
		}

	};

} (jQuery));
/*	
 *	jQuery dotdotdot 1.5.1
 *	
 *	Copyright (c) 2012 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */


(function( $ )
{
	if ( $.fn.dotdotdot )
	{
		return;
	}

	$.fn.dotdotdot = function( o )
	{
        return;
		if ( this.length == 0 )
		{
			debug( true, 'No element found for "' + this.selector + '".' );
			return this;
		}
		if ( this.length > 1 )
		{
			return this.each(
				function()
				{
					$(this).dotdotdot( o );
				}
			);
		}


		var $dot = this;

		if ( $dot.data( 'dotdotdot' ) )
		{
			$dot.trigger( 'destroy.dot' );
		}

		$dot.bind_events = function()
		{
			$dot.bind(
				'update.dot',
				function( e, c )
				{
					e.preventDefault();
					e.stopPropagation();

					opts.maxHeight = ( typeof opts.height == 'number' ) 
						? opts.height 
						: getTrueInnerHeight( $dot );

					opts.maxHeight += opts.tolerance;

					if ( typeof c != 'undefined' )
					{
						if ( typeof c == 'string' || c instanceof HTMLElement )
						{
					 		c = $('<div />').append( c ).contents();
						}
						if ( c instanceof $ )
						{
							orgContent = c;
						}
					}

					$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
					$inr.empty()
						.append( orgContent.clone( true ) )
						.css({
							'height'	: 'auto',
							'width'		: 'auto',
							'border'	: 'none',
							'padding'	: 0,
							'margin'	: 0
						});

					var after = false,
						trunc = false;

					if ( conf.afterElement )
					{
						after = conf.afterElement.clone( true );
						conf.afterElement.remove();
					}
					if ( test( $inr, opts ) )
					{
						if ( opts.wrap == 'children' )
						{
							trunc = children( $inr, opts, after );
						}
						else
						{
							trunc = ellipsis( $inr, $dot, $inr, opts, after );
						}
					}
					$inr.replaceWith( $inr.contents() );
					$inr = null;
					
					if ( $.isFunction( opts.callback ) )
					{
						opts.callback.call( $dot[ 0 ], trunc, orgContent );
					}

					conf.isTruncated = trunc;
					return trunc;
				}

			).bind(
				'isTruncated.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], conf.isTruncated );
					}
					return conf.isTruncated;
				}

			).bind(
				'originalContent.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], orgContent );
					}
					return orgContent;
				}

			).bind(
				'destroy.dot',
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();

					$dot.unwatch()
						.unbind_events()
						.empty()
						.append( orgContent )
						.data( 'dotdotdot', false );
				}
			);
			return $dot;
		};	//	/bind_events

		$dot.unbind_events = function()
		{
			$dot.unbind('.dot');
			return $dot;
		};	//	/unbind_events

		$dot.watch = function()
		{
			$dot.unwatch();
			if ( opts.watch == 'window' )
			{
				var $window = $(window),
					_wWidth = $window.width(),
					_wHeight = $window.height(); 

				$window.bind(
					'resize.dot' + conf.dotId,
					function()
					{
						if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
						{
							_wWidth = $window.width();
							_wHeight = $window.height();
	
							if ( watchInt )
							{
								clearInterval( watchInt );
							}
							watchInt = setTimeout(
								function()
								{
									$dot.trigger( 'update.dot' );
								}, 10
							);
						}
					}
				);
			}
			else
			{
				watchOrg = getSizes( $dot );
				watchInt = setInterval(
					function()
					{
						var watchNew = getSizes( $dot );
						if ( watchOrg.width  != watchNew.width ||
							 watchOrg.height != watchNew.height )
						{
							$dot.trigger( 'update.dot' );
							watchOrg = getSizes( $dot );
						}
					}, 100
				);
			}
			return $dot;
		};
		$dot.unwatch = function()
		{
			$(window).unbind( 'resize.dot' + conf.dotId );
			if ( watchInt )
			{
				clearInterval( watchInt );
			}
			return $dot;
		};

		var	orgContent	= $dot.contents(),
			opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
			conf		= {},
			watchOrg	= {},
			watchInt	= null,
			$inr		= null;

		conf.afterElement	= getElement( opts.after, $dot );
		conf.isTruncated	= false;
		conf.dotId			= dotId++;


		$dot.data( 'dotdotdot', true )
			.bind_events()
			.trigger( 'update.dot' );

		if ( opts.watch )
		{
			$dot.watch();
		}

		return $dot;
	};


	//	public
	$.fn.dotdotdot.defaults = {
		'ellipsis'	: '... ',
		'wrap'		: 'word',
		'lastCharacter': {
			'remove'		: [ ' ', ',', ';', '.', '!', '?' ],
			'noEllipsis'	: []
		},
		'tolerance'	: 0,
		'callback'	: null,
		'after'		: null,
		'height'	: null,
		'watch'		: false,
		'windowResizeFix': true,
		'debug'		: false
	};
	

	//	private
	var dotId = 1;

	function children( $elem, o, after )
	{
		var $elements 	= $elem.children(),
			isTruncated	= false;

		$elem.empty();

		for ( var a = 0, l = $elements.length; a < l; a++ )
		{
			var $e = $elements.eq( a );
			$elem.append( $e );
			if ( after )
			{
				$elem.append( after );
			}
			if ( test( $elem, o ) )
			{
				$e.remove();
				isTruncated = true;
				break;
			}
			else
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsis( $elem, $d, $i, o, after )
	{
		var $elements 	= $elem.contents(),
			isTruncated	= false;

		$elem.empty();

		var notx = 'table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, select, optgroup, option, textarea, script, style';
		for ( var a = 0, l = $elements.length; a < l; a++ )
		{

			if ( isTruncated )
			{
				break;
			}

			var e	= $elements[ a ],
				$e	= $(e);

			if ( typeof e == 'undefined' )
			{
				continue;
			}

			$elem.append( $e );
			if ( after )
			{
				var func = ( $elem.is( notx ) )
					? 'after'
					: 'append';
				$elem[ func ]( after );
			}
			if ( e.nodeType == 3 )
			{
				if ( test( $i, o ) )
				{
					isTruncated = ellipsisElement( $e, $d, $i, o, after );
				}
			}
			else
			{
				isTruncated = ellipsis( $e, $d, $i, o, after );
			}

			if ( !isTruncated )
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsisElement( $e, $d, $i, o, after )
	{
		var isTruncated	= false,
			e			= $e[ 0 ];

		if ( typeof e == 'undefined' )
		{
			return false;
		}

		var seporator	= ( o.wrap == 'letter' ) ? '' : ' ',
			textArr		= getTextContent( e ).split( seporator ),
			position 	= -1,
			midPos		= -1,
			startPos	= 0,
			endPos		= textArr.length - 1;

		while ( startPos <= endPos )
		{
			var m = Math.floor( ( startPos + endPos ) / 2 );
			if ( m == midPos ) 
			{
				break;
			}
			midPos = m;

			setTextContent( e, textArr.slice( 0, midPos + 1 ).join( seporator ) + o.ellipsis );

			if ( !test( $i, o ) )
			{
				position	= midPos;
				startPos	= midPos; 
			}
			else
			{
				endPos		= midPos;
			}				
		}	
	
		if ( position != -1 )
		{
			var txt = textArr.slice( 0, position + 1 ).join( seporator );
			isTruncated = true;

			while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
			{
				txt = txt.slice( 0, -1 );
			}
			if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
			{
				txt += o.ellipsis;
			}
			setTextContent( e, txt );
		}
		else
		{
			var $w = $e.parent();
			$e.remove();
			$n = $w.contents().eq( -1 );

			isTruncated = ellipsisElement( $n, $d, $i, o, after );
		}

		return isTruncated;
	}
	function test( $i, o )
	{
		return $i.innerHeight() > o.maxHeight;
	}
	function getSizes( $d )
	{
		return {
			'width'	: $d.innerWidth(),
			'height': $d.innerHeight()
		};
	}
	function setTextContent( e, content )
	{
		if ( e.innerText )
		{
			e.innerText = content;
		}
		else if ( e.nodeValue )
		{
			e.nodeValue = content;
		}
		else if (e.textContent)
		{
			e.textContent = content;
		}
	}
	function getTextContent( e )
	{
		if ( e.innerText )
		{
			return e.innerText;
		}
		else if ( e.nodeValue )
		{
			return e.nodeValue;
		}
		else if ( e.textContent )
		{
			return e.textContent;
		}
		else
		{
			return "";
		}
	}
	function getElement( e, $i )
	{
		if ( typeof e == 'undefined' )
		{
			return false;
		}
		if ( !e )
		{
			return false;
		}
		if ( typeof e == 'string' )
		{
			e = $(e, $i);
			return ( e.length )
				? e 
				: false;
		}
		if ( typeof e == 'object' )
		{
			return ( typeof e.jquery == 'undefined' )
				? false
				: e;
		}
		return false;
	}
	function getTrueInnerHeight( $el )
	{
		var h = $el.innerHeight(),
			a = [ 'paddingTop', 'paddingBottom' ];

		for ( z = 0, l = a.length; z < l; z++ ) {
			var m = parseInt( $el.css( a[ z ] ), 10 );
			if ( isNaN( m ) )
			{
				m = 0;
			}
			h -= m;
		}
		return h;
	}
	function debug( d, m )
	{
		if ( !d )
		{
			return false;
		}
		if ( typeof m == 'string' )
		{
			m = 'dotdotdot: ' + m;
		}
		else
		{
			m = [ 'dotdotdot:', m ];
		}

		if ( window.console && window.console.log )
		{
			window.console.log( m );
		}
		return false;
	}
	

	//	override jQuery.html
	var _orgHtml = $.fn.html;
    $.fn.html = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				if ( typeof str != 'function' )
				{
					return this.trigger( 'update', [ str ] );
				}
			}
			return _orgHtml.call( this, str );
		}
		return _orgHtml.call( this );
    };


	//	override jQuery.text
	var _orgText = $.fn.text;
    $.fn.text = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				var temp = $( '<div />' );
				temp.text( str );
				str = temp.html();
				temp.remove();
				return this.trigger( 'update', [ str ] );
			}
			return _orgText.call( this, str );
		}
        return _orgText.call( this );
    };


})( jQuery );// moment.js
// version : 1.7.0
// author : Tim Wood
// license : MIT
// momentjs.com

(function (Date, undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "1.7.0",
        round = Math.round, i,
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // Parameters to check for on the lang config.  This list of properties
        // will be inherited from English if not provided in a language
        // definition.  monthsParse is also a lang config property, but it
        // cannot be inherited and as such cannot be enumerated here.
        langConfigProperties = 'months|monthsShort|weekdays|weekdaysShort|weekdaysMin|longDateFormat|calendar|relativeTime|ordinal|meridiem'.split('|'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?)/g,
        localFormattingTokens = /(LT|LL?L?L?)/g,
        formattingRemoveEscapes = /(^\[)|(\\)|\]$/g,

        // parsing tokens
        parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenWord = /[0-9a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+/i, // any word characters or numbers
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO seperator)

        // preliminary iso regex 
        // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000
        isoRegex = /^\s*\d{4}-\d\d-\d\d(T(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.S', /T\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /T\d\d:\d\d:\d\d/],
            ['HH:mm', /T\d\d:\d\d/],
            ['HH', /T\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Month|Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        // format function strings
        formatFunctions = {},

        /*
         * moment.fn.format uses new Function() to create an inlined formatting function.
         * Results are a 3x speed boost
         * http://jsperf.com/momentjs-cached-format-functions
         *
         * These strings are appended into a function using replaceFormatTokens and makeFormatFunction
         */
        formatFunctionStrings = {
            // a = placeholder
            // b = placeholder
            // t = the current moment being formatted
            // v = getValueAtKey function
            // o = language.ordinal function
            // p = leftZeroFill function
            // m = language.meridiem value or function
            M    : '(a=t.month()+1)',
            MMM  : 'v("monthsShort",t.month())',
            MMMM : 'v("months",t.month())',
            D    : '(a=t.date())',
            DDD  : '(a=new Date(t.year(),t.month(),t.date()),b=new Date(t.year(),0,1),a=~~(((a-b)/864e5)+1.5))',
            d    : '(a=t.day())',
            dd   : 'v("weekdaysMin",t.day())',
            ddd  : 'v("weekdaysShort",t.day())',
            dddd : 'v("weekdays",t.day())',
            w    : '(a=new Date(t.year(),t.month(),t.date()-t.day()+5),b=new Date(a.getFullYear(),0,4),a=~~((a-b)/864e5/7+1.5))',
            YY   : 'p(t.year()%100,2)',
            YYYY : 'p(t.year(),4)',
            a    : 'm(t.hours(),t.minutes(),!0)',
            A    : 'm(t.hours(),t.minutes(),!1)',
            H    : 't.hours()',
            h    : 't.hours()%12||12',
            m    : 't.minutes()',
            s    : 't.seconds()',
            S    : '~~(t.milliseconds()/100)',
            SS   : 'p(~~(t.milliseconds()/10),2)',
            SSS  : 'p(t.milliseconds(),3)',
            Z    : '((a=-t.zone())<0?((a=-a),"-"):"+")+p(~~(a/60),2)+":"+p(~~a%60,2)',
            ZZ   : '((a=-t.zone())<0?((a=-a),"-"):"+")+p(~~(10*a/6),4)'
        },

        ordinalizeTokens = 'DDD w M D d'.split(' '),
        paddedTokens = 'M D H h m s w'.split(' ');

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatFunctionStrings[i + 'o'] = formatFunctionStrings[i] + '+o(a)';
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatFunctionStrings[i + i] = 'p(' + formatFunctionStrings[i] + ',2)';
    }
    formatFunctionStrings.DDDD = 'p(' + formatFunctionStrings.DDD + ',3)';


    /************************************
        Constructors
    ************************************/


    // Moment prototype object
    function Moment(date, isUTC, lang) {
        this._d = date;
        this._isUTC = !!isUTC;
        this._a = date._a || null;
        date._a = null;
        this._lang = lang || false;
    }

    // Duration Constructor
    function Duration(duration) {
        var data = this._data = {},
            years = duration.years || duration.y || 0,
            months = duration.months || duration.M || 0, 
            weeks = duration.weeks || duration.w || 0,
            days = duration.days || duration.d || 0,
            hours = duration.hours || duration.h || 0,
            minutes = duration.minutes || duration.m || 0,
            seconds = duration.seconds || duration.s || 0,
            milliseconds = duration.milliseconds || duration.ms || 0;

        // representation for dateAddRemove
        this._milliseconds = milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = months +
            years * 12;
            
        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;
        seconds += absRound(milliseconds / 1000);

        data.seconds = seconds % 60;
        minutes += absRound(seconds / 60);

        data.minutes = minutes % 60;
        hours += absRound(minutes / 60);

        data.hours = hours % 24;
        days += absRound(hours / 24);

        days += weeks * 7;
        data.days = days % 30;
        
        months += absRound(days / 30);

        data.months = months % 12;
        years += absRound(months / 12);

        data.years = years;

        this._lang = false;
    }


    /************************************
        Helpers
    ************************************/


    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength) {
        var output = number + '';
        while (output.length < targetLength) {
            output = '0' + output;
        }
        return output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
        var ms = duration._milliseconds,
            d = duration._days,
            M = duration._months,
            currentDate;

        if (ms) {
            mom._d.setTime(+mom + ms * isAdding);
        }
        if (d) {
            mom.date(mom.date() + d * isAdding);
        }
        if (M) {
            currentDate = mom.date();
            mom.date(1)
                .month(mom.month() + M * isAdding)
                .date(Math.min(currentDate, mom.daysInMonth()));
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (~~array1[i] !== ~~array2[i]) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromArray(input, asUTC) {
        var i, date;
        for (i = 1; i < 7; i++) {
            input[i] = (input[i] == null) ? (i === 2 ? 1 : 0) : input[i];
        }
        // we store whether we used utc or not in the input array
        input[7] = asUTC;
        date = new Date(0);
        if (asUTC) {
            date.setUTCFullYear(input[0], input[1], input[2]);
            date.setUTCHours(input[3], input[4], input[5], input[6]);
        } else {
            date.setFullYear(input[0], input[1], input[2]);
            date.setHours(input[3], input[4], input[5], input[6]);
        }
        date._a = input;
        return date;
    }

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        var i, m,
            parse = [];

        if (!values && hasModule) {
            values = require('./lang/' + key);
        }
        
        for (i = 0; i < langConfigProperties.length; i++) {
            // If a language definition does not provide a value, inherit
            // from English
            values[langConfigProperties[i]] = values[langConfigProperties[i]] ||
              languages.en[langConfigProperties[i]];
        }

        for (i = 0; i < 12; i++) {
            m = moment([2000, i]);
            parse[i] = new RegExp('^' + (values.months[i] || values.months(m, '')) + 
                '|^' + (values.monthsShort[i] || values.monthsShort(m, '')).replace('.', ''), 'i');
        }
        values.monthsParse = values.monthsParse || parse;

        languages[key] = values;
        
        return values;
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.  If you pass in a moment or duration instance, it
    // will decide the language based on that, or default to the global
    // language.
    function getLangDefinition(m) {
        var langKey = (typeof m === 'string') && m ||
                      m && m._lang ||
                      null;

        return langKey ? (languages[langKey] || loadLang(langKey)) : moment;
    }


    /************************************
        Formatting
    ************************************/


    // helper for building inline formatting functions
    function replaceFormatTokens(token) {
        return formatFunctionStrings[token] ? 
            ("'+(" + formatFunctionStrings[token] + ")+'") :
            token.replace(formattingRemoveEscapes, "").replace(/\\?'/g, "\\'");
    }

    // helper for recursing long date formatting tokens
    function replaceLongDateFormatTokens(input) {
        return getLangDefinition().longDateFormat[input] || input;
    }

    function makeFormatFunction(format) {
        var output = "var a,b;return '" +
            format.replace(formattingTokens, replaceFormatTokens) + "';",
            Fn = Function; // get around jshint
        // t = the current moment being formatted
        // v = getValueAtKey function
        // o = language.ordinal function
        // p = leftZeroFill function
        // m = language.meridiem value or function
        return new Fn('t', 'v', 'o', 'p', 'm', output);
    }

    function makeOrGetFormatFunction(format) {
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format];
    }

    // format date using native date object
    function formatMoment(m, format) {
        var lang = getLangDefinition(m);

        function getValueFromArray(key, index) {
            return lang[key].call ? lang[key](m, format) : lang[key][index];
        }

        while (localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        }

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m, getValueFromArray, lang.ordinal, leftZeroFill, lang.meridiem);
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token) {
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
            return parseTokenFourDigits;
        case 'S':
        case 'SS':
        case 'SSS':
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'a':
        case 'A':
            return parseTokenWord;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
            return parseTokenOneOrTwoDigits;
        default :
            return new RegExp(token.replace('\\', ''));
        }
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, datePartArray, config) {
        var a;
        //console.log('addTime', format, input);
        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            datePartArray[1] = (input == null) ? 0 : ~~input - 1;
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            for (a = 0; a < 12; a++) {
                if (getLangDefinition().monthsParse[a].test(input)) {
                    datePartArray[1] = a;
                    break;
                }
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DDDD
        case 'DD' : // fall through to DDDD
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                datePartArray[2] = ~~input;
            }
            break;
        // YEAR
        case 'YY' :
            input = ~~input;
            datePartArray[0] = input + (input > 70 ? 1900 : 2000);
            break;
        case 'YYYY' :
            datePartArray[0] = ~~Math.abs(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config.isPm = ((input + '').toLowerCase() === 'pm');
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[3] = ~~input;
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[4] = ~~input;
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[5] = ~~input;
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
            datePartArray[6] = ~~ (('0.' + input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config.isUTC = true;
            a = (input + '').match(parseTimezoneChunker);
            if (a && a[1]) {
                config.tzh = ~~a[1];
            }
            if (a && a[2]) {
                config.tzm = ~~a[2];
            }
            // reverse offsets
            if (a && a[0] === '+') {
                config.tzh = -config.tzh;
                config.tzm = -config.tzm;
            }
            break;
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(string, format) {
        var datePartArray = [0, 0, 1, 0, 0, 0, 0],
            config = {
                tzh : 0, // timezone hour offset
                tzm : 0  // timezone minute offset
            },
            tokens = format.match(formattingTokens),
            i, parsedInput;

        for (i = 0; i < tokens.length; i++) {
            parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
            string = string.replace(getParseRegexForToken(tokens[i]), '');
            addTimeToArrayFromToken(tokens[i], parsedInput, datePartArray, config);
        }
        // handle am pm
        if (config.isPm && datePartArray[3] < 12) {
            datePartArray[3] += 12;
        }
        // if is 12 am, change hours to 0
        if (config.isPm === false && datePartArray[3] === 12) {
            datePartArray[3] = 0;
        }
        // handle timezone
        datePartArray[3] += config.tzh;
        datePartArray[4] += config.tzm;
        // return
        return dateFromArray(datePartArray, config.isUTC);
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(string, formats) {
        var output,
            inputParts = string.match(parseMultipleFormatChunker) || [],
            formattedInputParts,
            scoreToBeat = 99,
            i,
            currentDate,
            currentScore;
        for (i = 0; i < formats.length; i++) {
            currentDate = makeDateFromStringAndFormat(string, formats[i]);
            formattedInputParts = formatMoment(new Moment(currentDate), formats[i]).match(parseMultipleFormatChunker) || [];
            currentScore = compareArrays(inputParts, formattedInputParts);
            if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                output = currentDate;
            }
        }
        return output;
    }

    // date from iso format
    function makeDateFromString(string) {
        var format = 'YYYY-MM-DDT',
            i;
        if (isoRegex.exec(string)) {
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    format += isoTimes[i][0];
                    break;
                }
            }
            return parseTokenTimezone.exec(string) ? 
                makeDateFromStringAndFormat(string, format + ' Z') :
                makeDateFromStringAndFormat(string, format);
        }
        return new Date(string);
    }


    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        var rt = lang.relativeTime[string];
        return (typeof rt === 'function') ?
            rt(number || 1, !!withoutSuffix, string, isFuture) :
            rt.replace(/%d/i, number || 1);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Top Level Functions
    ************************************/


    moment = function (input, format) {
        if (input === null || input === '') {
            return null;
        }
        var date,
            matched;
        // parse Moment object
        if (moment.isMoment(input)) {
            return new Moment(new Date(+input._d), input._isUTC, input._lang);
        // parse string and format
        } else if (format) {
            if (isArray(format)) {
                date = makeDateFromStringAndArray(input, format);
            } else {
                date = makeDateFromStringAndFormat(input, format);
            }
        // evaluate it as a JSON-encoded date
        } else {
            matched = aspNetJsonRegex.exec(input);
            date = input === undefined ? new Date() :
                matched ? new Date(+matched[1]) :
                input instanceof Date ? input :
                isArray(input) ? dateFromArray(input) :
                typeof input === 'string' ? makeDateFromString(input) :
                new Date(input);
        }

        return new Moment(date);
    };

    // creating with utc
    moment.utc = function (input, format) {
        if (isArray(input)) {
            return new Moment(dateFromArray(input, true), true);
        }
        // if we don't have a timezone, we need to add one to trigger parsing into utc
        if (typeof input === 'string' && !parseTokenTimezone.exec(input)) {
            input += ' +0000';
            if (format) {
                format += ' Z';
            }
        }
        return moment(input, format).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var isDuration = moment.isDuration(input),
            isNumber = (typeof input === 'number'),
            duration = (isDuration ? input._data : (isNumber ? {} : input)),
            ret;

        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        }

        ret = new Duration(duration);

        if (isDuration) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // humanizeDuration
    // This method is deprecated in favor of the new Duration object.  Please
    // see the moment.duration method.
    moment.humanizeDuration = function (num, type, withSuffix) {
        return moment.duration(num, type === true ? null : type).humanize(type === true ? true : withSuffix);
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var i;

        if (!key) {
            return currentLanguage;
        }
        if (values || !languages[key]) {
            loadLang(key, values);
        }
        if (languages[key]) {
            // deprecated, to get the language definition variables, use the
            // moment.fn.lang method or the getLangDefinition function.
            for (i = 0; i < langConfigProperties.length; i++) {
                moment[langConfigProperties[i]] = languages[key][langConfigProperties[i]];
            }
            moment.monthsParse = languages[key].monthsParse;
            currentLanguage = key;
        }
    };

    // returns language data
    moment.langData = getLangDefinition;

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        }
    });


    /************************************
        Moment Prototype
    ************************************/


    moment.fn = Moment.prototype = {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d;
        },

        unix : function () {
            return Math.floor(+this._d / 1000);
        },

        toString : function () {
            return this._d.toString();
        },

        toDate : function () {
            return this._d;
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds(),
                !!this._isUTC
            ];
        },

        isValid : function () {
            if (this._a) {
                return !compareArrays(this._a, (this._a[7] ? moment.utc(this) : this).toArray());
            }
            return !isNaN(this._d.getTime());
        },

        utc : function () {
            this._isUTC = true;
            return this;
        },

        local : function () {
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            return formatMoment(this, inputString ? inputString : moment.defaultFormat);
        },

        add : function (input, val) {
            var dur = val ? moment.duration(+val, input) : moment.duration(input);
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur = val ? moment.duration(+val, input) : moment.duration(input);
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, val, asFloat) {
            var inputMoment = this._isUTC ? moment(input).utc() : moment(input).local(),
                zoneDiff = (this.zone() - inputMoment.zone()) * 6e4,
                diff = this._d - inputMoment._d - zoneDiff,
                year = this.year() - inputMoment.year(),
                month = this.month() - inputMoment.month(),
                date = this.date() - inputMoment.date(),
                output;
            if (val === 'months') {
                output = year * 12 + month + date / 30;
            } else if (val === 'years') {
                output = year + (month + date / 30) / 12;
            } else {
                output = val === 'seconds' ? diff / 1e3 : // 1000
                    val === 'minutes' ? diff / 6e4 : // 1000 * 60
                    val === 'hours' ? diff / 36e5 : // 1000 * 60 * 60
                    val === 'days' ? diff / 864e5 : // 1000 * 60 * 60 * 24
                    val === 'weeks' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7
                    diff;
            }
            return asFloat ? output : round(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this._lang).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            var diff = this.diff(moment().sod(), 'days', true),
                calendar = this.lang().calendar,
                allElse = calendar.sameElse,
                format = diff < -6 ? allElse :
                diff < -1 ? calendar.lastWeek :
                diff < 0 ? calendar.lastDay :
                diff < 1 ? calendar.sameDay :
                diff < 2 ? calendar.nextDay :
                diff < 7 ? calendar.nextWeek : allElse;
            return this.format(typeof format === 'function' ? format.apply(this) : format);
        },

        isLeapYear : function () {
            var year = this.year();
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        },

        isDST : function () {
            return (this.zone() < moment([this.year()]).zone() || 
                this.zone() < moment([this.year(), 5]).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return input == null ? day :
                this.add({ d : input - day });
        },

        startOf: function (val) {
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (val.replace(/s$/, '')) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }
            return this;
        },

        endOf: function (val) {
            return this.startOf(val).add(val.replace(/s?$/, 's'), 1).subtract('ms', 1);
        },
        
        sod: function () {
            return this.clone().startOf('day');
        },

        eod: function () {
            // end of day = start of day plus 1 day, minus 1 millisecond
            return this.clone().endOf('day');
        },

        zone : function () {
            return this._isUTC ? 0 : this._d.getTimezoneOffset();
        },

        daysInMonth : function () {
            return moment.utc([this.year(), this.month() + 1, 0]).date();
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (lang) {
            if (lang === undefined) {
                return getLangDefinition(this);
            } else {
                this._lang = lang;
                return this;
            }
        }
    };

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase(), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');


    /************************************
        Duration Prototype
    ************************************/


    moment.duration.fn = Duration.prototype = {
        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              this._months * 2592e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                rel = this.lang().relativeTime,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = (difference <= 0 ? rel.past : rel.future).replace(/%s/i, output);
            }

            return output;
        },

        lang : moment.fn.lang
    };

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);


    /************************************
        Exposing Moment
    ************************************/


    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    }
    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        this['moment'] = moment;
    }
    /*global define:false */
    if (typeof define === "function" && define.amd) {
        define("moment", [], function () {
            return moment;
        });
    }
}).call(this, Date);
// moment.js language configuration
// language : russian (ru)
// author : Viktorminator : https://github.com/Viktorminator
(function () {

    var pluralRules = [
            function (n) { return ((n % 10 === 1) && (n % 100 !== 11)); },
            function (n) { return ((n % 10) >= 2 && (n % 10) <= 4 && ((n % 10) % 1) === 0) && ((n % 100) < 12 || (n % 100) > 14); },
            function (n) { return ((n % 10) === 0 || ((n % 10) >= 5 && (n % 10) <= 9 && ((n % 10) % 1) === 0) || ((n % 100) >= 11 && (n % 100) <= 14 && ((n % 100) % 1) === 0)); },
            function (n) { return true; }
        ],

        plural = function (word, num) {
            var forms = word.split('_'),
                minCount = Math.min(pluralRules.length, forms.length),
                i = -1;

            while (++i < minCount) {
                if (pluralRules[i](num)) {
                    return forms[i];
                }
            }
            return forms[minCount - 1];
        },

        relativeTimeWithPlural = function (number, withoutSuffix, key) {
            var format = {
                'mm': '___',
                'hh': '___',
                'dd': '___',
                'MM': '___',
                'yy': '___'
            };
            if (key === 'm') {
                return withoutSuffix ? '' : '';
            }
            else {
                return number + ' ' + plural(format[key], +number);
            }
        },

        monthsCaseReplace = function (m, format) {
            var months = {
                    'nominative': '___________'.split('_'),
                    'accusative': '___________'.split('_')
                },

                nounCase = (/D[oD]? *MMMM?/).test(format) ?
                    'accusative' :
                    'nominative';

            return months[nounCase][m.month()];
        },

        weekdaysCaseReplace = function (m, format) {
            var weekdays = {
                    'nominative': '______'.split('_'),
                    'accusative': '______'.split('_')
                },

                nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
                    'accusative' :
                    'nominative';

            return weekdays[nounCase][m.day()];
        },

        lang = {
            months : monthsCaseReplace,
            monthsShort : "___________".split("_"),
            weekdays : weekdaysCaseReplace,
            weekdaysShort : "______".split("_"),
            weekdaysMin : "______".split("_"),
            longDateFormat : {
                LT : "HH:mm",
                L : "DD.MM.YYYY",
                LL : "D MMMM YYYY .",
                LLL : "D MMMM YYYY ., LT",
                LLLL : "dddd, D MMMM YYYY ., LT"
            },
            calendar : {
                sameDay: '[ ] LT',
                nextDay: '[ ] LT',
                lastDay: '[ ] LT',
                nextWeek: function () {
                    return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
                },
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd [] LT';
                    }
                },
                sameElse: 'L'
            },
            // It needs checking (adding) russian plurals and cases.
            relativeTime : {
                future : " %s",
                past : "%s ",
                s : " ",
                m : relativeTimeWithPlural,
                mm : relativeTimeWithPlural,
                h : "",
                hh : relativeTimeWithPlural,
                d : "",
                dd : relativeTimeWithPlural,
                M : "",
                MM : relativeTimeWithPlural,
                y : "",
                yy : relativeTimeWithPlural
            },
            ordinal : function (number) {
                return '.';
            }
        };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = lang;
    }
    // Browser
    if (typeof window !== 'undefined' && this.moment && this.moment.lang) {
        this.moment.lang('ru', lang);
    }
}());/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }
    
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;
    
    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }
    
    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);
    
    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);
/*!
 * jScrollPane - v2.0.0beta12 - 2012-09-27
 * http://jscrollpane.kelvinluck.com/
 *
 * Copyright (c) 2010 Kelvin Luck
 * Dual licensed under the MIT or GPL licenses.
 */

// Script: jScrollPane - cross browser customisable scrollbars
//
// *Version: 2.0.0beta12, Last updated: 2012-09-27*
//
// Project Home - http://jscrollpane.kelvinluck.com/
// GitHub       - http://github.com/vitch/jScrollPane
// Source       - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.js
// (Minified)   - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.min.js
//
// About: License
//
// Copyright (c) 2012 Kelvin Luck
// Dual licensed under the MIT or GPL Version 2 licenses.
// http://jscrollpane.kelvinluck.com/MIT-LICENSE.txt
// http://jscrollpane.kelvinluck.com/GPL-LICENSE.txt
//
// About: Examples
//
// All examples and demos are available through the jScrollPane example site at:
// http://jscrollpane.kelvinluck.com/
//
// About: Support and Testing
//
// This plugin is tested on the browsers below and has been found to work reliably on them. If you run
// into a problem on one of the supported browsers then please visit the support section on the jScrollPane
// website (http://jscrollpane.kelvinluck.com/) for more information on getting support. You are also
// welcome to fork the project on GitHub if you can contribute a fix for a given issue. 
//
// jQuery Versions - tested in 1.4.2+ - reported to work in 1.3.x
// Browsers Tested - Firefox 3.6.8, Safari 5, Opera 10.6, Chrome 5.0, IE 6, 7, 8
//
// About: Release History
//
// 2.0.0beta12 - (2012-09-27) fix for jQuery 1.8+
// 2.0.0beta11 - (2012-05-14)
// 2.0.0beta10 - (2011-04-17) cleaner required size calculation, improved keyboard support, stickToBottom/Left, other small fixes
// 2.0.0beta9 - (2011-01-31) new API methods, bug fixes and correct keyboard support for FF/OSX
// 2.0.0beta8 - (2011-01-29) touchscreen support, improved keyboard support
// 2.0.0beta7 - (2011-01-23) scroll speed consistent (thanks Aivo Paas)
// 2.0.0beta6 - (2010-12-07) scrollToElement horizontal support
// 2.0.0beta5 - (2010-10-18) jQuery 1.4.3 support, various bug fixes
// 2.0.0beta4 - (2010-09-17) clickOnTrack support, bug fixes
// 2.0.0beta3 - (2010-08-27) Horizontal mousewheel, mwheelIntent, keyboard support, bug fixes
// 2.0.0beta2 - (2010-08-21) Bug fixes
// 2.0.0beta1 - (2010-08-17) Rewrite to follow modern best practices and enable horizontal scrolling, initially hidden
//							 elements and dynamically sized elements.
// 1.x - (2006-12-31 - 2010-07-31) Initial version, hosted at googlecode, deprecated

(function($,window,undefined){

    $.fn.jScrollPane = function(settings)
    {
        // JScrollPane "class" - public methods are available through $('selector').data('jsp')
        function JScrollPane(elem, s)
        {
            var settings, jsp = this, pane, paneWidth, paneHeight, container, contentWidth, contentHeight,
                percentInViewH, percentInViewV, isScrollableV, isScrollableH, verticalDrag, dragMaxY,
                verticalDragPosition, horizontalDrag, dragMaxX, horizontalDragPosition,
                verticalBar, verticalTrack, scrollbarWidth, verticalTrackHeight, verticalDragHeight, arrowUp, arrowDown,
                horizontalBar, horizontalTrack, horizontalTrackWidth, horizontalDragWidth, arrowLeft, arrowRight,
                reinitialiseInterval, originalPadding, originalPaddingTotalWidth, previousContentWidth,
                wasAtTop = true, wasAtLeft = true, wasAtBottom = false, wasAtRight = false,
                originalElement = elem.clone(false, false).empty(),
                mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';

            originalPadding = elem.css('paddingTop') + ' ' +
                elem.css('paddingRight') + ' ' +
                elem.css('paddingBottom') + ' ' +
                elem.css('paddingLeft');
            originalPaddingTotalWidth = (parseInt(elem.css('paddingLeft'), 10) || 0) +
                (parseInt(elem.css('paddingRight'), 10) || 0);

            function initialise(s)
            {

                var /*firstChild, lastChild, */isMaintainingPositon, lastContentX, lastContentY,
                    hasContainingSpaceChanged, originalScrollTop, originalScrollLeft,
                    maintainAtBottom = false, maintainAtRight = false;

                settings = s;

                if (pane === undefined) {
                    originalScrollTop = elem.scrollTop();
                    originalScrollLeft = elem.scrollLeft();

                    elem.css(
                        {
                            overflow: 'hidden',
                            padding: 0
                        }
                    );
                    // TODO: Deal with where width/ height is 0 as it probably means the element is hidden and we should
                    // come back to it later and check once it is unhidden...
                    paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
                    paneHeight = elem.innerHeight();

                    elem.width(paneWidth);

                    pane = $('<div class="jspPane" />').css('padding', originalPadding).append(elem.children());
                    container = $('<div class="jspContainer" />')
                        .css({
                            'width': paneWidth + 'px',
                            'height': paneHeight + 'px'
                        }
                    ).append(pane).appendTo(elem);

                    /*
                     // Move any margins from the first and last children up to the container so they can still
                     // collapse with neighbouring elements as they would before jScrollPane
                     firstChild = pane.find(':first-child');
                     lastChild = pane.find(':last-child');
                     elem.css(
                     {
                     'margin-top': firstChild.css('margin-top'),
                     'margin-bottom': lastChild.css('margin-bottom')
                     }
                     );
                     firstChild.css('margin-top', 0);
                     lastChild.css('margin-bottom', 0);
                     */
                } else {
                    elem.css('width', '');

                    maintainAtBottom = settings.stickToBottom && isCloseToBottom();
                    maintainAtRight  = settings.stickToRight  && isCloseToRight();

                    hasContainingSpaceChanged = elem.innerWidth() + originalPaddingTotalWidth != paneWidth || elem.outerHeight() != paneHeight;
                    if (hasContainingSpaceChanged) {
                        paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
                        paneHeight = elem.innerHeight();
                        container.css({
                            width: paneWidth + 'px',
                            height: paneHeight + 'px'
                        });
                    }

                    // If nothing changed since last check...
                    if (!hasContainingSpaceChanged && previousContentWidth == contentWidth && pane.outerHeight() == contentHeight) {
                        elem.width(paneWidth);
                        return;
                    }
                    previousContentWidth = contentWidth;

                    pane.css('width', '');
                    elem.width(paneWidth);
                    container.find('>.jspVerticalBar,>.jspHorizontalBar').remove().end();
                }

                pane.css('overflow', 'auto');
                if (s.contentWidth) {
                    contentWidth = s.contentWidth;
                } else {
                    contentWidth = pane[0].scrollWidth;
                }
                contentHeight = pane[0].scrollHeight;
                pane.css('overflow', '');

                percentInViewH = contentWidth / paneWidth;
                percentInViewV = contentHeight / paneHeight;
                isScrollableV = percentInViewV > 1;

                isScrollableH = percentInViewH > 1;

                //console.log(paneWidth, paneHeight, contentWidth, contentHeight, percentInViewH, percentInViewV, isScrollableH, isScrollableV);

                if (!(isScrollableH || isScrollableV)) {
                    elem.removeClass('jspScrollable');
                    pane.css({
                        top: 0,
                        width: container.width() - originalPaddingTotalWidth
                    });
                    removeMousewheel();
                    removeFocusHandler();
                    removeKeyboardNav();
                    removeClickOnTrack();
                } else {
                    elem.addClass('jspScrollable');

                    isMaintainingPositon = settings.maintainPosition && (verticalDragPosition || horizontalDragPosition);
                    if (isMaintainingPositon) {
                        lastContentX = contentPositionX();
                        lastContentY = contentPositionY();
                    }

                    initialiseVerticalScroll();
                    initialiseHorizontalScroll();
                    resizeScrollbars();

                    if (isMaintainingPositon) {
                        scrollToX(maintainAtRight  ? (contentWidth  - paneWidth ) : lastContentX, false);
                        scrollToY(maintainAtBottom ? (contentHeight - paneHeight) : lastContentY, false);
                    }

                    initFocusHandler();
                    initMousewheel();
                    initTouch();

                    if (settings.enableKeyboardNavigation) {
                        initKeyboardNav();
                    }
                    if (settings.clickOnTrack) {
                        initClickOnTrack();
                    }

                    observeHash();
                    if (settings.hijackInternalLinks) {
                        hijackInternalLinks();
                    }
                }

                if (settings.autoReinitialise && !reinitialiseInterval) {
                    reinitialiseInterval = setInterval(
                        function()
                        {
                            initialise(settings);
                        },
                        settings.autoReinitialiseDelay
                    );
                } else if (!settings.autoReinitialise && reinitialiseInterval) {
                    clearInterval(reinitialiseInterval);
                }

                originalScrollTop && elem.scrollTop(0) && scrollToY(originalScrollTop, false);
                originalScrollLeft && elem.scrollLeft(0) && scrollToX(originalScrollLeft, false);

                elem.trigger('jsp-initialised', [isScrollableH || isScrollableV]);
            }

            function initialiseVerticalScroll()
            {
                if (isScrollableV) {

                    container.append(
                        $('<div class="jspVerticalBar" />').append(
                            $('<div class="jspCap jspCapTop" />'),
                            $('<div class="jspTrack" />').append(
                                $('<div class="jspDrag" />').append(
                                    $('<div class="jspDragTop" />'),
                                    $('<div class="jspDragBottom" />')
                                )
                            ),
                            $('<div class="jspCap jspCapBottom" />')
                        )
                    );

                    verticalBar = container.find('>.jspVerticalBar');
                    verticalTrack = verticalBar.find('>.jspTrack');
                    verticalDrag = verticalTrack.find('>.jspDrag');

                    if (settings.showArrows) {
                        arrowUp = $('<a class="jspArrow jspArrowUp" />').bind(
                            'mousedown.jsp', getArrowScroll(0, -1)
                        ).bind('click.jsp', nil);
                        arrowDown = $('<a class="jspArrow jspArrowDown" />').bind(
                            'mousedown.jsp', getArrowScroll(0, 1)
                        ).bind('click.jsp', nil);
                        if (settings.arrowScrollOnHover) {
                            arrowUp.bind('mouseover.jsp', getArrowScroll(0, -1, arrowUp));
                            arrowDown.bind('mouseover.jsp', getArrowScroll(0, 1, arrowDown));
                        }

                        appendArrows(verticalTrack, settings.verticalArrowPositions, arrowUp, arrowDown);
                    }

                    verticalTrackHeight = paneHeight;
                    container.find('>.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow').each(
                        function()
                        {
                            verticalTrackHeight -= $(this).outerHeight();
                        }
                    );


                    verticalDrag.hover(
                        function()
                        {
                            verticalDrag.addClass('jspHover');
                        },
                        function()
                        {
                            verticalDrag.removeClass('jspHover');
                        }
                    ).bind(
                        'mousedown.jsp',
                        function(e)
                        {
                            // Stop IE from allowing text selection
                            $('html').bind('dragstart.jsp selectstart.jsp', nil);

                            verticalDrag.addClass('jspActive');

                            var startY = e.pageY - verticalDrag.position().top;

                            $('html').bind(
                                'mousemove.jsp',
                                function(e)
                                {
                                    positionDragY(e.pageY - startY, false);
                                }
                            ).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
                            return false;
                        }
                    );
                    sizeVerticalScrollbar();
                }

//console.log(pane+' '+ paneWidth+' '+ paneHeight+' '+ container+' '+ contentWidth+' '+ contentHeight+' '+ percentInViewH+' '+ percentInViewV+' '+ isScrollableV+' '+ isScrollableH+' '+ verticalDrag+' '+ dragMaxY+' '+ verticalDragPosition+' '+ horizontalDrag+' '+ dragMaxX+' '+ horizontalDragPosition+' '+ verticalBar+' '+ verticalTrack+' '+ scrollbarWidth+' '+ verticalTrackHeight+' '+ verticalDragHeight+' '+ arrowUp+' '+ arrowDown+' '+ horizontalBar+' '+ horizontalTrack+' '+ horizontalTrackWidth+' '+ horizontalDragWidth+' '+ arrowLeft+' '+ arrowRight+' '+ reinitialiseInterval+' '+ originalPadding+' '+ originalPaddingTotalWidth+' '+ previousContentWidth);
            }

            function sizeVerticalScrollbar()
            {
                verticalTrack.height(verticalTrackHeight + 'px');
                verticalDragPosition = 0;
                scrollbarWidth = settings.verticalGutter + verticalTrack.outerWidth();

                // Make the pane thinner to allow for the vertical scrollbar
                pane.width(paneWidth  - originalPaddingTotalWidth);

                // Add margin to the left of the pane if scrollbars are on that side (to position
                // the scrollbar on the left or right set it's left or right property in CSS)
                try {
                    if (verticalBar.position().left === 0) {
                        pane.css('margin-left', scrollbarWidth + 'px');
                    }
                } catch (err) {
                }
            }

            function initialiseHorizontalScroll()
            {
                if (isScrollableH) {

                    container.append(
                        $('<div class="jspHorizontalBar" />').append(
                            $('<div class="jspCap jspCapLeft" />'),
                            $('<div class="jspTrack" />').append(
                                $('<div class="jspDrag" />').append(
                                    $('<div class="jspDragLeft" />'),
                                    $('<div class="jspDragRight" />')
                                )
                            ),
                            $('<div class="jspCap jspCapRight" />')
                        )
                    );

                    horizontalBar = container.find('>.jspHorizontalBar');
                    horizontalTrack = horizontalBar.find('>.jspTrack');
                    horizontalDrag = horizontalTrack.find('>.jspDrag');

                    if (settings.showArrows) {
                        arrowLeft = $('<a class="jspArrow jspArrowLeft" />').bind(
                            'mousedown.jsp', getArrowScroll(-1, 0)
                        ).bind('click.jsp', nil);
                        arrowRight = $('<a class="jspArrow jspArrowRight" />').bind(
                            'mousedown.jsp', getArrowScroll(1, 0)
                        ).bind('click.jsp', nil);
                        if (settings.arrowScrollOnHover) {
                            arrowLeft.bind('mouseover.jsp', getArrowScroll(-1, 0, arrowLeft));
                            arrowRight.bind('mouseover.jsp', getArrowScroll(1, 0, arrowRight));
                        }
                        appendArrows(horizontalTrack, settings.horizontalArrowPositions, arrowLeft, arrowRight);
                    }

                    horizontalDrag.hover(
                        function()
                        {
                            horizontalDrag.addClass('jspHover');
                        },
                        function()
                        {
                            horizontalDrag.removeClass('jspHover');
                        }
                    ).bind(
                        'mousedown.jsp',
                        function(e)
                        {
                            // Stop IE from allowing text selection
                            $('html').bind('dragstart.jsp selectstart.jsp', nil);

                            horizontalDrag.addClass('jspActive');

                            var startX = e.pageX - horizontalDrag.position().left;

                            $('html').bind(
                                'mousemove.jsp',
                                function(e)
                                {
                                    positionDragX(e.pageX - startX, false);
                                }
                            ).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
                            return false;
                        }
                    );
                    horizontalTrackWidth = container.innerWidth();
                    sizeHorizontalScrollbar();
                }
            }

            function sizeHorizontalScrollbar()
            {
                container.find('>.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow').each(
                    function()
                    {
                        horizontalTrackWidth -= $(this).outerWidth();
                    }
                );

                horizontalTrack.width(horizontalTrackWidth + 'px');
                horizontalDragPosition = 0;
            }

            function resizeScrollbars()
            {
                if (isScrollableH && isScrollableV) {
                    var horizontalTrackHeight = horizontalTrack.outerHeight(),
                        verticalTrackWidth = verticalTrack.outerWidth();
                    verticalTrackHeight -= horizontalTrackHeight;
                    $(horizontalBar).find('>.jspCap:visible,>.jspArrow').each(
                        function()
                        {
                            horizontalTrackWidth += $(this).outerWidth();
                        }
                    );
                    horizontalTrackWidth -= verticalTrackWidth;
                    paneHeight -= verticalTrackWidth;
                    paneWidth -= horizontalTrackHeight;
                    horizontalTrack.parent().append(
                        $('<div class="jspCorner" />').css('width', horizontalTrackHeight + 'px')
                    );
                    sizeVerticalScrollbar();
                    sizeHorizontalScrollbar();
                }
                // reflow content
                if (isScrollableH) {
                    pane.width((container.outerWidth() - originalPaddingTotalWidth) + 'px');
                }
                contentHeight = pane.outerHeight();
                percentInViewV = contentHeight / paneHeight;

                if (isScrollableH) {
                    horizontalDragWidth = Math.ceil(1 / percentInViewH * horizontalTrackWidth);
                    if (horizontalDragWidth > settings.horizontalDragMaxWidth) {
                        horizontalDragWidth = settings.horizontalDragMaxWidth;
                    } else if (horizontalDragWidth < settings.horizontalDragMinWidth) {
                        horizontalDragWidth = settings.horizontalDragMinWidth;
                    }
                    horizontalDrag.width(horizontalDragWidth + 'px');
                    dragMaxX = horizontalTrackWidth - horizontalDragWidth;
                    _positionDragX(horizontalDragPosition); // To update the state for the arrow buttons
                }
                if (isScrollableV) {
                    verticalDragHeight = Math.ceil(1 / percentInViewV * verticalTrackHeight);
                    if (verticalDragHeight > settings.verticalDragMaxHeight) {
                        verticalDragHeight = settings.verticalDragMaxHeight;
                    } else if (verticalDragHeight < settings.verticalDragMinHeight) {
                        verticalDragHeight = settings.verticalDragMinHeight;
                    }
                    verticalDrag.height(verticalDragHeight + 'px');
                    dragMaxY = verticalTrackHeight - verticalDragHeight;
                    _positionDragY(verticalDragPosition); // To update the state for the arrow buttons
                }
            }

            function appendArrows(ele, p, a1, a2)
            {
                var p1 = "before", p2 = "after", aTemp;

                // Sniff for mac... Is there a better way to determine whether the arrows would naturally appear
                // at the top or the bottom of the bar?
                if (p == "os") {
                    p = /Mac/.test(navigator.platform) ? "after" : "split";
                }
                if (p == p1) {
                    p2 = p;
                } else if (p == p2) {
                    p1 = p;
                    aTemp = a1;
                    a1 = a2;
                    a2 = aTemp;
                }

                ele[p1](a1)[p2](a2);
            }

            function getArrowScroll(dirX, dirY, ele)
            {
                return function()
                {
                    arrowScroll(dirX, dirY, this, ele);
                    this.blur();
                    return false;
                };
            }

            function arrowScroll(dirX, dirY, arrow, ele)
            {
                arrow = $(arrow).addClass('jspActive');

                var eve,
                    scrollTimeout,
                    isFirst = true,
                    doScroll = function()
                    {
                        if (dirX !== 0) {
                            jsp.scrollByX(dirX * settings.arrowButtonSpeed);
                        }
                        if (dirY !== 0) {
                            jsp.scrollByY(dirY * settings.arrowButtonSpeed);
                        }
                        scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.arrowRepeatFreq);
                        isFirst = false;
                    };

                doScroll();

                eve = ele ? 'mouseout.jsp' : 'mouseup.jsp';
                ele = ele || $('html');
                ele.bind(
                    eve,
                    function()
                    {
                        arrow.removeClass('jspActive');
                        scrollTimeout && clearTimeout(scrollTimeout);
                        scrollTimeout = null;
                        ele.unbind(eve);
                    }
                );
            }

            function initClickOnTrack()
            {
                removeClickOnTrack();
                if (isScrollableV) {
                    verticalTrack.bind(
                        'mousedown.jsp',
                        function(e)
                        {
                            if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
                                var clickedTrack = $(this),
                                    offset = clickedTrack.offset(),
                                    direction = e.pageY - offset.top - verticalDragPosition,
                                    scrollTimeout,
                                    isFirst = true,
                                    doScroll = function()
                                    {
                                        var offset = clickedTrack.offset(),
                                            pos = e.pageY - offset.top - verticalDragHeight / 2,
                                            contentDragY = paneHeight * settings.scrollPagePercent,
                                            dragY = dragMaxY * contentDragY / (contentHeight - paneHeight);
                                        if (direction < 0) {
                                            if (verticalDragPosition - dragY > pos) {
                                                jsp.scrollByY(-contentDragY);
                                            } else {
                                                positionDragY(pos);
                                            }
                                        } else if (direction > 0) {
                                            if (verticalDragPosition + dragY < pos) {
                                                jsp.scrollByY(contentDragY);
                                            } else {
                                                positionDragY(pos);
                                            }
                                        } else {
                                            cancelClick();
                                            return;
                                        }
                                        scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
                                        isFirst = false;
                                    },
                                    cancelClick = function()
                                    {
                                        scrollTimeout && clearTimeout(scrollTimeout);
                                        scrollTimeout = null;
                                        $(document).unbind('mouseup.jsp', cancelClick);
                                    };
                                doScroll();
                                $(document).bind('mouseup.jsp', cancelClick);
                                return false;
                            }
                        }
                    );
                }

                if (isScrollableH) {
                    horizontalTrack.bind(
                        'mousedown.jsp',
                        function(e)
                        {
                            if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
                                var clickedTrack = $(this),
                                    offset = clickedTrack.offset(),
                                    direction = e.pageX - offset.left - horizontalDragPosition,
                                    scrollTimeout,
                                    isFirst = true,
                                    doScroll = function()
                                    {
                                        var offset = clickedTrack.offset(),
                                            pos = e.pageX - offset.left - horizontalDragWidth / 2,
                                            contentDragX = paneWidth * settings.scrollPagePercent,
                                            dragX = dragMaxX * contentDragX / (contentWidth - paneWidth);
                                        if (direction < 0) {
                                            if (horizontalDragPosition - dragX > pos) {
                                                jsp.scrollByX(-contentDragX);
                                            } else {
                                                positionDragX(pos);
                                            }
                                        } else if (direction > 0) {
                                            if (horizontalDragPosition + dragX < pos) {
                                                jsp.scrollByX(contentDragX);
                                            } else {
                                                positionDragX(pos);
                                            }
                                        } else {
                                            cancelClick();
                                            return;
                                        }
                                        scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
                                        isFirst = false;
                                    },
                                    cancelClick = function()
                                    {
                                        scrollTimeout && clearTimeout(scrollTimeout);
                                        scrollTimeout = null;
                                        $(document).unbind('mouseup.jsp', cancelClick);
                                    };
                                doScroll();
                                $(document).bind('mouseup.jsp', cancelClick);
                                return false;
                            }
                        }
                    );
                }
            }

            function removeClickOnTrack()
            {
                if (horizontalTrack) {
                    horizontalTrack.unbind('mousedown.jsp');
                }
                if (verticalTrack) {
                    verticalTrack.unbind('mousedown.jsp');
                }
            }

            function cancelDrag()
            {
                $('html').unbind('dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp');

                if (verticalDrag) {
                    verticalDrag.removeClass('jspActive');
                }
                if (horizontalDrag) {
                    horizontalDrag.removeClass('jspActive');
                }
            }

            function positionDragY(destY, animate)
            {
                if (!isScrollableV) {
                    return;
                }
                if (destY < 0) {
                    destY = 0;
                } else if (destY > dragMaxY) {
                    destY = dragMaxY;
                }

                // can't just check if(animate) because false is a valid value that could be passed in...
                if (animate === undefined) {
                    animate = settings.animateScroll;
                }
                if (animate) {
                    jsp.animate(verticalDrag, 'top', destY,	_positionDragY);
                } else {
                    verticalDrag.css('top', destY);
                    _positionDragY(destY);
                }

            }

            function _positionDragY(destY)
            {
                if (destY === undefined) {
                    destY = verticalDrag.position().top;
                }

                container.scrollTop(0);
                verticalDragPosition = destY;

                var isAtTop = verticalDragPosition === 0,
                    isAtBottom = verticalDragPosition == dragMaxY,
                    percentScrolled = destY/ dragMaxY,
                    destTop = -percentScrolled * (contentHeight - paneHeight);

                if (wasAtTop != isAtTop || wasAtBottom != isAtBottom) {
                    wasAtTop = isAtTop;
                    wasAtBottom = isAtBottom;
                    elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
                }

                updateVerticalArrows(isAtTop, isAtBottom);
                pane.css('top', destTop);
                elem.trigger('jsp-scroll-y', [-destTop, isAtTop, isAtBottom]).trigger('scroll');
            }

            function positionDragX(destX, animate)
            {
                if (!isScrollableH) {
                    return;
                }
                if (destX < 0) {
                    destX = 0;
                } else if (destX > dragMaxX) {
                    destX = dragMaxX;
                }

                if (animate === undefined) {
                    animate = settings.animateScroll;
                }
                if (animate) {
                    jsp.animate(horizontalDrag, 'left', destX,	_positionDragX);
                } else {
                    horizontalDrag.css('left', destX);
                    _positionDragX(destX);
                }
            }

            function _positionDragX(destX)
            {
                if (destX === undefined) {
                    destX = horizontalDrag.position().left;
                }

                container.scrollTop(0);
                horizontalDragPosition = destX;

                var isAtLeft = horizontalDragPosition === 0,
                    isAtRight = horizontalDragPosition == dragMaxX,
                    percentScrolled = destX / dragMaxX,
                    destLeft = -percentScrolled * (contentWidth - paneWidth);

                if (wasAtLeft != isAtLeft || wasAtRight != isAtRight) {
                    wasAtLeft = isAtLeft;
                    wasAtRight = isAtRight;
                    elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
                }

                updateHorizontalArrows(isAtLeft, isAtRight);
                pane.css('left', destLeft);
                elem.trigger('jsp-scroll-x', [-destLeft, isAtLeft, isAtRight]).trigger('scroll');
            }

            function updateVerticalArrows(isAtTop, isAtBottom)
            {
                if (settings.showArrows) {
                    arrowUp[isAtTop ? 'addClass' : 'removeClass']('jspDisabled');
                    arrowDown[isAtBottom ? 'addClass' : 'removeClass']('jspDisabled');
                }
            }

            function updateHorizontalArrows(isAtLeft, isAtRight)
            {
                if (settings.showArrows) {
                    arrowLeft[isAtLeft ? 'addClass' : 'removeClass']('jspDisabled');
                    arrowRight[isAtRight ? 'addClass' : 'removeClass']('jspDisabled');
                }
            }

            function scrollToY(destY, animate)
            {
                var percentScrolled = destY / (contentHeight - paneHeight);
                positionDragY(percentScrolled * dragMaxY, animate);
            }

            function scrollToX(destX, animate)
            {
                var percentScrolled = destX / (contentWidth - paneWidth);
                positionDragX(percentScrolled * dragMaxX, animate);
            }

            function scrollToElement(ele, stickToTop, animate)
            {
                var e, eleHeight, eleWidth, eleTop = 0, eleLeft = 0, viewportTop, viewportLeft, maxVisibleEleTop, maxVisibleEleLeft, destY, destX;

                // Legal hash values aren't necessarily legal jQuery selectors so we need to catch any
                // errors from the lookup...
                try {
                    e = $(ele);
                } catch (err) {
                    return;
                }
                eleHeight = e.outerHeight();
                eleWidth= e.outerWidth();

                container.scrollTop(0);
                container.scrollLeft(0);

                // loop through parents adding the offset top of any elements that are relatively positioned between
                // the focused element and the jspPane so we can get the true distance from the top
                // of the focused element to the top of the scrollpane...
                while (!e.is('.jspPane')) {
                    eleTop += e.position().top;
                    eleLeft += e.position().left;
                    e = e.offsetParent();
                    if (/^body|html$/i.test(e[0].nodeName)) {
                        // we ended up too high in the document structure. Quit!
                        return;
                    }
                }

                viewportTop = contentPositionY();
                maxVisibleEleTop = viewportTop + paneHeight;
                if (eleTop < viewportTop || stickToTop) { // element is above viewport
                    destY = eleTop - settings.verticalGutter;
                } else if (eleTop + eleHeight > maxVisibleEleTop) { // element is below viewport
                    destY = eleTop - paneHeight + eleHeight + settings.verticalGutter;
                }
                if (destY) {
                    scrollToY(destY, animate);
                }

                viewportLeft = contentPositionX();
                maxVisibleEleLeft = viewportLeft + paneWidth;
                if (eleLeft < viewportLeft || stickToTop) { // element is to the left of viewport
                    destX = eleLeft - settings.horizontalGutter;
                } else if (eleLeft + eleWidth > maxVisibleEleLeft) { // element is to the right viewport
                    destX = eleLeft - paneWidth + eleWidth + settings.horizontalGutter;
                }
                if (destX) {
                    scrollToX(destX, animate);
                }

            }

            function contentPositionX()
            {
                return -pane.position().left;
            }

            function contentPositionY()
            {
                return -pane.position().top;
            }

            function isCloseToBottom()
            {
                var scrollableHeight = contentHeight - paneHeight;
                return (scrollableHeight > 20) && (scrollableHeight - contentPositionY() < 10);
            }

            function isCloseToRight()
            {
                var scrollableWidth = contentWidth - paneWidth;
                return (scrollableWidth > 20) && (scrollableWidth - contentPositionX() < 10);
            }

            function initMousewheel()
            {
                container.unbind(mwEvent).bind(
                    mwEvent,
                    function (event, delta, deltaX, deltaY) {
                        var dX = horizontalDragPosition, dY = verticalDragPosition;
                        jsp.scrollBy(deltaX * settings.mouseWheelSpeed, -deltaY * settings.mouseWheelSpeed, false);
                        // return true if there was no movement so rest of screen can scroll
                        return dX == horizontalDragPosition && dY == verticalDragPosition;
                    }
                );
            }

            function removeMousewheel()
            {
                container.unbind(mwEvent);
            }

            function nil()
            {
                return false;
            }

            function initFocusHandler()
            {
                pane.find(':input,a').unbind('focus.jsp').bind(
                    'focus.jsp',
                    function(e)
                    {
                        scrollToElement(e.target, false);
                    }
                );
            }

            function removeFocusHandler()
            {
                pane.find(':input,a').unbind('focus.jsp');
            }

            function initKeyboardNav()
            {
                var keyDown, elementHasScrolled, validParents = [];
                isScrollableH && validParents.push(horizontalBar[0]);
                isScrollableV && validParents.push(verticalBar[0]);

                // IE also focuses elements that don't have tabindex set.
                pane.focus(
                    function()
                    {
                        elem.focus();
                    }
                );

                elem.attr('tabindex', 0)
                    .unbind('keydown.jsp keypress.jsp')
                    .bind(
                    'keydown.jsp',
                    function(e)
                    {
                        if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)){
                            return;
                        }
                        var dX = horizontalDragPosition, dY = verticalDragPosition;
                        switch(e.keyCode) {
                            case 40: // down
                            case 38: // up
                            case 34: // page down
                            case 32: // space
                            case 33: // page up
                            case 39: // right
                            case 37: // left
                                keyDown = e.keyCode;
                                keyDownHandler();
                                break;
                            case 35: // end
                                scrollToY(contentHeight - paneHeight);
                                keyDown = null;
                                break;
                            case 36: // home
                                scrollToY(0);
                                keyDown = null;
                                break;
                        }

                        elementHasScrolled = e.keyCode == keyDown && dX != horizontalDragPosition || dY != verticalDragPosition;
                        return !elementHasScrolled;
                    }
                ).bind(
                    'keypress.jsp', // For FF/ OSX so that we can cancel the repeat key presses if the JSP scrolls...
                    function(e)
                    {
                        if (e.keyCode == keyDown) {
                            keyDownHandler();
                        }
                        return !elementHasScrolled;
                    }
                );

                if (settings.hideFocus) {
                    elem.css('outline', 'none');
                    if ('hideFocus' in container[0]){
                        elem.attr('hideFocus', true);
                    }
                } else {
                    elem.css('outline', '');
                    if ('hideFocus' in container[0]){
                        elem.attr('hideFocus', false);
                    }
                }

                function keyDownHandler()
                {
                    var dX = horizontalDragPosition, dY = verticalDragPosition;
                    switch(keyDown) {
                        case 40: // down
                            jsp.scrollByY(settings.keyboardSpeed, false);
                            break;
                        case 38: // up
                            jsp.scrollByY(-settings.keyboardSpeed, false);
                            break;
                        case 34: // page down
                        case 32: // space
                            jsp.scrollByY(paneHeight * settings.scrollPagePercent, false);
                            break;
                        case 33: // page up
                            jsp.scrollByY(-paneHeight * settings.scrollPagePercent, false);
                            break;
                        case 39: // right
                            jsp.scrollByX(settings.keyboardSpeed, false);
                            break;
                        case 37: // left
                            jsp.scrollByX(-settings.keyboardSpeed, false);
                            break;
                    }

                    elementHasScrolled = dX != horizontalDragPosition || dY != verticalDragPosition;
                    return elementHasScrolled;
                }
            }

            function removeKeyboardNav()
            {
                elem.attr('tabindex', '-1')
                    .removeAttr('tabindex')
                    .unbind('keydown.jsp keypress.jsp');
            }

            function observeHash()
            {
                if (location.hash && location.hash.length > 1) {
                    var e,
                        retryInt,
                        hash = escape(location.hash.substr(1)) // hash must be escaped to prevent XSS
                        ;
                    try {
                        e = $('#' + hash + ', a[name="' + hash + '"]');
                    } catch (err) {
                        return;
                    }

                    if (e.length && pane.find(hash)) {
                        // nasty workaround but it appears to take a little while before the hash has done its thing
                        // to the rendered page so we just wait until the container's scrollTop has been messed up.
                        if (container.scrollTop() === 0) {
                            retryInt = setInterval(
                                function()
                                {
                                    if (container.scrollTop() > 0) {
                                        scrollToElement(e, true);
                                        $(document).scrollTop(container.position().top);
                                        clearInterval(retryInt);
                                    }
                                },
                                50
                            );
                        } else {
                            scrollToElement(e, true);
                            $(document).scrollTop(container.position().top);
                        }
                    }
                }
            }

            function hijackInternalLinks()
            {
                // only register the link handler once
                if ($(document.body).data('jspHijack')) {
                    return;
                }

                // remember that the handler was bound
                $(document.body).data('jspHijack', true);

                // use live handler to also capture newly created links
                $(document.body).delegate('a[href*=#]', 'click', function(event) {
                    // does the link point to the same page?
                    // this also takes care of cases with a <base>-Tag or Links not starting with the hash #
                    // e.g. <a href="index.html#test"> when the current url already is index.html
                    var href = this.href.substr(0, this.href.indexOf('#')),
                        locationHref = location.href,
                        hash,
                        element,
                        container,
                        jsp,
                        scrollTop,
                        elementTop;
                    if (location.href.indexOf('#') !== -1) {
                        locationHref = location.href.substr(0, location.href.indexOf('#'));
                    }
                    if (href !== locationHref) {
                        // the link points to another page
                        return;
                    }

                    // check if jScrollPane should handle this click event
                    hash = escape(this.href.substr(this.href.indexOf('#') + 1));

                    // find the element on the page
                    element;
                    try {
                        element = $('#' + hash + ', a[name="' + hash + '"]');
                    } catch (e) {
                        // hash is not a valid jQuery identifier
                        return;
                    }

                    if (!element.length) {
                        // this link does not point to an element on this page
                        return;
                    }

                    container = element.closest('.jspScrollable');
                    jsp = container.data('jsp');

                    // jsp might be another jsp instance than the one, that bound this event
                    // remember: this event is only bound once for all instances.
                    jsp.scrollToElement(element, true);

                    if (container[0].scrollIntoView) {
                        // also scroll to the top of the container (if it is not visible)
                        scrollTop = $(window).scrollTop();
                        elementTop = element.offset().top;
                        if (elementTop < scrollTop || elementTop > scrollTop + $(window).height()) {
                            container[0].scrollIntoView();
                        }
                    }

                    // jsp handled this event, prevent the browser default (scrolling :P)
                    event.preventDefault();
                });
            }

            // Init touch on iPad, iPhone, iPod, Android
            function initTouch()
            {
                var startX,
                    startY,
                    touchStartX,
                    touchStartY,
                    moved,
                    moving = false;

                container.unbind('touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick').bind(
                    'touchstart.jsp',
                    function(e)
                    {
                        var touch = e.originalEvent.touches[0];
                        startX = contentPositionX();
                        startY = contentPositionY();
                        touchStartX = touch.pageX;
                        touchStartY = touch.pageY;
                        moved = false;
                        moving = true;
                    }
                ).bind(
                    'touchmove.jsp',
                    function(ev)
                    {
                        if(!moving) {
                            return;
                        }

                        var touchPos = ev.originalEvent.touches[0],
                            dX = horizontalDragPosition, dY = verticalDragPosition;

                        jsp.scrollTo(startX + touchStartX - touchPos.pageX, startY + touchStartY - touchPos.pageY);

                        moved = moved || Math.abs(touchStartX - touchPos.pageX) > 5 || Math.abs(touchStartY - touchPos.pageY) > 5;

                        // return true if there was no movement so rest of screen can scroll
                        return dX == horizontalDragPosition && dY == verticalDragPosition;
                    }
                ).bind(
                    'touchend.jsp',
                    function(e)
                    {
                        moving = false;
                        /*if(moved) {
                         return false;
                         }*/
                    }
                ).bind(
                    'click.jsp-touchclick',
                    function(e)
                    {
                        if(moved) {
                            moved = false;
                            return false;
                        }
                    }
                );
            }

            function destroy(){
                var currentY = contentPositionY(),
                    currentX = contentPositionX();
                elem.removeClass('jspScrollable').unbind('.jsp');
                elem.replaceWith(originalElement.append(pane.children()));
                originalElement.scrollTop(currentY);
                originalElement.scrollLeft(currentX);

                // clear reinitialize timer if active
                if (reinitialiseInterval) {
                    clearInterval(reinitialiseInterval);
                }
            }

            // Public API
            $.extend(
                jsp,
                {
                    // Reinitialises the scroll pane (if it's internal dimensions have changed since the last time it
                    // was initialised). The settings object which is passed in will override any settings from the
                    // previous time it was initialised - if you don't pass any settings then the ones from the previous
                    // initialisation will be used.
                    reinitialise: function(s)
                    {
                        s = $.extend({}, settings, s);
                        initialise(s);
                    },
                    // Scrolls the specified element (a jQuery object, DOM node or jQuery selector string) into view so
                    // that it can be seen within the viewport. If stickToTop is true then the element will appear at
                    // the top of the viewport, if it is false then the viewport will scroll as little as possible to
                    // show the element. You can also specify if you want animation to occur. If you don't provide this
                    // argument then the animateScroll value from the settings object is used instead.
                    scrollToElement: function(ele, stickToTop, animate)
                    {
                        scrollToElement(ele, stickToTop, animate);
                    },
                    // Scrolls the pane so that the specified co-ordinates within the content are at the top left
                    // of the viewport. animate is optional and if not passed then the value of animateScroll from
                    // the settings object this jScrollPane was initialised with is used.
                    scrollTo: function(destX, destY, animate)
                    {
                        scrollToX(destX, animate);
                        scrollToY(destY, animate);
                    },
                    // Scrolls the pane so that the specified co-ordinate within the content is at the left of the
                    // viewport. animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    scrollToX: function(destX, animate)
                    {
                        scrollToX(destX, animate);
                    },
                    // Scrolls the pane so that the specified co-ordinate within the content is at the top of the
                    // viewport. animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    scrollToY: function(destY, animate)
                    {
                        scrollToY(destY, animate);
                    },
                    // Scrolls the pane to the specified percentage of its maximum horizontal scroll position. animate
                    // is optional and if not passed then the value of animateScroll from the settings object this
                    // jScrollPane was initialised with is used.
                    scrollToPercentX: function(destPercentX, animate)
                    {
                        scrollToX(destPercentX * (contentWidth - paneWidth), animate);
                    },
                    // Scrolls the pane to the specified percentage of its maximum vertical scroll position. animate
                    // is optional and if not passed then the value of animateScroll from the settings object this
                    // jScrollPane was initialised with is used.
                    scrollToPercentY: function(destPercentY, animate)
                    {
                        scrollToY(destPercentY * (contentHeight - paneHeight), animate);
                    },
                    // Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
                    // the value of animateScroll from the settings object this jScrollPane was initialised with is used.
                    scrollBy: function(deltaX, deltaY, animate)
                    {
                        jsp.scrollByX(deltaX, animate);
                        jsp.scrollByY(deltaY, animate);
                    },
                    // Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
                    // the value of animateScroll from the settings object this jScrollPane was initialised with is used.
                    scrollByX: function(deltaX, animate)
                    {
                        var destX = contentPositionX() + Math[deltaX<0 ? 'floor' : 'ceil'](deltaX),
                            percentScrolled = destX / (contentWidth - paneWidth);
                        positionDragX(percentScrolled * dragMaxX, animate);
                    },
                    // Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
                    // the value of animateScroll from the settings object this jScrollPane was initialised with is used.
                    scrollByY: function(deltaY, animate)
                    {
                        var destY = contentPositionY() + Math[deltaY<0 ? 'floor' : 'ceil'](deltaY),
                            percentScrolled = destY / (contentHeight - paneHeight);
                        positionDragY(percentScrolled * dragMaxY, animate);
                    },
                    // Positions the horizontal drag at the specified x position (and updates the viewport to reflect
                    // this). animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    positionDragX: function(x, animate)
                    {
                        positionDragX(x, animate);
                    },
                    // Positions the vertical drag at the specified y position (and updates the viewport to reflect
                    // this). animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    positionDragY: function(y, animate)
                    {
                        positionDragY(y, animate);
                    },
                    // This method is called when jScrollPane is trying to animate to a new position. You can override
                    // it if you want to provide advanced animation functionality. It is passed the following arguments:
                    //  * ele          - the element whose position is being animated
                    //  * prop         - the property that is being animated
                    //  * value        - the value it's being animated to
                    //  * stepCallback - a function that you must execute each time you update the value of the property
                    // You can use the default implementation (below) as a starting point for your own implementation.
                    animate: function(ele, prop, value, stepCallback)
                    {
                        var params = {};
                        params[prop] = value;
                        ele.animate(
                            params,
                            {
                                'duration'	: settings.animateDuration,
                                'easing'	: settings.animateEase,
                                'queue'		: false,
                                'step'		: stepCallback
                            }
                        );
                    },
                    // Returns the current x position of the viewport with regards to the content pane.
                    getContentPositionX: function()
                    {
                        return contentPositionX();
                    },
                    // Returns the current y position of the viewport with regards to the content pane.
                    getContentPositionY: function()
                    {
                        return contentPositionY();
                    },
                    // Returns the width of the content within the scroll pane.
                    getContentWidth: function()
                    {
                        return contentWidth;
                    },
                    // Returns the height of the content within the scroll pane.
                    getContentHeight: function()
                    {
                        return contentHeight;
                    },
                    // Returns the horizontal position of the viewport within the pane content.
                    getPercentScrolledX: function()
                    {
                        return contentPositionX() / (contentWidth - paneWidth);
                    },
                    // Returns the vertical position of the viewport within the pane content.
                    getPercentScrolledY: function()
                    {
                        return contentPositionY() / (contentHeight - paneHeight);
                    },
                    // Returns whether or not this scrollpane has a horizontal scrollbar.
                    getIsScrollableH: function()
                    {
                        return isScrollableH;
                    },
                    // Returns whether or not this scrollpane has a vertical scrollbar.
                    getIsScrollableV: function()
                    {
                        return isScrollableV;
                    },
                    // Gets a reference to the content pane. It is important that you use this method if you want to
                    // edit the content of your jScrollPane as if you access the element directly then you may have some
                    // problems (as your original element has had additional elements for the scrollbars etc added into
                    // it).
                    getContentPane: function()
                    {
                        return pane;
                    },
                    // Scrolls this jScrollPane down as far as it can currently scroll. If animate isn't passed then the
                    // animateScroll value from settings is used instead.
                    scrollToBottom: function(animate)
                    {
                        positionDragY(dragMaxY, animate);
                    },
                    // Hijacks the links on the page which link to content inside the scrollpane. If you have changed
                    // the content of your page (e.g. via AJAX) and want to make sure any new anchor links to the
                    // contents of your scroll pane will work then call this function.
                    hijackInternalLinks: $.noop,
                    // Removes the jScrollPane and returns the page to the state it was in before jScrollPane was
                    // initialised.
                    destroy: function()
                    {
                        destroy();
                    }
                }
            );

            initialise(s);
        }

        // Pluginifying code...
        settings = $.extend({}, $.fn.jScrollPane.defaults, settings);

        // Apply default speed
        $.each(['mouseWheelSpeed', 'arrowButtonSpeed', 'trackClickSpeed', 'keyboardSpeed'], function() {
            settings[this] = settings[this] || settings.speed;
        });

        return this.each(
            function()
            {
                var elem = $(this), jspApi = elem.data('jsp');
                if (jspApi) {
                    jspApi.reinitialise(settings);
                } else {
                    $("script",elem).filter('[type="text/javascript"],:not([type])').remove();
                    jspApi = new JScrollPane(elem, settings);
                    elem.data('jsp', jspApi);
                }
            }
        );
    };

    $.fn.jScrollPane.defaults = {
        showArrows					: false,
        maintainPosition			: true,
        stickToBottom				: false,
        stickToRight				: false,
        clickOnTrack				: true,
        autoReinitialise			: false,
        autoReinitialiseDelay		: 500,
        verticalDragMinHeight		: 0,
        verticalDragMaxHeight		: 99999,
        horizontalDragMinWidth		: 0,
        horizontalDragMaxWidth		: 99999,
        contentWidth				: undefined,
        animateScroll				: false,
        animateDuration				: 300,
        animateEase					: 'linear',
        hijackInternalLinks			: false,
        verticalGutter				: 4,
        horizontalGutter			: 4,
        mouseWheelSpeed				: 0,
        arrowButtonSpeed			: 0,
        arrowRepeatFreq				: 50,
        arrowScrollOnHover			: false,
        trackClickSpeed				: 0,
        trackClickRepeatFreq		: 70,
        verticalArrowPositions		: 'split',
        horizontalArrowPositions	: 'split',
        enableKeyboardNavigation	: true,
        hideFocus					: false,
        keyboardSpeed				: 0,
        initialDelay                : 300,        // Delay before starting repeating
        speed						: 30,		// Default speed when others falsey
        scrollPagePercent			: .8		// Percent of visible area scrolled when pageUp/Down or track area pressed
    };

})(jQuery,this);
(function(){var d=null;function e(a){return function(b){this[a]=b}}function h(a){return function(){return this[a]}}var j;
function k(a,b,c){this.extend(k,google.maps.OverlayView);this.c=a;this.a=[];this.f=[];this.ca=[53,56,66,78,90];this.j=[];this.A=!1;c=c||{};this.g=c.gridSize||60;this.l=c.minimumClusterSize||2;this.J=c.maxZoom||d;this.j=c.styles||[];this.X=c.imagePath||this.Q;this.W=c.imageExtension||this.P;this.O=!0;if(c.zoomOnClick!=void 0)this.O=c.zoomOnClick;this.r=!1;if(c.averageCenter!=void 0)this.r=c.averageCenter;l(this);this.setMap(a);this.K=this.c.getZoom();var f=this;google.maps.event.addListener(this.c,
"zoom_changed",function(){var a=f.c.getZoom();if(f.K!=a)f.K=a,f.m()});google.maps.event.addListener(this.c,"idle",function(){f.i()});b&&b.length&&this.C(b,!1)}j=k.prototype;j.Q="http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/images/m";j.P="png";j.extend=function(a,b){return function(a){for(var b in a.prototype)this.prototype[b]=a.prototype[b];return this}.apply(a,[b])};j.onAdd=function(){if(!this.A)this.A=!0,n(this)};j.draw=function(){};
function l(a){if(!a.j.length)for(var b=0,c;c=a.ca[b];b++)a.j.push({url:a.X+(b+1)+"."+a.W,height:c,width:c})}j.S=function(){for(var a=this.o(),b=new google.maps.LatLngBounds,c=0,f;f=a[c];c++)b.extend(f.getPosition());this.c.fitBounds(b)};j.z=h("j");j.o=h("a");j.V=function(){return this.a.length};j.ba=e("J");j.I=h("J");j.G=function(a,b){for(var c=0,f=a.length,g=f;g!==0;)g=parseInt(g/10,10),c++;c=Math.min(c,b);return{text:f,index:c}};j.$=e("G");j.H=h("G");
j.C=function(a,b){for(var c=0,f;f=a[c];c++)q(this,f);b||this.i()};function q(a,b){b.s=!1;b.draggable&&google.maps.event.addListener(b,"dragend",function(){b.s=!1;a.L()});a.a.push(b)}j.q=function(a,b){q(this,a);b||this.i()};function r(a,b){var c=-1;if(a.a.indexOf)c=a.a.indexOf(b);else for(var f=0,g;g=a.a[f];f++)if(g==b){c=f;break}if(c==-1)return!1;b.setMap(d);a.a.splice(c,1);return!0}j.Y=function(a,b){var c=r(this,a);return!b&&c?(this.m(),this.i(),!0):!1};
j.Z=function(a,b){for(var c=!1,f=0,g;g=a[f];f++)g=r(this,g),c=c||g;if(!b&&c)return this.m(),this.i(),!0};j.U=function(){return this.f.length};j.getMap=h("c");j.setMap=e("c");j.w=h("g");j.aa=e("g");
j.v=function(a){var b=this.getProjection(),c=new google.maps.LatLng(a.getNorthEast().lat(),a.getNorthEast().lng()),f=new google.maps.LatLng(a.getSouthWest().lat(),a.getSouthWest().lng()),c=b.fromLatLngToDivPixel(c);c.x+=this.g;c.y-=this.g;f=b.fromLatLngToDivPixel(f);f.x-=this.g;f.y+=this.g;c=b.fromDivPixelToLatLng(c);b=b.fromDivPixelToLatLng(f);a.extend(c);a.extend(b);return a};j.R=function(){this.m(!0);this.a=[]};
j.m=function(a){for(var b=0,c;c=this.f[b];b++)c.remove();for(b=0;c=this.a[b];b++)c.s=!1,a&&c.setMap(d);this.f=[]};j.L=function(){var a=this.f.slice();this.f.length=0;this.m();this.i();window.setTimeout(function(){for(var b=0,c;c=a[b];b++)c.remove()},0)};j.i=function(){n(this)};
function n(a){if(a.A)for(var b=a.v(new google.maps.LatLngBounds(a.c.getBounds().getSouthWest(),a.c.getBounds().getNorthEast())),c=0,f;f=a.a[c];c++)if(!f.s&&b.contains(f.getPosition())){for(var g=a,u=4E4,o=d,v=0,m=void 0;m=g.f[v];v++){var i=m.getCenter();if(i){var p=f.getPosition();if(!i||!p)i=0;else var w=(p.lat()-i.lat())*Math.PI/180,x=(p.lng()-i.lng())*Math.PI/180,i=Math.sin(w/2)*Math.sin(w/2)+Math.cos(i.lat()*Math.PI/180)*Math.cos(p.lat()*Math.PI/180)*Math.sin(x/2)*Math.sin(x/2),i=6371*2*Math.atan2(Math.sqrt(i),
Math.sqrt(1-i));i<u&&(u=i,o=m)}}o&&o.F.contains(f.getPosition())?o.q(f):(m=new s(g),m.q(f),g.f.push(m))}}function s(a){this.k=a;this.c=a.getMap();this.g=a.w();this.l=a.l;this.r=a.r;this.d=d;this.a=[];this.F=d;this.n=new t(this,a.z(),a.w())}j=s.prototype;
j.q=function(a){var b;a:if(this.a.indexOf)b=this.a.indexOf(a)!=-1;else{b=0;for(var c;c=this.a[b];b++)if(c==a){b=!0;break a}b=!1}if(b)return!1;if(this.d){if(this.r)c=this.a.length+1,b=(this.d.lat()*(c-1)+a.getPosition().lat())/c,c=(this.d.lng()*(c-1)+a.getPosition().lng())/c,this.d=new google.maps.LatLng(b,c),y(this)}else this.d=a.getPosition(),y(this);a.s=!0;this.a.push(a);b=this.a.length;b<this.l&&a.getMap()!=this.c&&a.setMap(this.c);if(b==this.l)for(c=0;c<b;c++)this.a[c].setMap(d);b>=this.l&&a.setMap(d);
a=this.c.getZoom();if((b=this.k.I())&&a>b)for(a=0;b=this.a[a];a++)b.setMap(this.c);else if(this.a.length<this.l)z(this.n);else{b=this.k.H()(this.a,this.k.z().length);this.n.setCenter(this.d);a=this.n;a.B=b;a.ga=b.text;a.ea=b.index;if(a.b)a.b.innerHTML=b.text;b=Math.max(0,a.B.index-1);b=Math.min(a.j.length-1,b);b=a.j[b];a.da=b.url;a.h=b.height;a.p=b.width;a.M=b.textColor;a.e=b.anchor;a.N=b.textSize;a.D=b.backgroundPosition;this.n.show()}return!0};
j.getBounds=function(){for(var a=new google.maps.LatLngBounds(this.d,this.d),b=this.o(),c=0,f;f=b[c];c++)a.extend(f.getPosition());return a};j.remove=function(){this.n.remove();this.a.length=0;delete this.a};j.T=function(){return this.a.length};j.o=h("a");j.getCenter=h("d");function y(a){a.F=a.k.v(new google.maps.LatLngBounds(a.d,a.d))}j.getMap=h("c");
function t(a,b,c){a.k.extend(t,google.maps.OverlayView);this.j=b;this.fa=c||0;this.u=a;this.d=d;this.c=a.getMap();this.B=this.b=d;this.t=!1;this.setMap(this.c)}j=t.prototype;
j.onAdd=function(){this.b=document.createElement("DIV");if(this.t)this.b.style.cssText=A(this,B(this,this.d)),this.b.innerHTML=this.B.text;this.getPanes().overlayMouseTarget.appendChild(this.b);var a=this;google.maps.event.addDomListener(this.b,"click",function(){var b=a.u.k;google.maps.event.trigger(b,"clusterclick",a.u);b.O&&a.c.fitBounds(a.u.getBounds())})};function B(a,b){var c=a.getProjection().fromLatLngToDivPixel(b);c.x-=parseInt(a.p/2,10);c.y-=parseInt(a.h/2,10);return c}
j.draw=function(){if(this.t){var a=B(this,this.d);this.b.style.top=a.y+"px";this.b.style.left=a.x+"px"}};function z(a){if(a.b)a.b.style.display="none";a.t=!1}j.show=function(){if(this.b)this.b.style.cssText=A(this,B(this,this.d)),this.b.style.display="";this.t=!0};j.remove=function(){this.setMap(d)};j.onRemove=function(){if(this.b&&this.b.parentNode)z(this),this.b.parentNode.removeChild(this.b),this.b=d};j.setCenter=e("d");
function A(a,b){var c=[];c.push("background-image:url("+a.da+");");c.push("background-position:"+(a.D?a.D:"0 0")+";");typeof a.e==="object"?(typeof a.e[0]==="number"&&a.e[0]>0&&a.e[0]<a.h?c.push("height:"+(a.h-a.e[0])+"px; padding-top:"+a.e[0]+"px;"):c.push("height:"+a.h+"px; line-height:"+a.h+"px;"),typeof a.e[1]==="number"&&a.e[1]>0&&a.e[1]<a.p?c.push("width:"+(a.p-a.e[1])+"px; padding-left:"+a.e[1]+"px;"):c.push("width:"+a.p+"px; text-align:center;")):c.push("height:"+a.h+"px; line-height:"+a.h+
"px; width:"+a.p+"px; text-align:center;");c.push("cursor:pointer; top:"+b.y+"px; left:"+b.x+"px; color:"+(a.M?a.M:"black")+"; position:absolute; font-size:"+(a.N?a.N:11)+"px; font-family:Arial,sans-serif; font-weight:bold");return c.join("")}window.MarkerClusterer=k;k.prototype.addMarker=k.prototype.q;k.prototype.addMarkers=k.prototype.C;k.prototype.clearMarkers=k.prototype.R;k.prototype.fitMapToMarkers=k.prototype.S;k.prototype.getCalculator=k.prototype.H;k.prototype.getGridSize=k.prototype.w;
k.prototype.getExtendedBounds=k.prototype.v;k.prototype.getMap=k.prototype.getMap;k.prototype.getMarkers=k.prototype.o;k.prototype.getMaxZoom=k.prototype.I;k.prototype.getStyles=k.prototype.z;k.prototype.getTotalClusters=k.prototype.U;k.prototype.getTotalMarkers=k.prototype.V;k.prototype.redraw=k.prototype.i;k.prototype.removeMarker=k.prototype.Y;k.prototype.removeMarkers=k.prototype.Z;k.prototype.resetViewport=k.prototype.m;k.prototype.repaint=k.prototype.L;k.prototype.setCalculator=k.prototype.$;
k.prototype.setGridSize=k.prototype.aa;k.prototype.setMaxZoom=k.prototype.ba;k.prototype.onAdd=k.prototype.onAdd;k.prototype.draw=k.prototype.draw;s.prototype.getCenter=s.prototype.getCenter;s.prototype.getSize=s.prototype.T;s.prototype.getMarkers=s.prototype.o;t.prototype.onAdd=t.prototype.onAdd;t.prototype.draw=t.prototype.draw;t.prototype.onRemove=t.prototype.onRemove;
})();// Chosen, a Select Box Enhancer for jQuery and Protoype
// by Patrick Filler for Harvest, http://getharvest.com
// 
// Version 0.9.8
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// This file is generated by `cake build`, do not edit it by hand.
// Chosen, a Select Box Enhancer for jQuery and Protoype
// by Patrick Filler for Harvest, http://getharvest.com
//
// Version 0.9.8
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// This file is generated by `cake build`, do not edit it by hand.
(function() {
    var SelectParser;

    SelectParser = (function() {

        function SelectParser() {
            this.options_index = 0;
            this.parsed = [];
        }

        SelectParser.prototype.add_node = function(child) {
            if (child.nodeName.toUpperCase() === "OPTGROUP") {
                return this.add_group(child);
            } else {
                return this.add_option(child);
            }
        };

        SelectParser.prototype.add_group = function(group) {
            var group_position, option, _i, _len, _ref, _results;
            group_position = this.parsed.length;
            this.parsed.push({
                array_index: group_position,
                group: true,
                label: group.label,
                children: 0,
                disabled: group.disabled
            });
            _ref = group.childNodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                _results.push(this.add_option(option, group_position, group.disabled));
            }
            return _results;
        };

        SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
            if (option.nodeName.toUpperCase() === "OPTION") {
                if (option.text !== "") {
                    if (group_position != null) this.parsed[group_position].children += 1;
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        value: option.value,
                        text: option.text,
                        html: option.innerHTML,
                        selected: option.selected,
                        disabled: group_disabled === true ? group_disabled : option.disabled,
                        group_array_index: group_position,
                        classes: option.className,
                        style: option.style.cssText
                    });
                } else {
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        empty: true
                    });
                }
                return this.options_index += 1;
            }
        };

        return SelectParser;

    })();

    SelectParser.select_to_array = function(select) {
        var child, parser, _i, _len, _ref;
        parser = new SelectParser();
        _ref = select.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            parser.add_node(child);
        }
        return parser.parsed;
    };

    this.SelectParser = SelectParser;

}).call(this);

/*
 Chosen source: generate output using 'cake build'
 Copyright (c) 2011 by Harvest
 */

(function() {
    var AbstractChosen, root;

    root = this;

    AbstractChosen = (function() {

        function AbstractChosen(form_field, options) {
            this.form_field = form_field;
            this.options = options != null ? options : {};
            this.set_default_values();
            this.is_multiple = this.form_field.multiple;
            this.set_default_text();
            this.setup();
            this.set_up_html();
            this.register_observers();
            this.finish_setup();
        }

        AbstractChosen.prototype.set_default_values = function() {
            var _this = this;
            this.click_test_action = function(evt) {
                return _this.test_active_click(evt);
            };
            this.activate_action = function(evt) {
                return _this.activate_field(evt);
            };
            this.active_field = false;
            this.mouse_on_container = false;
            this.results_showing = false;
            this.result_highlighted = null;
            this.result_single_selected = null;
            this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
            this.disable_search_threshold = this.options.disable_search_threshold || 0;
            this.disable_search = this.options.disable_search || false;
            this.search_contains = this.options.search_contains || false;
            this.choices = 0;
            this.single_backstroke_delete = this.options.single_backstroke_delete || false;
            return this.max_selected_options = this.options.max_selected_options || Infinity;
        };

        AbstractChosen.prototype.set_default_text = function() {
            if (this.form_field.getAttribute("data-placeholder")) {
                this.default_text = this.form_field.getAttribute("data-placeholder");
            } else if (this.is_multiple) {
                this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || "Select Some Options";
            } else {
                this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || "Select an Option";
            }
            return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || "No results match";
        };

        AbstractChosen.prototype.mouse_enter = function() {
            return this.mouse_on_container = true;
        };

        AbstractChosen.prototype.mouse_leave = function() {
            return this.mouse_on_container = false;
        };

        AbstractChosen.prototype.input_focus = function(evt) {
            var _this = this;
            if (this.is_multiple) {
                if (!this.active_field) {
                    return setTimeout((function() {
                        return _this.container_mousedown();
                    }), 50);
                }
            } else {
                if (!this.active_field) return this.activate_field();
            }
        };

        AbstractChosen.prototype.input_blur = function(evt) {
            var _this = this;
            if (!this.mouse_on_container) {
                this.active_field = false;
                return setTimeout((function() {
                    return _this.blur_test();
                }), 100);
            }
        };

        AbstractChosen.prototype.result_add_option = function(option) {
            var classes, style;
            if (!option.disabled) {
                option.dom_id = this.container_id + "_o_" + option.array_index;
                classes = option.selected && this.is_multiple ? [] : ["active-result"];
                if (option.selected) classes.push("result-selected");
                if (option.group_array_index != null) classes.push("group-option");
                if (option.classes !== "") classes.push(option.classes);
                style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
                return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
            } else {
                return "";
            }
        };

        AbstractChosen.prototype.results_update_field = function() {
            if (!this.is_multiple) this.results_reset_cleanup();
            this.result_clear_highlight();
            this.result_single_selected = null;
            return this.results_build();
        };

        AbstractChosen.prototype.results_toggle = function() {
            if (this.results_showing) {
                return this.results_hide();
            } else {
                return this.results_show();
            }
        };

        AbstractChosen.prototype.results_search = function(evt) {
            if (this.results_showing) {
                return this.winnow_results();
            } else {
                return this.results_show();
            }
        };

        AbstractChosen.prototype.keyup_checker = function(evt) {
            var stroke, _ref;
            stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
            this.search_field_scale();
            switch (stroke) {
                case 8:
                    if (this.is_multiple && this.backstroke_length < 1 && this.choices > 0) {
                        return this.keydown_backstroke();
                    } else if (!this.pending_backstroke) {
                        this.result_clear_highlight();
                        return this.results_search();
                    }
                    break;
                case 13:
                    evt.preventDefault();
                    if (this.results_showing) return this.result_select(evt);
                    break;
                case 27:
                    if (this.results_showing) this.results_hide();
                    return true;
                case 9:
                case 38:
                case 40:
                case 16:
                case 91:
                case 17:
                    break;
                default:
                    return this.results_search();
            }
        };

        AbstractChosen.prototype.generate_field_id = function() {
            var new_id;
            new_id = this.generate_random_id();
            this.form_field.id = new_id;
            return new_id;
        };

        AbstractChosen.prototype.generate_random_char = function() {
            var chars, newchar, rand;
            chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            rand = Math.floor(Math.random() * chars.length);
            return newchar = chars.substring(rand, rand + 1);
        };

        return AbstractChosen;

    })();

    root.AbstractChosen = AbstractChosen;

}).call(this);

/*
 Chosen source: generate output using 'cake build'
 Copyright (c) 2011 by Harvest
 */

(function() {
    var $, Chosen, get_side_border_padding, root,
        __hasProp = Object.prototype.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

    root = this;

    $ = jQuery;

    $.fn.extend({
        chosen: function(options) {
            if ($.browser.msie && ($.browser.version === "6.0" || ($.browser.version === "7.0" && document.documentMode === 7))) {
                return this;
            }
            return this.each(function(input_field) {
                var $this;
                $this = $(this);
                if (!$this.hasClass("chzn-done")) {
                    return $this.data('chosen', new Chosen(this, options));
                }
            });
        }
    });

    Chosen = (function(_super) {

        __extends(Chosen, _super);

        function Chosen() {
            Chosen.__super__.constructor.apply(this, arguments);
        }

        Chosen.prototype.setup = function() {
            this.form_field_jq = $(this.form_field);
            this.current_value = this.form_field_jq.val();
            return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
        };

        Chosen.prototype.finish_setup = function() {
            return this.form_field_jq.addClass("chzn-done");
        };

        Chosen.prototype.set_up_html = function() {
            var container_div, dd_top, dd_width, sf_width;
            this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, '_') : this.generate_field_id();
            this.container_id += "_chzn";
            this.f_width = this.form_field_jq.outerWidth();
            container_div = $("<div />", {
                id: this.container_id,
                "class": "chzn-container" + (this.is_rtl ? ' chzn-rtl' : ''),
                style: 'width: ' + this.f_width + 'px;'
            });
            if (this.is_multiple) {
                container_div.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>');
            } else {
                container_div.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off"  /></div><ul class="chzn-results"></ul></div>');
            }
            this.form_field_jq.hide().after(container_div);
            this.container = $('#' + this.container_id);
            this.container.addClass("chzn-container-" + (this.is_multiple ? "multi" : "single"));
            this.dropdown = this.container.find('div.chzn-drop').first();
            dd_top = this.container.height();
            dd_width = this.f_width - get_side_border_padding(this.dropdown);
            //todo: move to options like forceWidth
            dd_width = 175;
            this.dropdown.css({
                "width": dd_width + "px",
                "top": dd_top + "px"
            });
            this.search_field = this.container.find('input').first();
            this.search_results = this.container.find('ul.chzn-results').first();
            this.search_field_scale();
            this.search_no_results = this.container.find('li.no-results').first();
            if (this.is_multiple) {
                this.search_choices = this.container.find('ul.chzn-choices').first();
                this.search_container = this.container.find('li.search-field').first();
            } else {
                this.search_container = this.container.find('div.chzn-search').first();
                this.selected_item = this.container.find('.chzn-single').first();
                sf_width = dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field);
                this.search_field.css({
                    "width": sf_width + "px"
                });
            }
            this.results_build();
            this.set_tab_index();
            return this.form_field_jq.trigger("liszt:ready", {
                chosen: this
            });
        };

        Chosen.prototype.register_observers = function() {
            var _this = this;
            this.container.mousedown(function(evt) {
                return _this.container_mousedown(evt);
            });
            this.container.mouseup(function(evt) {
                return _this.container_mouseup(evt);
            });
            this.container.mouseenter(function(evt) {
                return _this.mouse_enter(evt);
            });
            this.container.mouseleave(function(evt) {
                return _this.mouse_leave(evt);
            });
            this.search_results.mouseup(function(evt) {
                return _this.search_results_mouseup(evt);
            });
            this.search_results.mouseover(function(evt) {
                return _this.search_results_mouseover(evt);
            });
            this.search_results.mouseout(function(evt) {
                return _this.search_results_mouseout(evt);
            });
            this.form_field_jq.bind("liszt:updated", function(evt) {
                return _this.results_update_field(evt);
            });
            this.form_field_jq.bind("liszt:activate", function(evt) {
                return _this.activate_field(evt);
            });
            this.form_field_jq.bind("liszt:open", function(evt) {
                return _this.container_mousedown(evt);
            });
            this.search_field.blur(function(evt) {
                return _this.input_blur(evt);
            });
            this.search_field.keyup(function(evt) {
                return _this.keyup_checker(evt);
            });
            this.search_field.keydown(function(evt) {
                return _this.keydown_checker(evt);
            });
            this.search_field.focus(function(evt) {
                return _this.input_focus(evt);
            });
            if (this.is_multiple) {
                return this.search_choices.click(function(evt) {
                    return _this.choices_click(evt);
                });
            } else {
                return this.container.click(function(evt) {
                    return evt.preventDefault();
                });
            }
        };

        Chosen.prototype.search_field_disabled = function() {
            this.is_disabled = this.form_field_jq[0].disabled;
            if (this.is_disabled) {
                this.container.addClass('chzn-disabled');
                this.search_field[0].disabled = true;
                if (!this.is_multiple) {
                    this.selected_item.unbind("focus", this.activate_action);
                }
                return this.close_field();
            } else {
                this.container.removeClass('chzn-disabled');
                this.search_field[0].disabled = false;
                if (!this.is_multiple) {
                    return this.selected_item.bind("focus", this.activate_action);
                }
            }
        };

        Chosen.prototype.container_mousedown = function(evt) {
            var target_closelink;
            if (!this.is_disabled) {
                target_closelink = evt != null ? ($(evt.target)).hasClass("search-choice-close") : false;
                if (evt && evt.type === "mousedown" && !this.results_showing) {
                    evt.stopPropagation();
                }
                if (!this.pending_destroy_click && !target_closelink) {
                    if (!this.active_field) {
                        if (this.is_multiple) this.search_field.val("");
                        $(document).click(this.click_test_action);
                        this.results_show();
                    } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
                        evt.preventDefault();
                        this.results_toggle();
                    }
                    return this.activate_field();
                } else {
                    return this.pending_destroy_click = false;
                }
            }
        };

        Chosen.prototype.container_mouseup = function(evt) {
            if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
                return this.results_reset(evt);
            }
        };

        Chosen.prototype.blur_test = function(evt) {
            if (!this.active_field && this.container.hasClass("chzn-container-active")) {
                return this.close_field();
            }
        };

        Chosen.prototype.close_field = function() {
            $(document).unbind("click", this.click_test_action);
            this.active_field = false;
            this.results_hide();
            this.container.removeClass("chzn-container-active");
            this.winnow_results_clear();
            this.clear_backstroke();
            this.show_search_field_default();
            return this.search_field_scale();
        };

        Chosen.prototype.activate_field = function() {
            this.container.addClass("chzn-container-active");
            this.active_field = true;
            this.search_field.val(this.search_field.val());
            return this.search_field.focus();
        };

        Chosen.prototype.test_active_click = function(evt) {
            if ($(evt.target).parents('#' + this.container_id).length) {
                return this.active_field = true;
            } else {
                return this.close_field();
            }
        };

        Chosen.prototype.results_build = function() {
            var content, data, _i, _len, _ref;
            this.parsing = true;
            this.results_data = root.SelectParser.select_to_array(this.form_field);
            if (this.is_multiple && this.choices > 0) {
                this.search_choices.find("li.search-choice").remove();
                this.choices = 0;
            } else if (!this.is_multiple) {
                this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
                if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
                    this.container.addClass("chzn-container-single-nosearch");
                } else {
                    this.container.removeClass("chzn-container-single-nosearch");
                }
            }
            content = '';
            _ref = this.results_data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                data = _ref[_i];
                if (data.group) {
                    content += this.result_add_group(data);
                } else if (!data.empty) {
                    content += this.result_add_option(data);
                    if (data.selected && this.is_multiple) {
                        this.choice_build(data);
                    } else if (data.selected && !this.is_multiple) {
                        this.selected_item.removeClass("chzn-default").find("span").text(data.text);
                        if (this.allow_single_deselect) this.single_deselect_control_build();
                    }
                }
            }
            this.search_field_disabled();
            this.show_search_field_default();
            this.search_field_scale();
            this.search_results.html(content);
            return this.parsing = false;
        };

        Chosen.prototype.result_add_group = function(group) {
            if (!group.disabled) {
                group.dom_id = this.container_id + "_g_" + group.array_index;
                return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
            } else {
                return "";
            }
        };

        Chosen.prototype.result_do_highlight = function(el) {
            var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
            if (el.length) {
                this.result_clear_highlight();
                this.result_highlight = el;
                this.result_highlight.addClass("highlighted");
                maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
                visible_top = this.search_results.scrollTop();
                visible_bottom = maxHeight + visible_top;
                high_top = this.result_highlight.position().top + this.search_results.scrollTop();
                high_bottom = high_top + this.result_highlight.outerHeight();
                if (high_bottom >= visible_bottom) {
                    return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
                } else if (high_top < visible_top) {
                    return this.search_results.scrollTop(high_top);
                }
            }
        };

        Chosen.prototype.result_clear_highlight = function() {
            if (this.result_highlight) this.result_highlight.removeClass("highlighted");
            return this.result_highlight = null;
        };

        Chosen.prototype.results_show = function() {
            var dd_top;
            if (!this.is_multiple) {
                this.selected_item.addClass("chzn-single-with-drop");
                if (this.result_single_selected) {
                    this.result_do_highlight(this.result_single_selected);
                }
            } else if (this.max_selected_options <= this.choices) {
                this.form_field_jq.trigger("liszt:maxselected", {
                    chosen: this
                });
                return false;
            }
            dd_top = this.is_multiple ? this.container.height() : this.container.height() - 1;
            this.form_field_jq.trigger("liszt:showing_dropdown", {
                chosen: this
            });
            this.dropdown.css({
                "top": dd_top + "px",
                "left": 0
            });
            this.results_showing = true;
            this.search_field.focus();
            this.search_field.val(this.search_field.val());
            return this.winnow_results();
        };

        Chosen.prototype.results_hide = function() {
            if (!this.is_multiple) {
                this.selected_item.removeClass("chzn-single-with-drop");
            }
            this.result_clear_highlight();
            this.form_field_jq.trigger("liszt:hiding_dropdown", {
                chosen: this
            });
            this.dropdown.css({
                "left": "-9000px"
            });
            return this.results_showing = false;
        };

        Chosen.prototype.set_tab_index = function(el) {
            var ti;
            if (this.form_field_jq.attr("tabindex")) {
                ti = this.form_field_jq.attr("tabindex");
                this.form_field_jq.attr("tabindex", -1);
                return this.search_field.attr("tabindex", ti);
            }
        };

        Chosen.prototype.show_search_field_default = function() {
            if (this.is_multiple && this.choices < 1 && !this.active_field) {
                this.search_field.val(this.default_text);
                return this.search_field.addClass("default");
            } else {
                this.search_field.val("");
                return this.search_field.removeClass("default");
            }
        };

        Chosen.prototype.search_results_mouseup = function(evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target.length) {
                this.result_highlight = target;
                this.result_select(evt);
                return this.search_field.focus();
            }
        };

        Chosen.prototype.search_results_mouseover = function(evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target) return this.result_do_highlight(target);
        };

        Chosen.prototype.search_results_mouseout = function(evt) {
            if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
                return this.result_clear_highlight();
            }
        };

        Chosen.prototype.choices_click = function(evt) {
            evt.preventDefault();
            if (this.active_field && !($(evt.target).hasClass("search-choice" || $(evt.target).parents('.search-choice').first)) && !this.results_showing) {
                return this.results_show();
            }
        };

        Chosen.prototype.choice_build = function(item) {
            var choice_id, html, link,
                _this = this;
            if (this.is_multiple && this.max_selected_options <= this.choices) {
                this.form_field_jq.trigger("liszt:maxselected", {
                    chosen: this
                });
                return false;
            }
            choice_id = this.container_id + "_c_" + item.array_index;
            this.choices += 1;
            if (item.disabled) {
                html = '<li class="search-choice search-choice-disabled" id="' + choice_id + '"><span>' + item.html + '</span></li>';
            } else {
                html = '<li class="search-choice" id="' + choice_id + '"><span>' + item.html + '</span><a href="javascript:void(0)" class="search-choice-close" rel="' + item.array_index + '"></a></li>';
            }
            this.search_container.before(html);
            link = $('#' + choice_id).find("a").first();
            return link.click(function(evt) {
                return _this.choice_destroy_link_click(evt);
            });
        };

        Chosen.prototype.choice_destroy_link_click = function(evt) {
            evt.preventDefault();
            if (!this.is_disabled) {
                this.pending_destroy_click = true;
                return this.choice_destroy($(evt.target));
            } else {
                return evt.stopPropagation;
            }
        };

        Chosen.prototype.choice_destroy = function(link) {
            if (this.result_deselect(link.attr("rel"))) {
                this.choices -= 1;
                this.show_search_field_default();
                if (this.is_multiple && this.choices > 0 && this.search_field.val().length < 1) {
                    this.results_hide();
                }
                return link.parents('li').first().remove();
            }
        };

        Chosen.prototype.results_reset = function() {
            this.form_field.options[0].selected = true;
            this.selected_item.find("span").text(this.default_text);
            if (!this.is_multiple) this.selected_item.addClass("chzn-default");
            this.show_search_field_default();
            this.results_reset_cleanup();
            this.form_field_jq.trigger("change");
            if (this.active_field) return this.results_hide();
        };

        Chosen.prototype.results_reset_cleanup = function() {
            this.current_value = this.form_field_jq.val();
            return this.selected_item.find("abbr").remove();
        };

        Chosen.prototype.result_select = function(evt) {
            var high, high_id, item, position;
            if (this.result_highlight) {
                high = this.result_highlight;
                high_id = high.attr("id");
                this.result_clear_highlight();
                if (this.is_multiple) {
                    this.result_deactivate(high);
                } else {
                    this.search_results.find(".result-selected").removeClass("result-selected");
                    this.result_single_selected = high;
                    this.selected_item.removeClass("chzn-default");
                }
                high.addClass("result-selected");
                position = high_id.substr(high_id.lastIndexOf("_") + 1);
                item = this.results_data[position];
                item.selected = true;
                this.form_field.options[item.options_index].selected = true;
                if (this.is_multiple) {
                    this.choice_build(item);
                } else {
                    this.selected_item.find("span").first().text(item.text);
                    if (this.allow_single_deselect) this.single_deselect_control_build();
                }
                if (!(evt.metaKey && this.is_multiple)) this.results_hide();
                this.search_field.val("");
                if (this.is_multiple || this.form_field_jq.val() !== this.current_value) {
                    this.form_field_jq.trigger("change", {
                        'selected': this.form_field.options[item.options_index].value
                    });
                }
                this.current_value = this.form_field_jq.val();
                return this.search_field_scale();
            }
        };

        Chosen.prototype.result_activate = function(el) {
            return el.addClass("active-result");
        };

        Chosen.prototype.result_deactivate = function(el) {
            return el.removeClass("active-result");
        };

        Chosen.prototype.result_deselect = function(pos) {
            var result, result_data;
            result_data = this.results_data[pos];
            if (!this.form_field.options[result_data.options_index].disabled) {
                result_data.selected = false;
                this.form_field.options[result_data.options_index].selected = false;
                result = $("#" + this.container_id + "_o_" + pos);
                result.removeClass("result-selected").addClass("active-result").show();
                this.result_clear_highlight();
                this.winnow_results();
                this.form_field_jq.trigger("change", {
                    deselected: this.form_field.options[result_data.options_index].value
                });
                this.search_field_scale();
                return true;
            } else {
                return false;
            }
        };

        Chosen.prototype.single_deselect_control_build = function() {
            if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
                return this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
            }
        };

        Chosen.prototype.winnow_results = function() {
            var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len2, _ref;
            this.no_results_clear();
            results = 0;
            searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
            regexAnchor = this.search_contains ? "" : "^";
            regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
            zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
            _ref = this.results_data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                if (!option.disabled && !option.empty) {
                    if (option.group) {
                        $('#' + option.dom_id).css('display', 'none');
                    } else if (!(this.is_multiple && option.selected)) {
                        found = false;
                        result_id = option.dom_id;
                        result = $("#" + result_id);
                        if (regex.test(option.html)) {
                            found = true;
                            results += 1;
                        } else if (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0) {
                            parts = option.html.replace(/\[|\]/g, "").split(" ");
                            if (parts.length) {
                                for (_j = 0, _len2 = parts.length; _j < _len2; _j++) {
                                    part = parts[_j];
                                    if (regex.test(part)) {
                                        found = true;
                                        results += 1;
                                    }
                                }
                            }
                        }
                        if (found) {
                            if (searchText.length) {
                                startpos = option.html.search(zregex);
                                text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
                                text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
                            } else {
                                text = option.html;
                            }
                            result.html(text);
                            this.result_activate(result);
                            if (option.group_array_index != null) {
                                $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
                            }
                        } else {
                            if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
                                this.result_clear_highlight();
                            }
                            this.result_deactivate(result);
                        }
                    }
                }
            }
            if (results < 1 && searchText.length) {
                return this.no_results(searchText);
            } else {
                return this.winnow_results_set_highlight();
            }
        };

        Chosen.prototype.winnow_results_clear = function() {
            var li, lis, _i, _len, _results;
            this.search_field.val("");
            lis = this.search_results.find("li");
            _results = [];
            for (_i = 0, _len = lis.length; _i < _len; _i++) {
                li = lis[_i];
                li = $(li);
                if (li.hasClass("group-result")) {
                    _results.push(li.css('display', 'auto'));
                } else if (!this.is_multiple || !li.hasClass("result-selected")) {
                    _results.push(this.result_activate(li));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        Chosen.prototype.winnow_results_set_highlight = function() {
            var do_high, selected_results;
            if (!this.result_highlight) {
                selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
                do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
                if (do_high != null) return this.result_do_highlight(do_high);
            }
        };

        Chosen.prototype.no_results = function(terms) {
            var no_results_html;
            no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
            no_results_html.find("span").first().html(terms);
            return this.search_results.append(no_results_html);
        };

        Chosen.prototype.no_results_clear = function() {
            return this.search_results.find(".no-results").remove();
        };

        Chosen.prototype.keydown_arrow = function() {
            var first_active, next_sib;
            if (!this.result_highlight) {
                first_active = this.search_results.find("li.active-result").first();
                if (first_active) this.result_do_highlight($(first_active));
            } else if (this.results_showing) {
                next_sib = this.result_highlight.nextAll("li.active-result").first();
                if (next_sib) this.result_do_highlight(next_sib);
            }
            if (!this.results_showing) return this.results_show();
        };

        Chosen.prototype.keyup_arrow = function() {
            var prev_sibs;
            if (!this.results_showing && !this.is_multiple) {
                return this.results_show();
            } else if (this.result_highlight) {
                prev_sibs = this.result_highlight.prevAll("li.active-result");
                if (prev_sibs.length) {
                    return this.result_do_highlight(prev_sibs.first());
                } else {
                    if (this.choices > 0) this.results_hide();
                    return this.result_clear_highlight();
                }
            }
        };

        Chosen.prototype.keydown_backstroke = function() {
            var next_available_destroy;
            if (this.pending_backstroke) {
                this.choice_destroy(this.pending_backstroke.find("a").first());
                return this.clear_backstroke();
            } else {
                next_available_destroy = this.search_container.siblings("li.search-choice").last();
                if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
                    this.pending_backstroke = next_available_destroy;
                    if (this.single_backstroke_delete) {
                        return this.keydown_backstroke();
                    } else {
                        return this.pending_backstroke.addClass("search-choice-focus");
                    }
                }
            }
        };

        Chosen.prototype.clear_backstroke = function() {
            if (this.pending_backstroke) {
                this.pending_backstroke.removeClass("search-choice-focus");
            }
            return this.pending_backstroke = null;
        };

        Chosen.prototype.keydown_checker = function(evt) {
            var stroke, _ref;
            stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
            this.search_field_scale();
            if (stroke !== 8 && this.pending_backstroke) this.clear_backstroke();
            switch (stroke) {
                case 8:
                    this.backstroke_length = this.search_field.val().length;
                    break;
                case 9:
                    if (this.results_showing && !this.is_multiple) this.result_select(evt);
                    this.mouse_on_container = false;
                    break;
                case 13:
                    evt.preventDefault();
                    break;
                case 38:
                    evt.preventDefault();
                    this.keyup_arrow();
                    break;
                case 40:
                    this.keydown_arrow();
                    break;
            }
        };

        Chosen.prototype.search_field_scale = function() {
            var dd_top, div, h, style, style_block, styles, w, _i, _len;
            if (this.is_multiple) {
                h = 0;
                w = 0;
                style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
                styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
                for (_i = 0, _len = styles.length; _i < _len; _i++) {
                    style = styles[_i];
                    style_block += style + ":" + this.search_field.css(style) + ";";
                }
                div = $('<div />', {
                    'style': style_block
                });
                div.text(this.search_field.val());
                $('body').append(div);
                w = div.width() + 25;
                div.remove();
                if (w > this.f_width - 10) w = this.f_width - 10;
                this.search_field.css({
                    'width': w + 'px'
                });
                dd_top = this.container.height();
                return this.dropdown.css({
                    "top": dd_top + "px"
                });
            }
        };

        Chosen.prototype.generate_random_id = function() {
            var string;
            string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
            while ($("#" + string).length > 0) {
                string += this.generate_random_char();
            }
            return string;
        };

        return Chosen;

    })(AbstractChosen);

    get_side_border_padding = function(elmt) {
        var side_border_padding;
        return side_border_padding = elmt.outerWidth() - elmt.width();
    };

    root.get_side_border_padding = get_side_border_padding;

}).call(this);/*!
 * Socialite v2.0
 * http://socialitejs.com
 * Copyright (c) 2011 David Bushell
 * Dual-licensed under the BSD or MIT licenses: http://socialitejs.com/license.txt
 */
window.Socialite = (function(window, document, undefined)
{
    'use strict';

    var uid       = 0,
        instances = [ ],
        networks  = { },
        widgets   = { },
        rstate    = /^($|loaded|complete)/,
        euc       = window.encodeURIComponent;

    var socialite = {

        settings: { },

        trim: function(str)
        {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
        },

        hasClass: function(el, cn)
        {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass: function(el, cn)
        {
            if (!socialite.hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass: function(el, cn)
        {
            el.className = socialite.trim(' ' + el.className + ' '.replace(' ' + cn + ' ', ' '));
        },

        /**
         * Copy properties of one object to another
         */
        extendObject: function(to, from, overwrite)
        {
            for (var prop in from) {
                var hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object') {
                    socialite.extendObject(to[prop], from[prop], overwrite);
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
        },

        /**
         * Return elements with a specific class
         *
         * @param context - containing element to search within
         * @param cn      - class name to search for
         *
         */
        getElements: function(context, cn)
        {
            // copy to a new array to avoid a live NodeList
            var i   = 0,
                el  = [ ],
                gcn = !!context.getElementsByClassName,
                all = gcn ? context.getElementsByClassName(cn) : context.getElementsByTagName('*');
            for (; i < all.length; i++) {
                if (gcn || socialite.hasClass(all[i], cn)) {
                    el.push(all[i]);
                }
            }
            return el;
        },

        /**
         * Return data-* attributes of element as a query string (or object)
         *
         * @param el       - the element
         * @param noprefix - (optional) if true, remove "data-" from attribute names
         * @param nostr    - (optional) if true, return attributes in an object
         *
         */
        getDataAttributes: function(el, noprefix, nostr)
        {
            var i    = 0,
                str  = '',
                obj  = { },
                attr = el.attributes;
            for (; i < attr.length; i++) {
                var key = attr[i].name,
                    val = attr[i].value;
                if (val.length && key.indexOf('data-') === 0) {
                    if (noprefix) {
                        key = key.substring(5);
                    }
                    if (nostr) {
                        obj[key] = val;
                    } else {
                        str += euc(key) + '=' + euc(val) + '&';
                    }
                }
            }
            return nostr ? obj : str;
        },

        /**
         * Copy data-* attributes from one element to another
         *
         * @param from     - element to copy from
         * @param to       - element to copy to
         * @param noprefix - (optional) if true, remove "data-" from attribute names
         * @param nohyphen - (optional) if true, convert hyphens to underscores in the attribute names
         *
         */
        copyDataAttributes: function(from, to, noprefix, nohyphen)
        {
            // `nohyphen` was needed for Facebook's <fb:like> elements - remove as no longer used?
            var attr = socialite.getDataAttributes(from, noprefix, true);
            for (var i in attr) {
                to.setAttribute(nohyphen ? i.replace(/-/g, '_') : i, attr[i]);
            }
        },

        /**
         * Create iframe element
         *
         * @param src      - iframe URL (src attribute)
         * @param instance - (optional) socialite instance to activate on iframe load
         *
         */
        createIframe: function(src, instance)
        {
            // Socialite v2 has slashed the amount of manual iframe creation, we should aim to avoid this entirely
            var iframe = document.createElement('iframe');
            iframe.style.cssText = 'overflow: hidden; border: none;';
            socialite.extendObject(iframe, { src: src, allowtransparency: 'true', frameborder: '0', scrolling: 'no' }, true);
            if (instance) {
                iframe.onload = iframe.onreadystatechange = function ()
                {
                    if (rstate.test(iframe.readyState || '')) {
                        iframe.onload = iframe.onreadystatechange = null;
                        socialite.activateInstance(instance);
                    }
                };
            }
            return iframe;
        },

        /**
         * Returns true if network script has loaded
         */
        networkReady: function(name)
        {
            return networks[name] ? networks[name].loaded : undefined;
        },

        /**
         * Append network script to the document
         */
        appendNetwork: function(network)
        {
            // the activation process is getting a little confusing for some networks
            // it would appear a script load event does not mean its global object exists yet
            // therefore the first call to `activateAll` may have no effect whereas the second call does, e.g. via `window.twttr.ready`

            if (!network || network.appended) {
                return;
            }
            // `network.append` and `network.onload` can cancel progress
            if (typeof network.append === 'function' && network.append(network) === false) {
                network.appended = network.loaded = true;
                socialite.activateAll(network);
                return;
            }

            if (network.script) {
                network.el = document.createElement('script');
                socialite.extendObject(network.el, network.script, true);
                network.el.async = true;
                network.el.onload = network.el.onreadystatechange = function()
                {
                    if (rstate.test(network.el.readyState || '')) {
                        network.el.onload = network.el.onreadystatechange = null;
                        network.loaded = true;
                        if (typeof network.onload === 'function' && network.onload(network) === false) {
                            return;
                        }
                        socialite.activateAll(network);
                    }
                };
                document.body.appendChild(network.el);
            }
            network.appended = true;
        },

        /**
         * Remove network script from the document
         */
        removeNetwork: function(network)
        {
            if (!socialite.networkReady(network.name)) {
                return false;
            }
            if (network.el.parentNode) {
                network.el.parentNode.removeChild(network.el);
            }
            return !(network.appended = network.loaded = false);
        },

        /**
         * Remove and re-append network script to the document
         */
        reloadNetwork: function(name)
        {
            // This is a last-ditch effort for half-baked scripts
            var network = networks[name];
            if (network && socialite.removeNetwork(network)) {
                socialite.appendNetwork(network);
            }
        },

        /**
         * Create new Socialite instance
         *
         * @param el     - parent element that will hold the new instance
         * @param widget - widget the instance belongs to
         *
         */
        createInstance: function(el, widget)
        {
            var proceed  = true,
                instance = {
                    el      : el,
                    uid     : uid++,
                    widget  : widget
                };
            instances.push(instance);
            if (widget.process !== undefined) {
                proceed = (typeof widget.process === 'function') ? widget.process(instance) : false;
            }
            if (proceed) {
                socialite.processInstance(instance);
            }
            instance.el.setAttribute('data-socialite', instance.uid);
            instance.el.className = 'socialite ' + widget.name + ' socialite-instance';
            return instance;
        },

        /**
         * Process a socialite instance to an intermediate state prior to load
         */
        processInstance: function(instance)
        {
            var el = instance.el;
            instance.el = document.createElement('div');
            instance.el.className = el.className;
            socialite.copyDataAttributes(el, instance.el);
            // stop over-zealous scripts from activating all instances
            if (el.nodeName.toLowerCase() === 'a' && !el.getAttribute('data-default-href')) {
                instance.el.setAttribute('data-default-href', el.getAttribute('href'));
            }
            var parent = el.parentNode;
            parent.insertBefore(instance.el, el);
            parent.removeChild(el);
        },

        /**
         * Activate a socialite instance
         */
        activateInstance: function(instance)
        {
            if (instance && !instance.loaded) {
                instance.loaded = true;
                if (typeof instance.widget.activate === 'function') {
                    instance.widget.activate(instance);
                }
                socialite.addClass(instance.el, 'socialite-loaded');
                return instance.onload ? instance.onload(instance.el) : null;
            }
        },

        /**
         * Activate all socialite instances belonging to a network
         */
        activateAll: function(network)
        {
            if (typeof network === 'string') {
                network = networks[network];
            }
            for (var i = 0; i < instances.length; i++) {
                var instance = instances[i];
                if (instance.init && instance.widget.network === network) {
                    socialite.activateInstance(instance);
                }
            }
        },

        /**
         * Load socialite instances
         *
         * @param context - (optional) containing element to search within
         * @param el      - (optional) individual or an array of elements to load
         * @param w       - (optional) widget name
         * @param onload  - (optional) function to call after each socialite instance has loaded
         * @param process - (optional) process but don't load network (if true)
         *
         */
        load: function(context, el, w, onload, process)
        {
            // use document as context if unspecified
            context = (context && typeof context === 'object' && context.nodeType === 1) ? context : document;

            // if no elements search within the context and recurse
            if (!el || typeof el !== 'object') {
                socialite.load(context, socialite.getElements(context, 'socialite'), w, onload, process);
                return;
            }

            var i;

            // if array of elements load each one individually
            if (/Array/.test(Object.prototype.toString.call(el))) {
                for (i = 0; i < el.length; i++) {
                    socialite.load(context, el[i], w, onload, process);
                }
                return;
            }

            // nothing was found...
            if (el.nodeType !== 1) {
                return;
            }

            // if widget name not specified search within the element classes
            if (!w || !widgets[w]) {
                w = null;
                var classes = el.className.split(' ');
                for (i = 0; i < classes.length; i++) {
                    if (widgets[classes[i]]) {
                        w = classes[i];
                        break;
                    }
                }
                if (!w) {
                    return;
                }
            }

            // find or create the Socialite instance
            var instance,
                widget = widgets[w],
                sid    = parseInt(el.getAttribute('data-socialite'), 10);
            if (!isNaN(sid)) {
                for (i = 0; i < instances.length; i++) {
                    if (instances[i].uid === sid) {
                        instance = instances[i];
                        break;
                    }
                }
            } else {
                instance = socialite.createInstance(el, widget);
            }

            // return if just processing (or no instance found)
            if (process || !instance) {
                return;
            }

            // initialise the instance
            if (!instance.init) {
                instance.init = true;
                instance.onload = (typeof onload === 'function') ? onload : null;
                widget.init(instance);
            }

            // append the parent network (all instances will be activated onload)
            // or activate immediately if network has already loaded
            if (!widget.network.appended) {
                socialite.appendNetwork(widget.network);
            } else {
                if (socialite.networkReady(widget.network.name)) {
                    socialite.activateInstance(instance);
                }
            }
        },

        /**
         * Load a single element
         *
         * @param el     - an individual element
         * @param w      - (optional) widget for this socialite instance
         * @param onload - (optional) function to call once each instance has loaded
         *
         */
        activate: function(el, w, onload)
        {
            // skip the first few steps
            window.Socialite.load(null, el, w, onload);
        },

        /**
         * Process elements to an intermediate state prior to load
         *
         * @param context - containing element to search within
         * @param el      - (optional) individual or an array of elements to load
         * @param w       - (optional) widget name
         *
         */
        process: function(context, el, w)
        {
            // stop before widget initialises instance
            window.Socialite.load(context, el, w, null, true);
        },

        /**
         * Add a new social network
         *
         * @param name   - unique name for network
         * @param params - additional data and callbacks
         *
         */
        network: function(n, params)
        {
            networks[n] = {
                name     : n,
                el       : null,
                appended : false,
                loaded   : false,
                widgets  : { }
            };
            if (params) {
                socialite.extendObject(networks[n], params);
            }
        },

        /**
         * Add a new social widget
         *
         * @param name   - name of owner network
         * @param w      - unique name for widget
         * @param params - additional data and callbacks
         *
         */
        widget: function(n, w, params)
        {
            params.name = n + '-' + w;
            if (!networks[n] || widgets[params.name]) {
                return;
            }
            params.network = networks[n];
            networks[n].widgets[w] = widgets[params.name] = params;
        },

        /**
         * Change the default Socialite settings for each network
         */
        setup: function(params)
        {
            socialite.extendObject(socialite.settings, params, true);
        }

    };

    return socialite;

})(window, window.document);

/**
 * Socialite Extensions - Pick 'n' Mix!
 */
(function(window, document, Socialite, undefined)
{

    // default to the Queen's English
    Socialite.setup({
        facebook: {
            lang: 'en_GB',
            appId: null
        },
        twitter: {
            lang: 'en'
        },
        googleplus: {
            lang: 'en-GB'
        }
    });


    // Facebook
    // http://developers.facebook.com/docs/reference/plugins/like/
    // http://developers.facebook.com/docs/reference/javascript/FB.init/

    Socialite.network('facebook', {
        script: {
            src : '//connect.facebook.net/{{language}}/all.js',
            id  : 'facebook-jssdk'
        },
        append: function(network)
        {
            var fb       = document.createElement('div'),
                settings = Socialite.settings.facebook,
                events   = { onlike: 'edge.create', onunlike: 'edge.remove', onsend: 'message.send' };
            fb.id = 'fb-root';
            document.body.appendChild(fb);
            network.script.src = network.script.src.replace('{{language}}', settings.lang);
            window.fbAsyncInit = function() {
                window.FB.init({
                      appId: settings.appId,
                      xfbml: true
                });
                for (var e in events) {
                    if (typeof settings[e] === 'function') {
                        window.FB.Event.subscribe(events[e], settings[e]);
                    }
                }
            };
        }
    });

    Socialite.widget('facebook', 'like', {
        init: function(instance)
        {
            var el = document.createElement('div');
            el.className = 'fb-like';
            Socialite.copyDataAttributes(instance.el, el);
            instance.el.appendChild(el);
            if (window.FB && window.FB.XFBML) {
                window.FB.XFBML.parse(instance.el);
            }
        }
    });


    // Twitter
    // https://dev.twitter.com/docs/tweet-button/
    // https://dev.twitter.com/docs/intents/events/
    // https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingSocial#twitter

    Socialite.network('twitter', {
        script: {
            src     : '//platform.twitter.com/widgets.js',
            id      : 'twitter-wjs',
            charset : 'utf-8'
        },
        append: function()
        {
            var notwttr  = (typeof window.twttr !== 'object'),
                settings = Socialite.settings.twitter,
                events   = ['click', 'tweet', 'retweet', 'favorite', 'follow'];
            if (notwttr) {
                window.twttr = (t = { _e: [], ready: function(f) { t._e.push(f); } });
            }
            window.twttr.ready(function(twttr)
            {
                for (var i = 0; i < events.length; i++) {
                    var e = events[i];
                    if (typeof settings['on' + e] === 'function') {
                        twttr.events.bind(e, settings['on' + e]);
                    }
                }
                Socialite.activateAll('twitter');
            });
            return notwttr;
        }
    });

    var twitterInit = function(instance)
    {
        var el = document.createElement('a');
        el.className = instance.widget.name + '-button';
        Socialite.copyDataAttributes(instance.el, el);
        el.setAttribute('href', instance.el.getAttribute('data-default-href'));
        el.setAttribute('data-lang', instance.el.getAttribute('data-lang') || Socialite.settings.twitter.lang);
        instance.el.appendChild(el);
    };

    var twitterActivate = function(instance)
    {
        if (window.twttr && typeof window.twttr.widgets === 'object' && typeof window.twttr.widgets.load === 'function') {
            window.twttr.widgets.load();
        }
    };

    Socialite.widget('twitter', 'share',   { init: twitterInit, activate: twitterActivate });
    Socialite.widget('twitter', 'follow',  { init: twitterInit, activate: twitterActivate });
    Socialite.widget('twitter', 'hashtag', { init: twitterInit, activate: twitterActivate });
    Socialite.widget('twitter', 'mention', { init: twitterInit, activate: twitterActivate });

    Socialite.widget('twitter', 'embed', {
        process: function(instance)
        {
            instance.innerEl = instance.el;
            if (!instance.innerEl.getAttribute('data-lang')) {
                instance.innerEl.setAttribute('data-lang', Socialite.settings.twitter.lang);
            }
            instance.el = document.createElement('div');
            instance.el.className = instance.innerEl.className;
            instance.innerEl.className = '';
            instance.innerEl.parentNode.insertBefore(instance.el, instance.innerEl);
            instance.el.appendChild(instance.innerEl);
        },
        init: function(instance)
        {
            instance.innerEl.className = 'twitter-tweet';
        },
        activate: twitterActivate
    });


    // Google+
    // https://developers.google.com/+/plugins/+1button/
    // Google does not support IE7

    Socialite.network('googleplus', {
        script: {
            src: '//apis.google.com/js/plusone.js'
        },
        append: function(network)
        {
            if (window.gapi) {
                return false;
            }
            window.___gcfg = {
                lang: Socialite.settings.googleplus.lang,
                parsetags: 'explicit'
            };
        }
    });

    var googleplusInit = function(instance)
    {
        var el = document.createElement('div');
        el.className = 'g-' + instance.widget.gtype;
        Socialite.copyDataAttributes(instance.el, el);
        instance.el.appendChild(el);
        instance.gplusEl = el;
    };

    var googleplusEvent = function(instance, callback) {
        return (typeof callback !== 'function') ? null : function(data) {
            callback(instance.el, data);
        };
    };

    var googleplusActivate = function(instance)
    {
        var type = instance.widget.gtype;
        if (window.gapi && window.gapi[type]) {
            var settings = Socialite.settings.googleplus,
                params   = Socialite.getDataAttributes(instance.el, true, true),
                events   = ['onstartinteraction', 'onendinteraction', 'callback'];
            for (var i = 0; i < events.length; i++) {
                params[events[i]] = googleplusEvent(instance, settings[events[i]]);
            }
            window.gapi[type].render(instance.gplusEl, params);
        }
    };

    Socialite.widget('googleplus', 'one',   { init: googleplusInit, activate: googleplusActivate, gtype: 'plusone' });
    Socialite.widget('googleplus', 'share', { init: googleplusInit, activate: googleplusActivate, gtype: 'plus' });
    Socialite.widget('googleplus', 'badge', { init: googleplusInit, activate: googleplusActivate, gtype: 'plus' });


    // LinkedIn
    // http://developer.linkedin.com/plugins/share-button/

    Socialite.network('linkedin', {
        script: {
            src: '//platform.linkedin.com/in.js'
        }
    });

    var linkedinInit = function(instance)
    {
        var el = document.createElement('script');
        el.type = 'IN/' + instance.widget.intype;
        Socialite.copyDataAttributes(instance.el, el);
        instance.el.appendChild(el);
        if (typeof window.IN === 'object' && typeof window.IN.parse === 'function') {
            window.IN.parse(instance.el);
            Socialite.activateInstance(instance);
        }
    };

    Socialite.widget('linkedin', 'share',     { init: linkedinInit, intype: 'Share' });
    Socialite.widget('linkedin', 'recommend', { init: linkedinInit, intype: 'RecommendProduct' });

})(window, window.document, window.Socialite);

/**
 * Execute any queued functions (don't enqueue before the document has loaded!)
 */
(function() {
    var s = window._socialite;
    if (/Array/.test(Object.prototype.toString.call(s))) {
        for (var i = 0, len = s.length; i < len; i++) {
            if (typeof s[i] === 'function') {
                s[i]();
            }
        }
    }
})();
/*!
 * Socialite v2.0 - Vkontakte extension
 * http://socialitejs.com
 * Dual-licensed under the BSD or MIT licenses: http://socialitejs.com/license.txt
 */
(function(window, document, Socialite, undefined)
{
    // http://vk.com/developers.php?oid=-1&p=Share
    // http://vk.com/developers.php?oid=-1&p=Like
    // http://vk.com/developers.php?oid=-1&p=Groups

    var VKCallbacks = [];

    Socialite.setup({
        vkontakte: {
            apiId: null,
            group: {
              id: 0,
              mode: 0,
              width: 300,
              height: 290
            },
            like: {
              type: 'mini'
            }
        }
    });

    Socialite.network('vkontakte', {
        script: {
            src : '//userapi.com/js/api/openapi.js?49',
            id  : 'vk-jsapi'
        },
        onload: function(network) {
           var settings = Socialite.settings.vkontakte;
           VK.init({apiId: settings.apiId, onlyWidgets: true});
           for (var i = 0, i$l = VKCallbacks.length; i < i$l; VKCallbacks[i].call(this), i++);
        }
    });

    var extendConfWithAttributes = function(el, attributes, original) {
        var result = {}, key;
        for (var k = 0, k$l = attributes.length; k < k$l; key = attributes[k], result[key] = el.getAttribute('data-' + key) || original[key], k++);
        return result;
    }

    Socialite.widget('vkontakte', 'group', {
        init: function(instance)
        {
            if (typeof window.VK !== 'object') VKCallbacks.push(function(){
                var el       = document.createElement('div'),
                    settings = Socialite.settings.vkontakte;
                el.className = 'vk-group';
                // Vkontakte needs explicit element id
                el.id = 'vkontakte-group-' + (new Date()).getTime();
                Socialite.copyDataAttributes(instance.el, el);
                group = extendConfWithAttributes(instance.el, ['id', 'mode', 'width', 'height'], settings.group);
                instance.el.appendChild(el);
                VK.Widgets.Group(el.id, group, group['id']);
            });
        }
    });

    Socialite.widget('vkontakte', 'like', {
        init: function(instance)
        {
            if (typeof window.VK !== 'object') VKCallbacks.push(function(){
                var el       = document.createElement('div'),
                    settings = Socialite.settings.vkontakte;
                el.className = 'vk-like';
                // Vkontakte needs explicit element id
                el.id = 'vkontakte-like-' + (new Date()).getTime() + Math.random().toString().replace('.', '-');
                Socialite.copyDataAttributes(instance.el, el);
                like = extendConfWithAttributes(instance.el, ['type'], settings.like);
                instance.el.appendChild(el);
                VK.Widgets.Like(el.id, like);
            });
        }
    });

})(window, window.document, window.Socialite);
/* *******************************************
 // Copyright 2010-2012, Anthony Hand
 //
 // File version date: April 23, 2012
 //    Update:
 //    - Updated DetectAmazonSilk(): Fixed an issue in the detection logic.
 //
 // File version date: April 22, 2012 - Second update
 //    Update: To address additional Kindle issues...
 //    - Updated DetectRichCSS(): Excluded e-Ink Kindle devices.
 //    - Created DetectAmazonSilk(): Created to detect Kindle Fire devices in Silk mode.
 //    - Updated DetectMobileQuick(): Updated to include e-Ink Kindle devices and the Kindle Fire in Silk mode.
 //
 // File version date: April 11, 2012
 //    Update:
 //    - Added a new variable for the new BlackBerry Curve Touch (9380): deviceBBCurveTouch.
 //    - Updated DetectBlackBerryTouch() to support the new BlackBerry Curve Touch (9380).
 //
 // File version date: January 21, 2012
 //    Update:
 //    - Moved Windows Phone 7 to the iPhone Tier. WP7.5's IE 9-based browser is good enough now.
 //    - Added a new variable for 2 versions of the new BlackBerry Bold Touch (9900 and 9930): deviceBBBoldTouch.
 //    - Updated DetectBlackBerryTouch() to support the 2 versions of the new BlackBerry Bold Touch (9900 and 9930).
 //    - Updated DetectKindle() to focus on eInk devices only. The Kindle Fire should be detected as a regular Android device.
 //
 // File version date: August 22, 2011
 //    Update:
 //    - Updated DetectAndroidTablet() to fix a bug introduced in the last fix! The true/false returns were mixed up.
 //
 // File version date: August 16, 2011
 //    Update:
 //    - Updated DetectAndroidTablet() to exclude Opera Mini, which was falsely reporting as running on a tablet device when on a phone.
 //    - Updated the user agent (uagent) init technique to handle spiders and such with null values.
 //
 //
 // LICENSE INFORMATION
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //        http://www.apache.org/licenses/LICENSE-2.0
 // Unless required by applicable law or agreed to in writing,
 // software distributed under the License is distributed on an
 // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 // either express or implied. See the License for the specific
 // language governing permissions and limitations under the License.
 //
 //
 // ABOUT THIS PROJECT
 //   Project Owner: Anthony Hand
 //   Email: anthony.hand@gmail.com
 //   Web Site: http://www.mobileesp.com
 //   Source Files: http://code.google.com/p/mobileesp/
 //
 //   Versions of this code are available for:
 //      PHP, JavaScript, Java, ASP.NET (C#), and Ruby
 //
 //
 // WARNING:
 //   These JavaScript-based device detection features may ONLY work
 //   for the newest generation of smartphones, such as the iPhone,
 //   Android and Palm WebOS devices.
 //   These device detection features may NOT work for older smartphones
 //   which had poor support for JavaScript, including
 //   older BlackBerry, PalmOS, and Windows Mobile devices.
 //   Additionally, because JavaScript support is extremely poor among
 //   'feature phones', these features may not work at all on such devices.
 //   For better results, consider using a server-based version of this code,
 //   such as Java, APS.NET, PHP, or Ruby.
 //
 // *******************************************
 */

//Optional: Store values for quickly accessing same info multiple times.
//Note: These values are not set automatically.
//Stores whether the device is an iPhone or iPod Touch.
var isIphone = false;
//Stores whether the device is an Android phone or multi-media player.
var isAndroidPhone = false;
//Stores whether is the Tablet (HTML5-capable, larger screen) tier of devices.
var isTierTablet = false;
//Stores whether is the iPhone tier of devices.
var isTierIphone = false;
//Stores whether the device can probably support Rich CSS, but JavaScript support is not assumed. (e.g., newer BlackBerry, Windows Mobile)
var isTierRichCss = false;
//Stores whether it is another mobile device, which cannot be assumed to support CSS or JS (eg, older BlackBerry, RAZR)
var isTierGenericMobile = false;

//Initialize some initial string variables we'll look for later.
var engineWebKit = "webkit";
var deviceIphone = "iphone";
var deviceIpod = "ipod";
var deviceIpad = "ipad";
var deviceMacPpc = "macintosh"; //Used for disambiguation

var deviceAndroid = "android";
var deviceGoogleTV = "googletv";
var deviceXoom = "xoom"; //Motorola Xoom
var deviceHtcFlyer = "htc_flyer"; //HTC Flyer

var deviceNuvifone = "nuvifone"; //Garmin Nuvifone

var deviceSymbian = "symbian";
var deviceS60 = "series60";
var deviceS70 = "series70";
var deviceS80 = "series80";
var deviceS90 = "series90";

var deviceWinPhone7 = "windows phone os 7";
var deviceWinMob = "windows ce";
var deviceWindows = "windows";
var deviceIeMob = "iemobile";
var devicePpc = "ppc"; //Stands for PocketPC
var enginePie = "wm5 pie";  //An old Windows Mobile

var deviceBB = "blackberry";
var vndRIM = "vnd.rim"; //Detectable when BB devices emulate IE or Firefox
var deviceBBStorm = "blackberry95"; //Storm 1 and 2
var deviceBBBold = "blackberry97"; //Bold 97x0 (non-touch)
var deviceBBBoldTouch = "blackberry 99"; //Bold 99x0 (touchscreen)
var deviceBBTour = "blackberry96"; //Tour
var deviceBBCurve = "blackberry89"; //Curve 2
var deviceBBCurveTouch = "blackberry 938"; //Curve Touch 9380
var deviceBBTorch = "blackberry 98"; //Torch
var deviceBBPlaybook = "playbook"; //PlayBook tablet

var devicePalm = "palm";
var deviceWebOS = "webos"; //For Palm's line of WebOS devices
var deviceWebOShp = "hpwos"; //For HP's line of WebOS devices

var engineBlazer = "blazer"; //Old Palm browser
var engineXiino = "xiino";

var deviceKindle = "kindle"; //Amazon Kindle, eInk one
var engineSilk = "silk"; //Amazon's accelerated Silk browser for Kindle Fire

//Initialize variables for mobile-specific content.
var vndwap = "vnd.wap";
var wml = "wml";

//Initialize variables for random devices and mobile browsers.
//Some of these may not support JavaScript
var deviceTablet = "tablet"; //Generic term for slate and tablet devices
var deviceBrew = "brew";
var deviceDanger = "danger";
var deviceHiptop = "hiptop";
var devicePlaystation = "playstation";
var deviceNintendoDs = "nitro";
var deviceNintendo = "nintendo";
var deviceWii = "wii";
var deviceXbox = "xbox";
var deviceArchos = "archos";

var engineOpera = "opera"; //Popular browser
var engineNetfront = "netfront"; //Common embedded OS browser
var engineUpBrowser = "up.browser"; //common on some phones
var engineOpenWeb = "openweb"; //Transcoding by OpenWave server
var deviceMidp = "midp"; //a mobile Java technology
var uplink = "up.link";
var engineTelecaQ = 'teleca q'; //a modern feature phone browser

var devicePda = "pda";
var mini = "mini";  //Some mobile browsers put 'mini' in their names.
var mobile = "mobile"; //Some mobile browsers put 'mobile' in their user agent strings.
var mobi = "mobi"; //Some mobile browsers put 'mobi' in their user agent strings.

//Use Maemo, Tablet, and Linux to test for Nokia's Internet Tablets.
var maemo = "maemo";
var linux = "linux";
var qtembedded = "qt embedded"; //for Sony Mylo and others
var mylocom2 = "com2"; //for Sony Mylo also

//In some UserAgents, the only clue is the manufacturer.
var manuSonyEricsson = "sonyericsson";
var manuericsson = "ericsson";
var manuSamsung1 = "sec-sgh";
var manuSony = "sony";
var manuHtc = "htc"; //Popular Android and WinMo manufacturer

//In some UserAgents, the only clue is the operator.
var svcDocomo = "docomo";
var svcKddi = "kddi";
var svcVodafone = "vodafone";

//Disambiguation strings.
var disUpdate = "update"; //pda vs. update



//Initialize our user agent string.
var uagent = "";
if (navigator && navigator.userAgent)
    uagent = navigator.userAgent.toLowerCase();


//**************************
// Detects if the current device is an iPhone.
function DetectIphone()
{
    if (uagent.search(deviceIphone) > -1)
    {
        //The iPad and iPod Touch say they're an iPhone! So let's disambiguate.
        if (DetectIpad() || DetectIpod())
            return false;
        //Yay! It's an iPhone!
        else
            return true;
    }
    else
        return false;
}

//**************************
// Detects if the current device is an iPod Touch.
function DetectIpod()
{
    if (uagent.search(deviceIpod) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is an iPad tablet.
function DetectIpad()
{
    if (uagent.search(deviceIpad) > -1  && DetectWebkit())
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is an iPhone or iPod Touch.
function DetectIphoneOrIpod()
{
    //We repeat the searches here because some iPods
    //  may report themselves as an iPhone, which is ok.
    if (uagent.search(deviceIphone) > -1 ||
        uagent.search(deviceIpod) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects *any* iOS device: iPhone, iPod Touch, iPad.
function DetectIos()
{
    if (DetectIphoneOrIpod() || DetectIpad())
        return true;
    else
        return false;
}

//**************************
// Detects *any* Android OS-based device: phone, tablet, and multi-media player.
// Also detects Google TV.
function DetectAndroid()
{
    if ((uagent.search(deviceAndroid) > -1) || DetectGoogleTV())
        return true;
    //Special check for the HTC Flyer 7" tablet. It should report here.
    if (uagent.search(deviceHtcFlyer) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is a (small-ish) Android OS-based device
// used for calling and/or multi-media (like a Samsung Galaxy Player).
// Google says these devices will have 'Android' AND 'mobile' in user agent.
// Ignores tablets (Honeycomb and later).
function DetectAndroidPhone()
{
    if (DetectAndroid() && (uagent.search(mobile) > -1))
        return true;
    //Special check for Android phones with Opera Mobile. They should report here.
    if (DetectOperaAndroidPhone())
        return true;
    //Special check for the HTC Flyer 7" tablet. It should report here.
    if (uagent.search(deviceHtcFlyer) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is a (self-reported) Android tablet.
// Google says these devices will have 'Android' and NOT 'mobile' in their user agent.
function DetectAndroidTablet()
{
    //First, let's make sure we're on an Android device.
    if (!DetectAndroid())
        return false;

    //Special check for Opera Android Phones. They should NOT report here.
    if (DetectOperaMobile())
        return false;
    //Special check for the HTC Flyer 7" tablet. It should NOT report here.
    if (uagent.search(deviceHtcFlyer) > -1)
        return false;

    //Otherwise, if it's Android and does NOT have 'mobile' in it, Google says it's a tablet.
    if (uagent.search(mobile) > -1)
        return false;
    else
        return true;
}


//**************************
// Detects if the current device is an Android OS-based device and
//   the browser is based on WebKit.
function DetectAndroidWebKit()
{
    if (DetectAndroid() && DetectWebkit())
        return true;
    else
        return false;
}


//**************************
// Detects if the current device is a GoogleTV.
function DetectGoogleTV()
{
    if (uagent.search(deviceGoogleTV) > -1)
        return true;
    else
        return false;
}


//**************************
// Detects if the current browser is based on WebKit.
function DetectWebkit()
{
    if (uagent.search(engineWebKit) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is the Nokia S60 Open Source Browser.
function DetectS60OssBrowser()
{
    if (DetectWebkit())
    {
        if ((uagent.search(deviceS60) > -1 ||
            uagent.search(deviceSymbian) > -1))
            return true;
        else
            return false;
    }
    else
        return false;
}

//**************************
// Detects if the current device is any Symbian OS-based device,
//   including older S60, Series 70, Series 80, Series 90, and UIQ, 
//   or other browsers running on these devices.
function DetectSymbianOS()
{
    if (uagent.search(deviceSymbian) > -1 ||
        uagent.search(deviceS60) > -1 ||
        uagent.search(deviceS70) > -1 ||
        uagent.search(deviceS80) > -1 ||
        uagent.search(deviceS90) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a 
// Windows Phone 7 device.
function DetectWindowsPhone7()
{
    if (uagent.search(deviceWinPhone7) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a Windows Mobile device.
// Excludes Windows Phone 7 devices. 
// Focuses on Windows Mobile 6.xx and earlier.
function DetectWindowsMobile()
{
    //Exclude new Windows Phone 7.
    if (DetectWindowsPhone7())
        return false;
    //Most devices use 'Windows CE', but some report 'iemobile'
    //  and some older ones report as 'PIE' for Pocket IE.
    if (uagent.search(deviceWinMob) > -1 ||
        uagent.search(deviceIeMob) > -1 ||
        uagent.search(enginePie) > -1)
        return true;
    //Test for Windows Mobile PPC but not old Macintosh PowerPC.
    if ((uagent.search(devicePpc) > -1) &&
        !(uagent.search(deviceMacPpc) > -1))
        return true;
    //Test for Windwos Mobile-based HTC devices.
    if (uagent.search(manuHtc) > -1 &&
        uagent.search(deviceWindows) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a BlackBerry of some sort.
// Includes the PlayBook.
function DetectBlackBerry()
{
    if (uagent.search(deviceBB) > -1)
        return true;
    if (uagent.search(vndRIM) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is on a BlackBerry tablet device.
//    Example: PlayBook
function DetectBlackBerryTablet()
{
    if (uagent.search(deviceBBPlaybook) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a BlackBerry device AND uses a
//    WebKit-based browser. These are signatures for the new BlackBerry OS 6.
//    Examples: Torch. Includes the Playbook.
function DetectBlackBerryWebKit()
{
    if (DetectBlackBerry() &&
        uagent.search(engineWebKit) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a BlackBerry Touch
//    device, such as the Storm, Torch, and Bold Touch. Excludes the Playbook.
function DetectBlackBerryTouch()
{
    if (DetectBlackBerry() &&
        ((uagent.search(deviceBBStorm) > -1) ||
            (uagent.search(deviceBBTorch) > -1) ||
            (uagent.search(deviceBBBoldTouch) > -1) ||
            (uagent.search(deviceBBCurveTouch) > -1) ))
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a BlackBerry OS 5 device AND
//    has a more capable recent browser. Excludes the Playbook.
//    Examples, Storm, Bold, Tour, Curve2
//    Excludes the new BlackBerry OS 6 and 7 browser!!
function DetectBlackBerryHigh()
{
    //Disambiguate for BlackBerry OS 6 or 7 (WebKit) browser
    if (DetectBlackBerryWebKit())
        return false;
    if (DetectBlackBerry())
    {
        if (DetectBlackBerryTouch() ||
            uagent.search(deviceBBBold) > -1 ||
            uagent.search(deviceBBTour) > -1 ||
            uagent.search(deviceBBCurve) > -1)
            return true;
        else
            return false;
    }
    else
        return false;
}

//**************************
// Detects if the current browser is a BlackBerry device AND
//    has an older, less capable browser. 
//    Examples: Pearl, 8800, Curve1.
function DetectBlackBerryLow()
{
    if (DetectBlackBerry())
    {
        //Assume that if it's not in the High tier or has WebKit, then it's Low.
        if (DetectBlackBerryHigh() || DetectBlackBerryWebKit())
            return false;
        else
            return true;
    }
    else
        return false;
}


//**************************
// Detects if the current browser is on a PalmOS device.
function DetectPalmOS()
{
    //Most devices nowadays report as 'Palm',
    //  but some older ones reported as Blazer or Xiino.
    if (uagent.search(devicePalm) > -1 ||
        uagent.search(engineBlazer) > -1 ||
        uagent.search(engineXiino) > -1)
    {
        //Make sure it's not WebOS first
        if (DetectPalmWebOS())
            return false;
        else
            return true;
    }
    else
        return false;
}

//**************************
// Detects if the current browser is on a Palm device
//   running the new WebOS.
function DetectPalmWebOS()
{
    if (uagent.search(deviceWebOS) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is on an HP tablet running WebOS.
function DetectWebOSTablet()
{
    if (uagent.search(deviceWebOShp) > -1 &&
        uagent.search(deviceTablet) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a
//   Garmin Nuvifone.
function DetectGarminNuvifone()
{
    if (uagent.search(deviceNuvifone) > -1)
        return true;
    else
        return false;
}


//**************************
// Check to see whether the device is a 'smartphone'.
//   You might wish to send smartphones to a more capable web page
//   than a dumbed down WAP page. 
function DetectSmartphone()
{
    if (DetectIphoneOrIpod()
        || DetectAndroidPhone()
        || DetectS60OssBrowser()
        || DetectSymbianOS()
        || DetectWindowsMobile()
        || DetectWindowsPhone7()
        || DetectBlackBerry()
        || DetectPalmWebOS()
        || DetectPalmOS()
        || DetectGarminNuvifone())
        return true;

    //Otherwise, return false.
    return false;
};

//**************************
// Detects if the current device is an Archos media player/Internet tablet.
function DetectArchos()
{
    if (uagent.search(deviceArchos) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects whether the device is a Brew-powered device.
function DetectBrewDevice()
{
    if (uagent.search(deviceBrew) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects the Danger Hiptop device.
function DetectDangerHiptop()
{
    if (uagent.search(deviceDanger) > -1 ||
        uagent.search(deviceHiptop) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is on one of 
// the Maemo-based Nokia Internet Tablets.
function DetectMaemoTablet()
{
    if (uagent.search(maemo) > -1)
        return true;
    //For Nokia N810, must be Linux + Tablet, or else it could be something else.
    if ((uagent.search(linux) > -1)
        && (uagent.search(deviceTablet) > -1)
        && !DetectWebOSTablet()
        && !DetectAndroid())
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is a Sony Mylo device.
function DetectSonyMylo()
{
    if (uagent.search(manuSony) > -1)
    {
        if (uagent.search(qtembedded) > -1 ||
            uagent.search(mylocom2) > -1)
            return true;
        else
            return false;
    }
    else
        return false;
}

//**************************
// Detects if the current browser is Opera Mobile or Mini.
function DetectOperaMobile()
{
    if (uagent.search(engineOpera) > -1)
    {
        if (uagent.search(mini) > -1 ||
            uagent.search(mobi) > -1)
            return true;
        else
            return false;
    }
    else
        return false;
}

//**************************
// Detects if the current browser is Opera Mobile 
// running on an Android phone.
function DetectOperaAndroidPhone()
{
    if ((uagent.search(engineOpera) > -1) &&
        (uagent.search(deviceAndroid) > -1) &&
        (uagent.search(mobi) > -1))
        return true;
    else
        return false;
}

//**************************
// Detects if the current browser is Opera Mobile 
// running on an Android tablet.
function DetectOperaAndroidTablet()
{
    if ((uagent.search(engineOpera) > -1) &&
        (uagent.search(deviceAndroid) > -1) &&
        (uagent.search(deviceTablet) > -1))
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is a Sony Playstation.
function DetectSonyPlaystation()
{
    if (uagent.search(devicePlaystation) > -1)
        return true;
    else
        return false;
};

//**************************
// Detects if the current device is a Nintendo game device.
function DetectNintendo()
{
    if (uagent.search(deviceNintendo) > -1   ||
          uagent.search(deviceWii) > -1 ||
  uagent.search(deviceNintendoDs) > -1)
    return true;
else
    return false;
};

//**************************
// Detects if the current device is a Microsoft Xbox.
function DetectXbox()
{
    if (uagent.search(deviceXbox) > -1)
        return true;
    else
        return false;
};

//**************************
// Detects if the current device is an Internet-capable game console.
function DetectGameConsole()
{
    if (DetectSonyPlaystation())
        return true;
    if (DetectNintendo())
        return true;
    if (DetectXbox())
        return true;
    else
        return false;
};

//**************************
// Detects if the current device is an Amazon Kindle (eInk devices only).
// Note: For the Kindle Fire, use the normal Android methods.
function DetectKindle()
{
    if (uagent.search(deviceKindle) > -1 &&
        !DetectAndroid())
        return true;
    else
        return false;
}

//**************************
// Detects if the current Amazon device is using the Silk Browser.
// Note: Typically used by the the Kindle Fire.
function DetectAmazonSilk()
{
    if (uagent.search(engineSilk) > -1)
        return true;
    else
        return false;
}

//**************************
// Detects if the current device is a mobile device.
//  This method catches most of the popular modern devices.
//  Excludes Apple iPads and other modern tablets.
function DetectMobileQuick()
{
    //Let's exclude tablets.
    if (DetectTierTablet())
        return false;

    //Most mobile browsing is done on smartphones
    if (DetectSmartphone())
        return true;

    if (uagent.search(deviceMidp) > -1 ||
          DetectBrewDevice())
    return true;

    if (DetectOperaMobile())
        return true;

    if (uagent.search(engineNetfront) > -1)
        return true;
    if (uagent.search(engineUpBrowser) > -1)
        return true;
    if (uagent.search(engineOpenWeb) > -1)
        return true;

    if (DetectDangerHiptop())
        return true;

    if (DetectMaemoTablet())
        return true;
    if (DetectArchos())
        return true;

    if ((uagent.search(devicePda) > -1) &&
        !(uagent.search(disUpdate) > -1))
        return true;
    if (uagent.search(mobile) > -1)
        return true;

    if (DetectKindle() ||
        DetectAmazonSilk())
        return true;

    return false;
};


//**************************
// Detects in a more comprehensive way if the current device is a mobile device.
function DetectMobileLong()
{
    if (DetectMobileQuick())
        return true;
    if (DetectGameConsole())
        return true;
    if (DetectSonyMylo())
        return true;

    //Detect for certain very old devices with stupid useragent strings.
    if (uagent.search(manuSamsung1) > -1 ||
          uagent.search(manuSonyEricsson) > -1 ||
  uagent.search(manuericsson) > -1)
    return true;

    if (uagent.search(svcDocomo) > -1)
        return true;
    if (uagent.search(svcKddi) > -1)
        return true;
    if (uagent.search(svcVodafone) > -1)
        return true;


    return false;
};


//*****************************
// For Mobile Web Site Design
//*****************************

//**************************
// The quick way to detect for a tier of devices.
//   This method detects for the new generation of
//   HTML 5 capable, larger screen tablets.
//   Includes iPad, Android (e.g., Xoom), BB Playbook, WebOS, etc.
function DetectTierTablet()
{
    if (DetectIpad()
        || DetectAndroidTablet()
        || DetectBlackBerryTablet()
        || DetectWebOSTablet())
        return true;
    else
        return false;
};

//**************************
// The quick way to detect for a tier of devices.
//   This method detects for devices which can 
//   display iPhone-optimized web content.
//   Includes iPhone, iPod Touch, Android, Windows Phone 7, WebOS, etc.
function DetectTierIphone()
{
    if (DetectIphoneOrIpod())
        return true;
    if (DetectAndroidPhone())
        return true;
    if (DetectBlackBerryWebKit() && DetectBlackBerryTouch())
        return true;
    if (DetectWindowsPhone7())
        return true;
    if (DetectPalmWebOS())
        return true;
    if (DetectGarminNuvifone())
        return true;
    else
        return false;
};

//**************************
// The quick way to detect for a tier of devices.
//   This method detects for devices which are likely to be 
//   capable of viewing CSS content optimized for the iPhone, 
//   but may not necessarily support JavaScript.
//   Excludes all iPhone Tier devices.
function DetectTierRichCss()
{
    if (DetectMobileQuick())
    {
        //Exclude iPhone Tier and e-Ink Kindle devices
        if (DetectTierIphone() || DetectKindle())
            return false;

        //The following devices are explicitly ok.
        if (DetectWebkit())
            return true;
        if (DetectS60OssBrowser())
            return true;

        //Note: 'High' BlackBerry devices ONLY
        if (DetectBlackBerryHigh())
            return true;

        //Older Windows 'Mobile' isn't good enough for iPhone Tier.
        if (DetectWindowsMobile())
            return true;

        if (uagent.search(engineTelecaQ) > -1)
            return true;

        else
            return false;
    }
    else
        return false;
};

//**************************
// The quick way to detect for a tier of devices.
//   This method detects for all other types of phones,
//   but excludes the iPhone and RichCSS Tier devices.
// NOTE: This method probably won't work due to poor
//  support for JavaScript among other devices. 
function DetectTierOtherPhones()
{
    if (DetectMobileLong())
    {
        //Exclude devices in the other 2 categories
        if (DetectTierIphone() || DetectTierRichCss())
            return false;

        //Otherwise, it's a YES
        else
            return true;
    }
    else
        return false;
};


//**************************
// Initialize Key Stored Values.
function InitDeviceScan()
{
    //We'll use these 4 variables to speed other processing. They're super common.
    isIphone = DetectIphoneOrIpod();
    isAndroidPhone = DetectAndroidPhone();
    isTierIphone = DetectTierIphone();
    isTierTablet = DetectTierTablet();

    //Optional: Comment these out if you don't need them.
    isTierRichCss = DetectTierRichCss();
    isTierGenericMobile = DetectTierOtherPhones();
};

//Now, run the initialization method.
InitDeviceScan()
/**
 * Created with JetBrains PhpStorm.
 * User: oleg
 * Date: 25.07.12
 * Time: 13:40
 * To change this template use File | Settings | File Templates.
 */

Date.fromIso = function (dateIsoString) {
    if (typeof dateIsoString == 'string') {
        var initArray = dateIsoString.split('-');
        return new Date(initArray[0], (initArray[1] - 1), initArray[2]);
    }
    else {
        return dateIsoString;
    }
}
MouseDraggable = {
    options: {
        animate: false,
        slider: false
    },

    _create: function () {
        var self = this,
            o = this.options;
        //console.log(this);
        this._mouseInit();

    },
    //_init: function(){
    //	this._mouseInit(); //    
    //},
    destroy: function () {
        this._mouseDestroy();
    },
    _mouseStart: function (e) {
        this.options.startEvent(e, this.element);
    },
    _mouseDrag: function (e) {
        this.options.dragEvent(e, this.element);
    },
    _mouseStop: function (event) {
        this.options.endEvent(event, this.element);
        return false;

    }
};
$.widget("ui.MouseDraggable", $.ui.mouse, MouseDraggable);

VoyangaCalendarSlider = function (options) {
    var defaults = {
        monthArray: new Array(),
        jObj: null,
        totalLines: 1,
        knobWidth: 1,
        knobPos: 0,
        linesWidth: 5,
        width: 0,//recalc on window resize
        knobSlideAction: false,
        animateScrollAction: false,
        onresize: function () {
            this.width = this.jObj.find('.monthLineVoyanga').width();
        },
        startEvent: function (e, obj) {
            if (this.knobSlideAction) {
                obj.data('xStart', e.pageX);
                obj.data('posStart', this.knobPos);
                if (this.width < 100) {
                    this.onresize();
                }
            }
        },
        endEvent: function (e, obj) {
            if (this.knobSlideAction) {
                this.knobSlideAction = false;
            }
        },
        dragEvent: function (e, obj) {
            if (this.knobSlideAction) {
                var xDelta = e.pageX - obj.data('xStart');
                var posDelta = Math.round((xDelta / this.width) * 10000) / 100;
                this.knobPos = obj.data('posStart') + posDelta;
                if (this.knobPos < 0) this.knobPos = 0;
                if (this.knobPos > (100 - this.knobWidth)) this.knobPos = (100 - this.knobWidth);
                this.jObj.find('.knobVoyanga').css('left', this.knobPos + '%');
                this.jObj.find('.knobUpAllMonth').css('left', this.getKnobUpLeft());
                var scrollHeight = this.jObj.find('.calendarGridVoyanga').prop('scrollHeight');
                var scrollTop = Math.round(scrollHeight * (this.knobPos / 100));
                this.jObj.find('.calendarGridVoyanga').scrollTop(scrollTop);
                this.knobMove();
            }
        },
        mouseDown: function (e) {
            var xLeft = Math.round(this.jObj.find('.knobVoyanga').offset().left);
            var xRight = xLeft + Math.round(this.jObj.find('.knobVoyanga').width());
            if ((e.pageX >= xLeft) && (e.pageX <= xRight)) {
                this.knobSlideAction = true;
                if (this.animateScrollAction) {
                    this.jObj.find('.knobVoyanga').stop(true);
                    this.animateScrollAction = false;
                }
            }
        },
        mouseUp: function (e) {
            this.knobSlideAction = false;
        },
        mousewheelEvent: function (e) {
            //console.log(e);
            var rolled = 0;
            var event = e.originalEvent;
            if ('wheelDelta' in event) {
                rolled = event.wheelDelta;
            }
            else {  // Firefox
                // The measurement units of the detail and wheelDelta properties are different.
                rolled = -40 * event.detail;
            }
            var direction = (rolled > 0) ? 1 : -1;
            if (Math.abs(rolled) > 60) {
                rolled = 60 * direction;
            }

            //var scrollHeight = TimelineCalendar.jObj.find('.calendarGrid').prop('scrollHeight');
            //console.log(this.jObj.find('.calendarGridVoyanga').scrollTop());

            var scrollTop = this.jObj.find('.calendarGridVoyanga').scrollTop() - rolled;
            this.jObj.find('.calendarGridVoyanga').scrollTop(scrollTop);
            return false;
        },
        animateStep: function (now, fx) {
            var data = fx.elem.id + ' ' + fx.prop + ': ' + now;
            if (fx.unit == 'px') {
                var posLeft = Math.round((now / this.width) * 10000) / 100;
            } else {
                var posLeft = now;
            }
            this.knobPos = posLeft;
            this.jObj.find('.knobUpAllMonth').css('left', this.getKnobUpLeft());
            var scrollHeight = this.jObj.find('.calendarGridVoyanga').prop('scrollHeight');
            var scrollTop = Math.round(scrollHeight * (this.knobPos / 100));
            this.jObj.find('.calendarGridVoyanga').scrollTop(scrollTop);
            this.knobMove();
        },
        getKnobUpLeft: function () {
            return this.knobPos + '%'
        },
        getPercent: function (pos) {
            if (pos.indexOf('px') != -1) {
                if (this.width < 100) {
                    this.onresize();
                }
                pos = pos.substr(0, pos.length - 2);
                pos = Math.round((pos / this.width) * 10000) / 100;
            } else if (pos.indexOf('%') != -1) {
                pos = pos.substr(0, pos.length - 1);
                pos = Math.round((pos) * 100) / 100;
            }
            return pos;
        },
        knobMove: function () {
            //var xLeft = Math.round(this.jObj.find('.knobVoyanga').offset().left);
            //var xRight = xLeft + Math.round(this.jObj.find('.knobVoyanga').width());
            var pWidth = this.knobWidth;
            //console.log(pWidth);
            var pLeft = this.knobPos;
            //console.log(pLeft);
            var pRight = pLeft + pWidth;
            var self = this;
            this.jObj.find('.monthNameVoyanga').each(function () {
                var pMonthLeft = self.getPercent($(this).css('left'));
                var pMonthWidth = self.getPercent($(this).css('width'));
                if (( (pRight - pMonthLeft) > (pMonthWidth * 0.6) ) && ( (pMonthLeft + pMonthWidth - pLeft) > (pMonthWidth * 0.6) )) {
                    $(this).addClass('highlited');
                    //console.log((pRight - pMonthLeft));

                } else {
                    $(this).removeClass('highlited');
                }
            });
        },
        monthMouseUp: function (obj, e) {
            if (!this.knobSlideAction) {
                this.animateScrollAction = true;
                this.jObj.find('.knobVoyanga').stop(true);
                var newPos = $(obj).parent().css('left');
                newPos = this.getPercent(newPos) + '%';
                //var newPos = $(this).css('left');
                var self = this;
                if (this.width < 100) {
                    this.onresize();
                }
                this.jObj.find('.knobVoyanga').animate({
                        left: [newPos, 'easeOutCubic']
                    },
                    {
                        duration: 800,
                        step: function (now, fx) {
                            self.animateStep(now, fx);
                        },
                        easing: 'easeOutCubic',
                        complete: function () {
                            self.animateScrollAction = false;
                        }
                    });
            }
        },
        scrollEvent: function (e) {
            if (!this.animateScrollAction) {
                var scrollHeight = this.jObj.find('.calendarGridVoyanga').prop('scrollHeight');
                this.knobPos = Math.round((this.jObj.find('.calendarGridVoyanga').scrollTop() / scrollHeight) * 1000) / 10;
                this.jObj.find('.knobVoyanga').css('left', this.knobPos + '%');
                this.jObj.find('.knobUpAllMonth').css('left', this.getKnobUpLeft());
                this.knobMove();
            }
        },

        init: function () {
        }
    };
    options = $.extend({}, defaults, options);
    for (key in options) {
        this[key] = options[key];
    }
}
VoyangaCalendarClass = function (options) {
    var defaults = {
        jObj: null,
        weekDays: new Array('', '', '', '', '', '', ''),
        monthNames: new Array('', '', '', '', '', '', '', '', '', '', '', ''),
        dayCellWidth: 180,
        getDay: function (dateObj) {
            var dayNum = dateObj.getDay();
            if (dayNum == 0) {
                dayNum = 6;
            }
            else {
                dayNum = dayNum - 1;
            }
            return dayNum;
        }
    };
    options = $.extend({}, defaults, options);
    for (key in options) {
        this[key] = options[key];
    }
}
/**/
VoyangaCalendarStandart = new VoyangaCalendarClass({values: new Array()});
VoyangaCalendarStandart.initialized = false;

VoyangaCalendarStandart.slider = new VoyangaCalendarSlider({
    init: function () {
        //console.log(this.monthArray);
        var self = this;
        for (var i in this.monthArray) {
            var leftPercent = this.monthArray[i].line / (this.totalLines - this.linesWidth);
            leftPercent = Math.round((1 - (this.linesWidth / this.totalLines) ) * leftPercent * 1000) / 10;
            if (i < (this.monthArray.length - 1)) {
                var k = parseInt(i) + 1;

                var widthPercent = (this.monthArray[k].line - this.monthArray[i].line) / this.totalLines;
                //var widthPercent = 4/(VoyangaCalendar.slider.totalLines);
            } else {
                var widthPercent = (this.totalLines - this.monthArray[i].line) / this.totalLines;
            }
            widthPercent = Math.round(widthPercent * 1000) / 10;

            var newHtml = '<div class="monthNameVoyanga" style="left: ' + leftPercent + '%; width: ' + widthPercent + '%"><div class="monthWrapper">' + this.monthArray[i].name + '</div></div>';
            this.jObj.find('.monthLineVoyanga').append(newHtml);
        }
        this.knobWidth = Math.round((this.linesWidth / this.totalLines) * 10000) / 100;
        this.jObj.find('.knobVoyanga').css('width', this.knobWidth + '%');
        this.jObj.find('.knobUpAllMonth').css('width', this.knobWidth + '%');
        //VoyangaCalendar.slider.width = VoyangaCalendar.jObj.find('.monthLineVoyanga').width();
        $(window).on('resize', function () {
            self.onresize();
        });
        $(window).load(function () {
            self.onresize();
            self.knobMove();
        });

        this.jObj.find('.calendarGridVoyanga').on('scroll', function (e) {
            self.scrollEvent(e);
            return false
        });
        //console.log('set wheel actions');
        this.jObj.find('.calendarGridVoyanga').on('mousewheel', function (e) {
            self.mousewheelEvent(e);
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
        });
        this.jObj.find('.calendarGridVoyanga').on('DOMMouseScroll', function (e) {
            self.mousewheelEvent(e);
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
        });
        //console.log(this);
        this.jObj.find('.monthLineVoyanga').mousedown(function (e) {
            self.mouseDown(e);
        });
        this.jObj.find('.monthLineVoyanga').mouseup(function (e) {
            self.mouseUp(e);
        });
        //VoyangaCalendar.jObj.find('.monthLineVoyanga .monthNameVoyanga').mouseup(VoyangaCalendar.slider.monthMouseUp);
        this.jObj.find('.monthLineVoyanga .monthNameVoyanga .monthWrapper').mouseup(function (e) {
            var obj = this;
            self.monthMouseUp(obj, e);
        });
        this.jObj.find('.monthLineVoyanga').MouseDraggable({
            startEvent: function (e, obj) {
                self.startEvent(e, obj);
            },
            endEvent: function (e, obj) {
                self.endEvent(e, obj);
            },
            dragEvent: function (e, obj) {
                self.dragEvent(e, obj);
            }
        });
        if (this.minimalLine) {
            var scrollTop = (this.minimalLine / this.totalLines) * this.jObj.find('.calendarGridVoyanga').prop('scrollHeight');
            this.jObj.find('.calendarGridVoyanga').scrollTop(scrollTop);
        }
    }
});

VoyangaCalendarStandart.onCellOver = function (obj, e) {
    var jCell = $(obj);
    if (!jCell.hasClass('inactive')) {
        var cellDate = Date.fromIso(jCell.data('cell-date'));
        if (this.values.length == 1) {
            if (cellDate < this.values[0]) {
                jCell.addClass('from');
            } else {
                if (this.twoSelect) {
                    jCell.addClass('to');
                } else {
                    jCell.addClass('from');
                }
            }

        } else {
            jCell.addClass('from');
        }
        if (cellDate.getDate() == 1) {
            jCell.addClass('startMonth');
        }
    }
}
VoyangaCalendarStandart.onCellOut = function (obj, e) {
    var jCell = $(obj);
    if (!jCell.hasClass('inactive')) {
        var cellDate = Date.fromIso(jCell.data('cell-date'));
        if (this.values.length == 1) {
            if (cellDate < this.values[0]) {
                jCell.removeClass('from');
            } else {
                if (this.twoSelect) {
                    jCell.removeClass('to');
                } else {
                    jCell.removeClass('from');
                }
            }

        } else {
            jCell.removeClass('from');
        }
        if (cellDate.getDate() == 1) {
            jCell.removeClass('startMonth');
        }
        if (this.values.length > 0) {
            if (this.values[0].valueOf() == cellDate.valueOf()) {
                jCell.addClass('selectData from');
                if (cellDate.getDate() == 1) {
                    jCell.addClass('startMonth');
                }
            }
        }
        if (this.values.length > 1) {
            if (this.values[1].valueOf() == cellDate.valueOf()) {
                jCell.addClass('selectData to');
                if (cellDate.getDate() == 1) {
                    jCell.addClass('startMonth');
                }
            }
        }
    }
}
VoyangaCalendarStandart.getCellByDate = function (oDate) {
    if (oDate) {
        var dateLabel = oDate.getFullYear() + '-' + (oDate.getMonth() + 1) + '-' + oDate.getDate();
        return $('#dayCell-' + dateLabel);
    } else {
        console.log('bad date value:', oDate);
        return false;
    }

}

VoyangaCalendarStandart.update = function (dontset) {
    // FIXME SUPER SLOW
    $('.dayCellVoyanga').removeClass('selectData from to selectDay');

    if (this.values.length) {
        var jCell = this.getCellByDate(this.values[0]);
        jCell.addClass('selectData from');

        if (this.values.length > 1) {
            jCell = this.getCellByDate(this.values[1]);
            jCell.addClass('selectData to');
            var tmpDate = new Date(this.values[0].toDateString());
            tmpDate.setDate(tmpDate.getDate() + 1);
            while (tmpDate < this.values[1]) {
                this.getCellByDate(tmpDate).addClass('selectDay');
                tmpDate.setDate(tmpDate.getDate() + 1);
            }
        }
        if (!dontset)
            this.panel().setDate(this.values);
    }
}

VoyangaCalendarStandart.onCellClick = function (obj) {
    var jCell = $(obj);
    if (jCell.hasClass('inactive'))
        return;
    var cellDate = Date.fromIso(jCell.data('cell-date'));
    var dontset = true;

    if (this.twoSelect) {
        if (this.values.length == 2) {
            this.values = new Array();
        } else if (this.values.length == 1) {
            if (cellDate < this.values[0]) {
                this.values = new Array();
            } else {
                dontset = false;
                this.values.push(cellDate);
            }
        }
    } else {
        if (this.values.length != 0) {
            this.values = new Array();
        } else {
            dontset = false;
        }
    }

    if (this.values.length == 0) {
        this.values.push(cellDate);
        dontset = false;
    }
    VoyangaCalendarStandart.update(dontset);
}

VoyangaCalendarStandart.generateGrid = function () {
    var firstDay = new Date();
    var dayToday = new Date();
    dayToday.setMinutes(0, 0, 0);
    dayToday.setHours(0);
    var self = this;
    var startMonth = firstDay.getMonth();
    var tmpDate = moment(moment(firstDay))._d;//clone Date object
    tmpDate.setDate(1);
    tmpDate.setDate(tmpDate.getDate() - this.getDay(tmpDate));//set Monday
    var weekDay = this.getDay(tmpDate);
    var startDate = firstDay.getDate();
    var startYear = firstDay.getFullYear();
    var needStop = false;
    var lineNumber = 0;
    this.slider.monthArray = new Array();
    while (!needStop) {
        var newHtml = '<div class="calendarLineVoyanga" id="weekNum-' + lineNumber + '" data-weeknum="' + lineNumber + '">';
        for (var i = 0; i < 7; i++) {
            var label = '<div class="dayLabel' + ((i >= 5 && i < 7) ? ' weekEnd' : '') + '">' + tmpDate.getDate() + '</div>';

            if (tmpDate.getDate() == 1) {
                label = label + ' <div class="monthLabel">' + this.monthNames[tmpDate.getMonth()] + '</div>';
                var monthObject = new Object();
                monthObject.line = lineNumber;
                monthObject.name = this.monthNames[tmpDate.getMonth()];
                this.slider.monthArray.push(monthObject);
            }
            var dateLabel = tmpDate.getFullYear() + '-' + (tmpDate.getMonth() + 1) + '-' + tmpDate.getDate();
            var dateLabelApi = tmpDate.getDate() + '.' + (tmpDate.getMonth() + 1) + '.' + tmpDate.getFullYear();
            newHtml = newHtml + '<div class="dayCellVoyanga' + ((tmpDate < dayToday) ? ' inactive' : '') + '" id="dayCell-' + dateLabel + '" data-cell-date="' + dateLabel + '" data-cell-date-api="' + dateLabelApi + '"><div class="innerDayCellVoyanga">' + label + '</div></div>';
            tmpDate.setDate(tmpDate.getDate() + 1);
        }
        newHtml = newHtml + '</div>';
        this.jObj.find('.calendarDIVVoyanga').append(newHtml);
        if (tmpDate.getFullYear() > startYear) {
            if (tmpDate.getMonth() >= startMonth) {
                needStop = true;
            }
        }
        lineNumber++;
    }
    var lastLineMonth = this.slider.monthArray[this.slider.monthArray.length - 1].line;
    if ((lineNumber - lastLineMonth) < 2) {
        this.slider.monthArray.pop();
    }
    this.jObj.find('.dayCellVoyanga').hover(function (e) {
        var obj = this;
        self.onCellOver(obj, e);
    }, function (e) {
        var obj = this;
        self.onCellOut(obj, e);
    });
    this.jObj.find('.dayCellVoyanga').click(function (e) {
        var obj = this;
        self.onCellClick(obj, e);
    });


    this.slider.totalLines = lineNumber;
}

VoyangaCalendarStandart.clear = function () {
    VoyangaCalendarStandart.values = [];
    VoyangaCalendarStandart.update(true);
}

VoyangaCalendarStandart.minimalDateUpdated = function () {
    var dateLabel = this.minimalDate.getFullYear() + '-' + (this.minimalDate.getMonth() + 1) + '-' + this.minimalDate.getDate();
    this.slider.minimalLine = $('#dayCell-' + dateLabel).parent().data('weeknum');

    dayCell = this.jObj.find('#weekNum-0 .dayCellVoyanga:eq(0)');
    if (dayCell.length) {
        var dd = Date.fromIso(dayCell.data('cell-date'));
        var stop = false;
        var lineNumber = 0;
        while (!stop) {
            for (var i = 0; i < 7; i++) {
                dateLabel = dd.getFullYear() + '-' + (dd.getMonth() + 1) + '-' + dd.getDate();
                if (dd < this.minimalDate) {
                    $('#dayCell-' + dateLabel).addClass('inactive');
                } else {
                    if ($('#dayCell-' + dateLabel).hasClass('inactive')) {
                        $('#dayCell-' + dateLabel).removeClass('inactive');
                    } else {
                        stop = true;
                        break;
                    }
                }
                dd.setDate(dd.getDate() + 1);
            }
        }
    }
}

VoyangaCalendarStandart.scrollToDate = function (dateVar) {
    var dateLabel = dateVar.getFullYear() + '-' + (dateVar.getMonth() + 1) + '-' + dateVar.getDate();
    var scrollLine = $('#dayCell-' + dateLabel).parent().data('weeknum');
    var scrollTop = (scrollLine / this.slider.totalLines) * this.jObj.find('.calendarGridVoyanga').prop('scrollHeight');
    this.jObj.find('.calendarGridVoyanga').scrollTop(scrollTop);
}

VoyangaCalendarStandart.newValueHandler = function (newCalendarValue) {
    if (newCalendarValue.hotels)
        $('#voyanga-calendar').addClass('hotel');
    else
        $('#voyanga-calendar').removeClass('hotel');
    if (newCalendarValue.values !== undefined && newCalendarValue.values.length == 0) {
        newCalendarValue.values.push(new Date());
        VoyangaCalendarStandart.values = new Array();
        VoyangaCalendarStandart.values.push(new Date())
        newCalendarValue.from = new Date();
    }
    VoyangaCalendarStandart.twoSelect = newCalendarValue.twoSelect;
    if (!newCalendarValue.twoSelect && VoyangaCalendarStandart.values.length > 1)
        VoyangaCalendarStandart.values = VoyangaCalendarStandart.values.slice(0, 1);
    VoyangaCalendarStandart.minimalDateChanged = false;
    var needScroll = false;
    if (newCalendarValue.activeSearchPanel) {
        if (newCalendarValue.activeSearchPanel.prevSearchPanel()) {
            minDt = newCalendarValue.activeSearchPanel.prevSearchPanel().checkOut();
            if ((!VoyangaCalendarStandart.minimalDate && minDt) || (minDt && VoyangaCalendarStandart.minimalDate.toString() != minDt.toString())) {
                VoyangaCalendarStandart.minimalDate = minDt;
                needScroll = true;
                VoyangaCalendarStandart.scrollDate = VoyangaCalendarStandart.minimalDate;
                VoyangaCalendarStandart.minimalDateChanged = true;
            }
        } else {
            minDt = new Date();
            minDt.setHours(0);
            minDt.setMinutes(0);
            minDt.setSeconds(0);
            minDt.setMilliseconds(0);
            if ((!VoyangaCalendarStandart.minimalDate) || (VoyangaCalendarStandart.minimalDate && VoyangaCalendarStandart.minimalDate.toString() != minDt.toString())) {
                VoyangaCalendarStandart.minimalDate = minDt;
                needScroll = true;
                VoyangaCalendarStandart.scrollDate = VoyangaCalendarStandart.minimalDate;
                VoyangaCalendarStandart.minimalDateChanged = true;
            }
        }
        if (VoyangaCalendarStandart.alreadyInited && VoyangaCalendarStandart.minimalDateChanged) {
            VoyangaCalendarStandart.minimalDateUpdated();
        } else if (VoyangaCalendarStandart.alreadyInited) {
            console.log('not inited', VoyangaCalendarStandart.minimalDateChanged);
        }
    } else {
        console.log('else????')
    }
    if ((newCalendarValue.from && !VoyangaCalendarStandart.scrollDate) || (newCalendarValue.from && newCalendarValue.from.toString() != VoyangaCalendarStandart.scrollDate.toString())) {
        needScroll = true;
        VoyangaCalendarStandart.scrollDate = newCalendarValue.from;
    }
    if (needScroll) {
        VoyangaCalendarStandart.scrollToDate(VoyangaCalendarStandart.scrollDate);
    }
    VoyangaCalendarStandart.values = new Array();
    if (newCalendarValue.from)
        VoyangaCalendarStandart.values.push(newCalendarValue.from);
    if ((newCalendarValue.twoSelect) && (newCalendarValue.to))
        VoyangaCalendarStandart.values.push(newCalendarValue.to);
    VoyangaCalendarStandart.update(true);
}

VoyangaCalendarStandart.compareCalendarValue = function (oldValue, newValue) {
    if ((!oldValue && newValue) || (!newValue && oldValue)) {
        return false;
    }
    for (var propName in newValue) {
        if (propName == 'from') {
            if ((oldValue[propName] != newValue[propName]) && (newValue[propName] != VoyangaCalendarStandart.values[0])) {
                return false;
            }
        } else if (propName == 'to') {
            if ((oldValue[propName] != newValue[propName]) && (newValue[propName] != VoyangaCalendarStandart.values[1])) {
                return false;
            }
        } else if (oldValue[propName] != newValue[propName]) {
            return false;
        }
    }
    return true;
}

VoyangaCalendarStandart.init = function (panel, element) {
    this.jObj = $(element);
    VoyangaCalendarStandart.slider.jObj = this.jObj;
    this.alreadyInited = false;
    this.minimalDateChanged = false;
    var self = this;
    this.oldCalendarValue = null;
    if (!this.panel || (this.panel && panel() != this.panel() )) {
        this.panel = panel;
        panel.subscribe(function (newPanel) {
            if (newPanel.template) {
                if (VoyangaCalendarStandart.subscription)
                    VoyangaCalendarStandart.subscription.dispose();
                VoyangaCalendarStandart.subscription = newPanel.calendarValue.subscribe(
                    function (calendarValue) {
                        if (!VoyangaCalendarStandart.compareCalendarValue(self.oldCalendarValue, calendarValue)) {
                            VoyangaCalendarStandart.clear();
                            self.oldCalendarValue = calendarValue;
                            VoyangaCalendarStandart.newValueHandler(calendarValue);
                        }
                    }
                );
                self.oldCalendarValue = newPanel.calendarValue();
                VoyangaCalendarStandart.newValueHandler(newPanel.calendarValue());
            }

        });
        newPanel = panel();

        if (newPanel.template) {
            if (VoyangaCalendarStandart.subscription)
                VoyangaCalendarStandart.subscription.dispose();
            VoyangaCalendarStandart.subscription = newPanel.calendarValue.subscribe(VoyangaCalendarStandart.newValueHandler);
            self.oldCalendarValue = newPanel.calendarValue();
            VoyangaCalendarStandart.newValueHandler(newPanel.calendarValue());
        }
    } else {
//        console.log('Else',panel,this.panel,this.panel(),panel());
    }

    VoyangaCalendarStandart.generateGrid();
    VoyangaCalendarStandart.slider.init();
    if (this.minimalDateChanged) {
        this.minimalDateUpdated();
    }
    this.alreadyInited = true;
}.bind(VoyangaCalendarStandart);
// Generated by CoffeeScript 1.4.0


/**
 * Created with JetBrains PhpStorm.
 * User: oleg
 * Date: 14.09.12
 * Time: 14:40
 * To change this template use File | Settings | File Templates.
 */


VoyangaCalendarTimeline = new VoyangaCalendarClass({jObj:'#voyanga-calendar-timeline',values:new Array(),twoSelect: true,
    monthNames: new Array('','','','','','','','','','','','')});
VoyangaCalendarTimeline.slider = new VoyangaCalendarSlider({
    init: function(){
        //console.log(this.monthArray);
        console.log(this.jObj);
        if(typeof this.jObj == 'string'){
            this.jObj = $(this.jObj);
        }
        var self = this;
        this.monthLineWidth = (this.totalLines) / this.totalShowLines;
        var monthLineWidth = Math.round((this.monthLineWidth)*10000)/100;
        this.jObj.find('.monthLineVoyanga').css('width',monthLineWidth + '%');
        var leftPercent = this.startLine / (this.totalShowLines);
        this.monthLineLeftPercent = leftPercent;
        leftPercent =  Math.round(leftPercent*1000 )/10;
        this.jObj.find('.monthLineVoyanga').css('left',leftPercent + '%');
        var tLines = this.totalLines;
        if(this.totalLines == this.linesWidth){
            this.jObj.find('.knobVoyanga').css('display','none');
            this.jObj.find('.knobUpAllMonth').css('display','none');
            tLines++;
        }else{
            this.jObj.find('.knobVoyanga').css('display','block');
            this.jObj.find('.knobUpAllMonth').css('display','block');
        }
        for(var i in this.monthShowArray){
            var leftPercent = this.monthShowArray[i].line / (this.totalShowLines - this.linesWidth);
            leftPercent =  Math.round((1 - (this.linesWidth / this.totalShowLines) )*leftPercent*1000 )/10;
            if(i < (this.monthShowArray.length - 1) ){
                var k=parseInt(i)+1;
                var widthPercent = (this.monthShowArray[k].line - this.monthShowArray[i].line) / this.totalShowLines;
            }else{
                var widthPercent = (this.totalShowLines - this.monthShowArray[i].line) / this.totalShowLines;
            }
            widthPercent = Math.round(widthPercent*1000)/10;

            var newHtml = $('<div class="monthNameVoyangaSplit" style="left: '+leftPercent+'%; width: '+widthPercent+'%"></div><div class="monthNameVoyanga" style="left: '+leftPercent+'%; width: '+widthPercent+'%"><div class="monthWrapper">'+this.monthShowArray[i].name+'</div></div>');
            //add only 3 lines condition
            if((this.monthShowArray[i].line >= (this.startLine - 3)) && (this.monthShowArray[i].line < (this.startLine+this.totalLines)) && (this.totalLines != this.linesWidth)){
                if(!this.monthShowArray[i].lineReal)
                    this.monthShowArray[i].lineReal = 0;
                leftPercent = this.monthShowArray[i].lineReal / (tLines - this.linesWidth);
                console.log('mmmm',this.monthShowArray[i].lineReal,tLines,this.linesWidth);
                leftPercent =  Math.round((1 - (this.linesWidth / tLines) )*leftPercent*1000 )/10;
                newHtml.data('clickable',true);
                newHtml.data('leftPos',leftPercent);
                newHtml.addClass('highlited');
            }else{
                newHtml.data('clickable',false);
            }
            this.monthShowArray[i].div = newHtml;
            this.jObj.find('.monthLineVoyangaYear').append(newHtml);
        }

        this.knobWidth = Math.round(((this.linesWidth) / this.totalLines)*10000)/100;
        this.jObj.find('.knobVoyanga').css('width',this.knobWidth + '%');
        knobUpWidth = Math.round(((this.linesWidth) / this.totalLines)*this.monthLineWidth*10000)/100;
        this.jObj.find('.knobUpAllMonth').css('width',knobUpWidth + '%');
        this.jObj.find('.knobUpAllMonth').css('left',this.getKnobUpLeft());
        //VoyangaCalendar.slider.width = VoyangaCalendar.jObj.find('.monthLineVoyanga').width();
        $(window).on('resize',function(){self.onresize();});
        $(window).load(function(){self.onresize();self.knobMove();});

        this.jObj.find('.calendarGridVoyanga').on('scroll',function(e){self.scrollEvent(e);});
        //console.log('set wheel actions2');
        this.jObj.find('.calendarGridVoyanga').on('mousewheel',function (e){self.mousewheelEvent(e);
            if(e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
        });
        this.jObj.find('.calendarGridVoyanga').on('DOMMouseScroll',function (e){self.mousewheelEvent(e);
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
        });
        this.jObj.find('.monthLineWrapper').mousedown(function(e){self.mouseDown(e);});
        this.jObj.find('.monthLineWrapper').mouseup(function(e){self.mouseUp(e);});
        //VoyangaCalendar.jObj.find('.monthLineVoyanga .monthNameVoyanga').mouseup(VoyangaCalendar.slider.monthMouseUp);
        this.jObj.find('.monthLineVoyangaYear .monthNameVoyanga .monthWrapper').mouseup(function(e){var obj = this;self.monthMouseUp(obj,e);});
        this.jObj.find('.monthLineWrapper').MouseDraggable({
            startEvent: function (e,obj){self.startEvent(e,obj);},
            endEvent: function (e,obj){self.endEvent(e,obj);},
            dragEvent: function (e,obj){self.dragEvent(e,obj);}
        });
    },
    getKnobUpLeft: function(){
        //this.monthLineLeftPercent;
        leftPerc = Math.round( (this.monthLineLeftPercent*100 + this.knobPos*this.monthLineWidth)*10 )/10
        return leftPerc + '%';
    },
    monthMouseUp: function(obj,e){
        var clickable = $(obj).parent().data('clickable');
        if(clickable && !this.knobSlideAction)
        {
            this.animateScrollAction = true;
            this.jObj.find('.knobVoyanga').stop(true);
            //var newPos = $(obj).parent().css('left');
            var newPos = $(obj).parent().data('leftPos');
            if(newPos < 0) newPos = 0;
            if(newPos > (100 - this.knobWidth)) newPos = (100 - this.knobWidth);
            newPos = newPos+'%';
            //var newPos = $(this).css('left');
            var self = this;
            this.jObj.find('.knobVoyanga').animate({
                    left: [newPos, 'easeOutCubic']
                },
                {
                    duration: 800,
                    step: function(now,fx){self.animateStep(now,fx);},
                    easing: 'easeOutCubic',
                    complete: function(){self.animateScrollAction = false;}
                });
        }
    },
    knobMove: function(){
        var pWidth = this.knobWidth;
        //console.log(pWidth);
        var pLeft = this.knobPos;
        //console.log(pLeft);
        var pRight = pLeft + pWidth;
        var self = this;
        this.jObj.find('.monthNameVoyanga').each(function(){
            //var pMonthLeft = self.getPercent($(this).css('left'));
            var pMonthWidth = self.getPercent($(this).css('width'));
            /*if( ( (pRight - pMonthLeft) > (pMonthWidth * 0.6) ) && ( (pMonthLeft + pMonthWidth - pLeft) > (pMonthWidth * 0.6) )){
                //$(this).addClass('highlited');
                //console.log((pRight - pMonthLeft));

            }else{
                //$(this).removeClass('highlited');
            }*/
        });
    },
    linesWidth:3
});
console.log(this.jObj);
VoyangaCalendarTimeline.onCellOver = function(obj,e){

}
VoyangaCalendarTimeline.onCellOut = function(obj,e){

}
VoyangaCalendarTimeline.getCellByDate = function(oDate){
    var dateLabel = oDate.getFullYear()+'-'+(oDate.getMonth()+1)+'-'+oDate.getDate();
    return $('#dayCell-'+dateLabel);
}
VoyangaCalendarTimeline.onCellClick = function(obj,e){

}
VoyangaCalendarTimeline.generateGrid = function(){
    var startMoment = moment(this.minDate);
    var endMoment = moment(this.maxDate);
    var startDraw = moment(startMoment);
    var endDraw = moment(endMoment);
    console.log('dates',this.minDate,this.maxDate);
    var firstDay = this.minDate;
    //var firstDay = new Date('2012-04-10');
    var dayToday = new Date();
    dayToday.setMinutes(0,0,0);
    dayToday.setHours(0);
    //dayToday.setSeconds(0);

    var self = this;


    var startMonth = firstDay.getMonth();
    var tmpDate = moment(startMoment)._d;
    var weekDiff  = this.getDay(this.maxDate) - this.getDay(this.minDate);
    var dateDiff = Math.floor(endMoment.diff(startMoment,'days',true));
    console.log('diff',weekDiff,dateDiff);
    if(weekDiff == dateDiff){
        startDraw.subtract('d',7);
        endDraw.add('d',7);
    }
    startDraw.date(startDraw.date()-this.getDay(startDraw._d));
    dateDiff = Math.floor(endDraw.diff(startDraw,'days',true)) + 1;
    if(dateDiff <= 14){
        endDraw.add('d',7);
        dateDiff = Math.floor(endDraw.diff(startDraw,'days',true)) + 1;
    }
    console.log('ds',startDraw,'de',endDraw,dateDiff);
    if(dateDiff % 7 != 0){
        endDraw.add('d',7 - (dateDiff % 7));
    }
    console.log('ds',startDraw,'de',endDraw,dateDiff);
    dateDiff = Math.floor(endDraw.diff(startDraw,'days',true))+1;
    var centerDiff = Math.floor((365 - dateDiff)/2)
    tmpDate = moment(startMoment)._d;
    tmpDate.setDate(tmpDate.getDate() - centerDiff);
    tmpDate.setDate(1);
    var stopDate = moment(endDraw)._d;
    stopDate.setDate(stopDate.getDate() + centerDiff + 3);
    stopDate.setDate(1);
    stopDate.setDate(0);
    stopDate.setDate(stopDate.getDate()-this.getDay(stopDate));
    stopDate.setDate(stopDate.getDate() + 7);


    var weekDay = this.getDay(tmpDate);
    var startDate = tmpDate.getDate();
    var startYear = tmpDate.getFullYear();
    tmpDate.setDate(tmpDate.getDate()-this.getDay(tmpDate));
    //need for clone start temp date
    var temp = moment(tmpDate);
    var startTemp = moment(temp);

    var needStop = false;
    var lineNumber = 0;
    var lineNumberReal = 0;
    var fullYear  = false;
    console.log('date params',tmpDate,'st',startDraw,'en',endDraw,'stp', stopDate);
    this.slider.monthArray = new Array();
    this.slider.monthShowArray = new Array();
    this.slider.startLine = false;
    while(tmpDate < stopDate)
    {
        if((tmpDate < endDraw._d)&&(tmpDate >= startDraw)){
            var newHtml = '<div class="calendarLineVoyanga" id="weekNum-'+lineNumber+'" data-weeknum="'+lineNumber+'">';
            for(var i=0;i<7;i++){

                var label = '<div class="dayLabel'+((i>=5 && i<7) ? ' weekEnd' : '')+'">'+tmpDate.getDate()+'</div>';
                var label = '';
                if(tmpDate.getDate() == 1){
                    //label = label + ' <div class="monthLabel">' + this.monthNames[tmpDate.getMonth()] +'</div>';
                    label = label + this.monthNames[tmpDate.getMonth()];
                    var monthObject = new Object();
                    monthObject.line = lineNumber;
                    monthObject.lineReal = lineNumberReal;
                    monthObject.name = this.monthNames[tmpDate.getMonth()];
                    this.slider.monthArray.push(monthObject);
                    this.slider.monthShowArray.push(monthObject);
                }else if(this.slider.startLine === false){
                    this.slider.startLine = lineNumber;
                    //label = label + ' <div class="monthLabel">' + this.monthNames[tmpDate.getMonth()] +'</div>';
                    label = label + this.monthNames[tmpDate.getMonth()];
                }
                label = '<div class="dayLabel'+((i>=5 && i<7) ? ' weekEnd' : '')+'">' + tmpDate.getDate()+ ' ' +label + '</div>';
                var dateLabel = tmpDate.getFullYear()+'-'+(tmpDate.getMonth()+1)+'-'+tmpDate.getDate();
                newHtml = newHtml + '<div class="dayCellVoyanga'+((tmpDate < dayToday) ? ' inactive' : '')+((i>=5 && i<7) ? ' weekEnd' : '')+'" id="dayCell-'+dateLabel+'" data-cell-date="'+dateLabel+'"><div class="innerDayCellVoyanga">'+label+'</div></div>';
                tmpDate.setDate(tmpDate.getDate()+1);
            }
            newHtml = newHtml + '</div>';
            this.jObj.find('.calendarDIVVoyanga').append(newHtml);

            lineNumberReal++;
        }else{
            for(var i=0;i<7;i++){
                if(tmpDate.getDate() == 1){
                    var monthObject = new Object();
                    monthObject.line = lineNumber;
                    monthObject.name = this.monthNames[tmpDate.getMonth()];
                    this.slider.monthShowArray.push(monthObject);
                }
                tmpDate.setDate(tmpDate.getDate()+1);
            }
        }

        lineNumber++;
    }
    console.log('monthArr', this.slider.monthArray.length,this.slider.monthArray);


    var lastLineMonth = this.slider.monthShowArray[this.slider.monthShowArray.length - 1].line;
    //console.log(this.slider.monthArray);
    if((lineNumber - lastLineMonth) < 2){
        this.slider.monthShowArray.pop();
    }

    this.jObj.find('.dayCellVoyanga').hover(function (e) {var obj = this; self.onCellOver(obj,e);},function (e) {var obj = this; self.onCellOut(obj,e);});
    this.jObj.find('.dayCellVoyanga').on('click',function (e) {var obj = this; self.onCellClick(obj,e);});

    this.slider.totalLines = lineNumberReal;
    this.slider.totalShowLines = lineNumber;
    console.log(this.slider.totalLines);
}

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
VoyangaCalendarTimeline.calendarEvents = new Array();

VoyangaCalendarTimeline.eventsCompareFunction = function (a, b) {
    if (a.dayStart < b.dayStart) {
        return -1;
    } else if (a.dayStart > b.dayStart) {
        return 1;
    } else {
        if ((a.type == 'flight') && (b.type == 'hotel')) {
            return -1;
        } else if ((a.type == 'hotel') && (b.type == 'flight')) {
            return 1;
        } else {
            return 0;
        }
    }
}


VoyangaCalendarTimeline.generateStartPoint = function (FirstEvent) {
    var totalDays = FirstEvent.dayEnd.valueOf() - FirstEvent.dayStart.valueOf();
    totalDays = Math.round(totalDays / (3600 * 24 * 1000));
    if (totalDays == 0) {
        totalDays = 1;
    }
    var dayWidth = this.dayCellWidth;
    //var outHtml = '<div class="startYourTours" style="width: ' + (dayWidth * totalDays) + '%">';
    var outHtml = '<div class="startYourTours">';
    outHtml = outHtml + '</div>';
    return outHtml;
}

VoyangaCalendarTimeline.generateEndPoint = function (LastEvent) {
    var totalDays = LastEvent.dayEnd.valueOf() - LastEvent.dayStart.valueOf();
    totalDays = Math.round(totalDays / (3600 * 24 * 1000));
    if (totalDays == 0) {
        totalDays = 1;
    }
    var dayWidth = this.dayCellWidth;
    //var outHtml = '<div class="endYourTours" style="width: ' + (dayWidth * totalDays) + '%">';
    totalDays = totalDays % 7;
    var outHtml = '<div class="endYourTours" style="left: ' + (dayWidth * totalDays) + '%">';
    outHtml = outHtml + '</div>';
    return outHtml;
}

VoyangaCalendarTimeline.generateHotelDiv = function (HotelEvent) {
    var totalDays = HotelEvent.dayEnd.valueOf() - HotelEvent.dayStart.valueOf();
    totalDays = Math.round(totalDays / (3600 * 24 * 1000));
    if (totalDays == 0) {
        totalDays = 1;
    }
    console.log(totalDays);
    var dayWidth = this.dayCellWidth;
    var deltaLeft = (dayWidth / HotelEvent.startInfo.count)*(0.5);
    var deltaRight = (dayWidth / HotelEvent.endInfo.count)*(0.5);
    //var deltaWidth = deltaRight - deltaLeft;
    var setWidth = dayWidth * totalDays - dayWidth + 0.1 + (deltaLeft + deltaRight);
    var outHtml = '<div class="yourTrip" style="width: ' + (setWidth) + '%" data-delta-left="'+deltaLeft+'">';
    outHtml = outHtml + '<div class="startHotel"></div>';
    outHtml = outHtml + '<div class="pathHotel"></div><div class="endHotel"></div>';
    outHtml = outHtml + '<div class="nameHotel">' + HotelEvent.description + '</div>';
    outHtml = outHtml + '</div></div>';

    //outHtml = '<div class="yourTrip"><div class="startHotel"></div><div class="pathHotel"></div><div class="endHotel"></div><div class="nameHotel" style="color: rgb(234, 239, 243); position: absolute; top: 49px; z-index: 210; left: 16px;">  , </div></div>';
    return outHtml;
}

VoyangaCalendarTimeline.generateFlightDiv = function (FlightEvent) {
    var totalDays = FlightEvent.dayEnd.valueOf() - FlightEvent.dayStart.valueOf();
    totalDays = Math.floor(totalDays / (3600 * 24 * 1000));
    //console.log('generate flight div');

    //console.log(FlightEvent);
    totalDays = totalDays + 1;
    /*if(totalDays == 0){
     totalDays = 1;
     }*/
    //console.log(totalDays);
    //console.log(totalDays);
    var dayWidth = this.dayCellWidth;
    //console.log(dayWidth);
    var names = FlightEvent.description.split('||');



    switch (totalDays){
        case 1:
            var jetFlyClass = '';
            var imgPath = '/themes/v2/images/trip-line-01.png';
            var flyTripClass = 'flyTrip fd1';

            break;
        case 2:
            var jetFlyClass = ' twoDays';
            var imgPath = '/themes/v2/images/trip-line-02.png';
            var flyTripClass = 'flyTrip fd2';

            break;
        case 3:
            var jetFlyClass = ' threeDays';
            var imgPath = '/themes/v2/images/trip-line-03.png';
            var flyTripClass = 'flyTrip fd3';

            break;
    }

    if(totalDays == 1 && FlightEvent.startInfo.position == FlightEvent.endInfo.position){
        if(false && FlightEvent.startInfo.point || FlightEvent.startInfo.point){
            var deltaLeft = (dayWidth / FlightEvent.startInfo.count)*(0.5 + FlightEvent.startInfo.position);
            var outHtml = '<div class="flyTrip" style="width: 0%" data-delta-left="'+deltaLeft+'">';
            outHtml = outHtml + '<div class="startYourTours"></div></div>';
            return outHtml;
        }
        return '';
    }
    var deltaLeft = (dayWidth / FlightEvent.startInfo.count)*(0.5 + FlightEvent.startInfo.position);
    var deltaRight = (totalDays-1)*dayWidth + (dayWidth / FlightEvent.endInfo.count)*(0.5 + FlightEvent.endInfo.position);
    console.log('flightDiv',deltaLeft,deltaRight)
    var deltaWidth = deltaRight - deltaLeft;
    if(FlightEvent.startInfo.count == 3){
        names[0] = FlightEvent.cityFrom;
    }
    if(FlightEvent.endInfo.count == 3){
        names[1] = FlightEvent.cityTo;
    }


    var outHtml = '<div class="'+flyTripClass+'" style="width: ' + (deltaWidth) + '%" data-delta-left="'+deltaLeft+'">';
    outHtml = outHtml + (FlightEvent.startInfo.point ? '<div class="startYourTours"></div>' : '');
    outHtml = outHtml + '<div class="tripFlyAll"><div class="jetFly'+jetFlyClass+'" style="top: 4px;"></div><img width="100%" height="40" src="'+imgPath+'"></div>';
    outHtml = outHtml + (FlightEvent.startInfo.city ? '<div class="startNameCity">' + names[0] + '</div>' : '');
    outHtml = outHtml + (FlightEvent.endInfo.city ? '<div class="endNameCity">' + names[1] + '</div>' : '');
    outHtml = outHtml + (FlightEvent.endInfo.point ? '<div class="endYourTours"></div>' : '');
    outHtml = outHtml + '</div>';
    return outHtml;
}

VoyangaCalendarTimeline.generateEvents = function () {
    this.dayCellWidth = this.jObj.find('.dayCellVoyanga:first').width() + 2;
    this.dayCellWidth = 14.2;//14.28;
    var self = this;
    //Need width %
    var eventDays = {};
    //       
    //   ,    
    //      
    //
    //

    //              
    for (var i in this.calendarEvents) {
        var dt = this.calendarEvents[i].dayStart;
        var dateLabel = dt.getFullYear() + '-' + (dt.getMonth() + 1) + '-' + dt.getDate();
        if(typeof eventDays[dateLabel] != 'object'){
            eventDays[dateLabel] = {types: {}, count: 0};
        }

        if(typeof eventDays[dateLabel].types[this.calendarEvents[i].type] != 'object'){
            eventDays[dateLabel].types[this.calendarEvents[i].type] = {s: new Array(), e: new Array()};
        }
        eventDays[dateLabel].types[this.calendarEvents[i].type].s.push(i);
        eventDays[dateLabel].count++;


        var dt = this.calendarEvents[i].dayEnd;
        var dateLabel = dt.getFullYear() + '-' + (dt.getMonth() + 1) + '-' + dt.getDate();

        if(typeof eventDays[dateLabel] != 'object'){
            eventDays[dateLabel] = {types: {}, count: 0};
        }

        if(typeof eventDays[dateLabel].types[this.calendarEvents[i].type] != 'object'){
            eventDays[dateLabel].types[this.calendarEvents[i].type] = {s: new Array(), e: new Array()};
        }
        eventDays[dateLabel].types[this.calendarEvents[i].type].e.push(i);
        eventDays[dateLabel].count++;
    }
    console.log('eventDays',eventDays);

    //             
    for(var key in eventDays){
        var endIds = {};
        var startIds = {};
        var dateLabel = key;
        var startCity = '';
        var endCity = '';
        var centerCities = new Array();
        var startShowPoint = true;
        var endShowPoint = true;
        var pointsObject = {startPoints: [],centerPoints:{s:[],e:[]},endPoints: []}

        if(typeof eventDays[dateLabel].types['hotel'] == 'object'){
            for(var fIndS in eventDays[dateLabel].types['hotel'].s){
                //       ,       
                sInd = eventDays[dateLabel].types['hotel'].s[fIndS];
                pointsObject.endPoints.push(sInd);
                endCity = this.calendarEvents[sInd].city;
                endShowPoint = false;
                break;
            }
            for(var fIndE in eventDays[dateLabel].types['hotel'].e){
                //       ,       
                eInd = eventDays[dateLabel].types['hotel'].e[fIndE];
                pointsObject.startPoints.push(eInd);
                startCity = this.calendarEvents[eInd].city;
                startShowPoint = false;
                break;
            }
        }
        if(typeof eventDays[dateLabel].types['flight'] == 'object'){

            eventDays[dateLabel].types['flight'].s.sort(function(left,right){
                if(self.calendarEvents[left].sortInd > self.calendarEvents[right].sortInd)
                    return 1;
                if(self.calendarEvents[left].sortInd < self.calendarEvents[right].sortInd)
                    return -1;
                return 0;
            });
            eventDays[dateLabel].types['flight'].e.sort(function(left,right){
                if(self.calendarEvents[left].sortInd > self.calendarEvents[right].sortInd)
                    return -1;
                if(self.calendarEvents[left].sortInd < self.calendarEvents[right].sortInd)
                    return 1;
                return 0;
            });
            for(var fIndS in eventDays[dateLabel].types['flight'].s){
                sInd = eventDays[dateLabel].types['flight'].s[fIndS];
                if(startCity && this.calendarEvents[sInd].cityFrom == startCity){
                    pointsObject.startPoints.push(sInd);
                    this.calendarEvents[sInd].startInfo.point = false;
                }else if(!startCity){
                    startCity = this.calendarEvents[sInd].cityFrom;
                    pointsObject.startPoints.push(sInd);
                    this.calendarEvents[sInd].startInfo.point = true;
                }else if(endCity && this.calendarEvents[sInd].cityFrom == endCity){
                    pointsObject.endPoints.push(sInd);
                    this.calendarEvents[sInd].startInfo.point = false;
                }else{
                    pointsObject.centerPoints.s.push(sInd);
                    if(centerCities.indexOf(this.calendarEvents[sInd].cityFrom) == -1){
                        centerCities.push(this.calendarEvents[sInd].cityFrom);
                    }
                }

            }
            for(var fIndE in eventDays[dateLabel].types['flight'].e){
                eInd = eventDays[dateLabel].types['flight'].e[fIndE];
                if(endCity && this.calendarEvents[eInd].cityTo == endCity){
                    pointsObject.endPoints.push(eInd);
                    this.calendarEvents[eInd].endInfo.point = false;
                }else if(!endCity){
                    if(centerCities.length == 0 && startCity == this.calendarEvents[eInd].cityTo){
                        pointsObject.startPoints.push(eInd);
                    }else{
                        endCity = this.calendarEvents[eInd].cityTo;
                        pointsObject.endPoints.push(eInd);
                        this.calendarEvents[eInd].endInfo.point = true;
                    }
                }else if(startCity && this.calendarEvents[eInd].cityTo == startCity){
                    pointsObject.startPoints.push(eInd);
                    this.calendarEvents[eInd].endInfo.point = false;
                }else{
                    pointsObject.centerPoints.e.push(eInd);
                    if(centerCities.indexOf(this.calendarEvents[eInd].cityTo) == -1){
                        centerCities.push(this.calendarEvents[eInd].cityTo);
                    }
                }
            }
        }
        var count = 0;
        if(pointsObject.startPoints.length > 0){
            var startPosition = count;
            count++;
        }
        if((pointsObject.centerPoints.s.length + pointsObject.centerPoints.e.length) > 0){
            var centerPosition = count;
            count++;
        }
        if(pointsObject.endPoints.length > 0){
            var endPosition = count;
            count++;
        }
        var needShowCity = true;
        var needShowPoint = startShowPoint;
        for(var iInd in pointsObject.startPoints){
            sInd = pointsObject.startPoints[iInd];
            if(this.calendarEvents[sInd].type == 'hotel'){
                this.calendarEvents[sInd].endInfo.count = count;
                this.calendarEvents[sInd].endInfo.position = startPosition;
            }else{
                if (this.calendarEvents[sInd].startInfo.dateLabel == dateLabel ){
                    var infoKey = 'startInfo';
                }else{
                    var infoKey = 'endInfo';
                }
                this.calendarEvents[sInd][infoKey].count = count;
                this.calendarEvents[sInd][infoKey].position = startPosition;
                this.calendarEvents[sInd][infoKey].point = needShowPoint;
                this.calendarEvents[sInd][infoKey].city = needShowCity;
                needShowCity = false;
                needShowPoint = false;
            }
        }
        var needShowCity = centerCities.length == 1;
        var needShowPoint = true;
        for(var iInd in pointsObject.centerPoints.s){
            sInd = pointsObject.centerPoints.s[iInd];

            this.calendarEvents[sInd].startInfo.count = count;
            this.calendarEvents[sInd].startInfo.position = centerPosition;
            this.calendarEvents[sInd].startInfo.point = needShowPoint;
            this.calendarEvents[sInd].startInfo.city = needShowCity;
            needShowPoint = false;
            needShowCity = false;
        }
        if(centerCities.length > 1){
            this.calendarEvents[sInd].startInfo.point = true;
        }
        for(var iInd in pointsObject.centerPoints.e){
            sInd = pointsObject.centerPoints.e[iInd];

            this.calendarEvents[sInd].endInfo.count = count;
            this.calendarEvents[sInd].endInfo.position = centerPosition;
            this.calendarEvents[sInd].endInfo.point = needShowPoint;
            this.calendarEvents[sInd].endInfo.city = needShowCity;
            needShowPoint = false;
            needShowCity = false;
        }
        var needShowCity = true;
        var needShowPoint = endShowPoint;
        for(var iInd in pointsObject.endPoints){
            sInd = pointsObject.endPoints[iInd];
            if(this.calendarEvents[sInd].type == 'hotel'){
                this.calendarEvents[sInd].startInfo.count = count;
                this.calendarEvents[sInd].startInfo.position = endPosition;
            }else{
                this.calendarEvents[sInd].endInfo.count = count;
                this.calendarEvents[sInd].endInfo.position = endPosition;
                this.calendarEvents[sInd].endInfo.point = needShowPoint;
                this.calendarEvents[sInd].endInfo.city = needShowCity;
                needShowPoint = false;
                needShowCity = false;
            }
        }


    }
    console.log('eventDays',eventDays);
    console.log('calendarEvents',this.calendarEvents);

    var firstElem = true;
    var lastId = 0;
    var lastLeft = 0;
    for (var i in this.calendarEvents) {
        var dt = this.calendarEvents[i].dayStart;
        var dateLabel = dt.getFullYear() + '-' + (dt.getMonth() + 1) + '-' + dt.getDate();
        //console.log(dateLabel);

        var weekObj = this.jObj.find('#dayCell-' + dateLabel).parent();
        var weekNum = weekObj.data('weeknum');
        //console.log(weekNum);
        var tmpDate = new Date(dt.toString());
        //console.log(tmpDate);
        //return;
        var eventLength = this.calendarEvents[i].dayEnd.valueOf() - this.calendarEvents[i].dayStart.valueOf();

        var dayWidth = this.dayCellWidth;
        //alert(TimelineCalendar.calendarEvents[i].dayEnd+'???');

        //eventLength in days
        eventLength = Math.round(eventLength / (3600 * 24 * 1000));


        if (this.calendarEvents[i].type == 'hotel') {

            //console.log(TimelineCalendar.calendarEvents[i]);
            /** @var dt Date */

            var hotelDiv = this.generateHotelDiv(this.calendarEvents[i]);

            var renderedLength = 0;
            var endDraw = false;
            var firstTime = true;
            //alert('numRender:'+numRender+' renderedLength:'+renderedLength+' eventLength:'+eventLength);
            //continue;
            while (!endDraw) {
                var newEventElement = $(hotelDiv);
                var deltaLeft = newEventElement.data('delta-left');
                if (firstTime) {
                    var numRender = 7 - this.getDay(tmpDate) -1;
                    //console.log('day:'+TimelineCalendar.getDay(tmpDate));
                    //console.log(numRender);

                    var leftPos = (7 - numRender) * dayWidth - deltaLeft;
                    //console.log(leftPos);
                    firstTime = false;
                } else {
                    var numRender = 7;
                    var leftPos = -renderedLength * dayWidth - deltaLeft;
                }
                if(firstElem){
                    /*var pointDiv = this.generateStartPoint(this.calendarEvents[i]);
                    var pointDivElement = $(pointDiv);
                    pointDivElement.css('left', leftPos + '%');
                    weekObj.append(pointDivElement);*/
                    //newEventElement.addClass('startPoint');
                    firstElem = false;
                }
                newEventElement.css('left', leftPos + '%');
                weekObj.append(newEventElement);
                renderedLength = renderedLength + numRender;
                if (renderedLength >= eventLength) {
                    endDraw = true;
                }
                weekNum++;
                weekObj = this.jObj.find('#weekNum-' + weekNum);
            }
        } else if (this.calendarEvents[i].type == 'flight') {

            var flightDiv = this.generateFlightDiv(this.calendarEvents[i]);
            var renderedLength = 0;
            var endDraw = false;
            var firstTime = true;
            //continue;
            if(!flightDiv){
                continue;
            }
            while (!endDraw) {
                var newEventElement = $(flightDiv);
                var deltaLeft = newEventElement.data('delta-left');
                if (firstTime) {
                    var numRender = 7 - this.getDay(tmpDate);
                    //console.log('day:'+TimelineCalendar.getDay(tmpDate));
                    //console.log(numRender);
                    var leftPos = (7 - numRender) * dayWidth + deltaLeft;
                    //console.log(leftPos);
                    firstTime = false;
                } else {
                    var numRender = 7;
                    var leftPos = -renderedLength * dayWidth + deltaLeft;
                }
                if(firstElem){
                    /*var pointDiv = this.generateStartPoint(this.calendarEvents[i]);
                    var pointDivElement = $(pointDiv);
                    pointDivElement.css('left', leftPos + '%');
                    weekObj.append(pointDivElement);*/
                    //newEventElement.addClass('startPoint');
                    firstElem = false;
                }
                newEventElement.css('left', leftPos + '%');

                //console.log(newEventElement);
                weekObj.append(newEventElement);
                renderedLength = renderedLength + numRender;
                if (renderedLength >= eventLength) {
                    endDraw = true;
                }
                weekNum++;
                weekObj = this.jObj.find('#weekNum-' + weekNum);
            }
        }
        lastId = i;
    }
    weekNum--;
    weekObj = this.jObj.find('#weekNum-' + weekNum);

    newEventElement.addClass('endPoint');
        /*var pointDiv = this.generateEndPoint(this.calendarEvents[lastId]);
        var pointDivElement = $(pointDiv);
        //pointDivElement.css('left', leftPos + '%');
        weekObj.append(pointDivElement);*/


}

VoyangaCalendarTimeline.prepareEvents = function () {
    console.log(this.calendarEvents);
    var self = this;
    $.each(this.calendarEvents, function (ind, el) {
        el.dayStart = Date.fromIso(el.dayStart);
        el.dayEnd = Date.fromIso(el.dayEnd);
        if(!self.minDate){
            self.minDate = el.dayStart;
        }else if(self.minDate > el.dayStart){
            self.minDate = el.dayStart;
        }
        if(!self.maxDate){
            self.maxDate = el.dayEnd;
        }else if(self.maxDate < el.dayEnd){
            self.maxDate = el.dayEnd;
        }
        if(el.type == 'flight'){
            var dt = el.dayStart;
            var dateLabel = dt.getFullYear() + '-' + (dt.getMonth() + 1) + '-' + dt.getDate();
            el.startInfo = {point: true,city:true,count: 1,position:0,dateLabel: dateLabel};
            var dt = el.dayEnd;
            var dateLabel = dt.getFullYear() + '-' + (dt.getMonth() + 1) + '-' + dt.getDate();
            el.endInfo = {point: true,city:true,count: 1,position:0,dateLabel: dateLabel};
            el.sortInd = ind;
        }else{
            el.startInfo = {count: 1,position:0};
            el.endInfo = {count: 1,position:0};
        }
    });
}

VoyangaCalendarTimeline.init = function () {
    VoyangaCalendarTimeline.minDate = false;
    VoyangaCalendarTimeline.maxDate = false;
    this.prepareEvents();
    this.slider.jObj = this.jObj;
    if(typeof this.jObj == 'string'){
        this.jObj = $(this.jObj);
    }
    this.calendarEvents.sort(this.eventsCompareFunction);

    //console.log(TimelineCalendar.calendarEvents);
    //return true;
    this.generateGrid();
    //return true;
    this.generateEvents();
    this.slider.init();
}

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Generated by CoffeeScript 1.4.0
var GenericPopup,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

GenericPopup = (function() {

  function GenericPopup(id, data, modal) {
    var el,
      _this = this;
    this.id = id;
    this.modal = modal != null ? modal : false;
    this.close = __bind(this.close, this);

    this.inside = false;
    $('body').css('overflow', 'hidden');
    $('body').prepend('<div id="popupOverlay"></div>');
    el = $(this.id + '-template');
    if (el[0] === void 0) {
      throw "Wrong popup template";
      return;
    }
    el = $(el.html());
    $('body').prepend(el);
    ko.applyBindings({
      data: data,
      close: this.close
    }, el[0]);
    ko.processAllDeferredBindingUpdates();
    if (this.modal) {
      return;
    }
    $(window).keyup(function(e) {
      if (e.keyCode === 27) {
        return _this.close();
      }
    });
    $(el.find('table')[0] || el.find('.wrapContent')).hover(function() {
      return _this.inside = true;
    }, function() {
      return _this.inside = false;
    });
    el.click(function() {
      if (!_this.inside) {
        return _this.close();
      }
    });
  }

  GenericPopup.prototype.close = function() {
    if (!this.modal) {
      $(window).unbind('keyup');
    }
    $(this.id).remove();
    $('#popupOverlay').remove();
    $('body').css('overflow', 'auto');
    return btnClosePopUp();
  };

  return GenericPopup;

})();
// Generated by CoffeeScript 1.4.0
var ERRORS, ErrorPopup,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ERRORS = {
  avia404: {
    title: "  ",
    text: "        .      .",
    buttonText: "  ",
    onclose: false
  },
  avia500: {
    title: "",
    text: "      .      ,    .",
    buttonText: "  "
  },
  aviaNoTicketOnValidation: {
    title: "  ",
    text: "      .              - .     .",
    buttonText: "Ok"
  },
  hotels404: {
    title: "  ",
    text: "           .     .",
    buttonText: "  "
  },
  hotelsNoTicketOnValidation: {
    title: "   ",
    text: "  ,      .           - .    .",
    buttonText: "Ok"
  },
  toursNoTicketOnValidation: {
    title: "   ",
    text: "  ,     : TODO    .",
    buttonText: "Ok"
  },
  e500withText: {
    title: "",
    text: "      .      ,    : {0}",
    buttonText: "  "
  },
  passport500: {
    title: "",
    text: "      .      ,    .",
    buttonText: "  "
  },
  passportBookingError: {
    title: " ",
    text: "       : {0}            - .   - .",
    buttonText: "Ok"
  }
};

ErrorPopup = (function(_super) {

  __extends(ErrorPopup, _super);

  function ErrorPopup(key, params, onclose) {
    var data, id;
    if (params == null) {
      params = false;
    }
    this.onclose = onclose != null ? onclose : false;
    this.close = __bind(this.close, this);

    id = 'errorpopup';
    data = ERRORS[key];
    data.text = data.text.format(params);
    if (!this.onclose) {
      this.onclose = data.onclose;
    }
    ErrorPopup.__super__.constructor.call(this, '#' + id, data, true);
    ko.processAllDeferredBindingUpdates();
    SizeBox(id);
    ResizeBox(id);
  }

  ErrorPopup.prototype.close = function() {
    ErrorPopup.__super__.close.apply(this, arguments);
    if (this.onclose) {
      return this.onclose();
    } else {
      return window.location = '/#' + (window.app.activeModule() || 'tours');
    }
  };

  return ErrorPopup;

})(GenericPopup);
// Generated by CoffeeScript 1.4.0
var PhotoBox,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

PhotoBox = (function() {

  function PhotoBox(photos, title, stars, initIndex) {
    var _this = this;
    this.photos = photos;
    this.title = title;
    this.stars = stars != null ? stars : 0;
    if (initIndex == null) {
      initIndex = 0;
    }
    this._load = __bind(this._load, this);

    this.prev = __bind(this.prev, this);

    this.next = __bind(this.next, this);

    this.photoLoad = __bind(this.photoLoad, this);

    if (photos.length === 0) {
      return;
    }
    this.activeIndex = ko.observable(initIndex);
    this.length0 = photos.length - 1;
    this.activePhoto = ko.observable(this.photos[this.activeIndex()]['largeUrl']);
    this.activeDesc = ko.observable(this.photos[this.activeIndex()]['description']);
    this.busy = false;
    $('body').prepend('<div id="popupOverlayPhoto"></div>');
    $('body').prepend($('#photo-popup-template').html());
    ko.applyBindings(this, $('#body-popup-Photo')[0]);
    ko.processAllDeferredBindingUpdates();
    resizeLoad();
    this.loadFirstTime = true;
    $(window).keyup(function(e) {
      if (e.keyCode === 27) {
        return _this.close();
      } else if (e.keyCode === 37) {
        return _this.prev();
      } else if (e.keyCode === 39) {
        return _this.next();
      }
    });
  }

  PhotoBox.prototype.close = function() {
    $(window).unbind('keyup');
    $('#body-popup-Photo').remove();
    return $('#popupOverlayPhoto').remove();
  };

  PhotoBox.prototype.photoLoad = function(context, event) {
    var el;
    console.log("PHOTOLOAD");
    if (this.loadFirstTime) {
      this.loadFirstTime = false;
    }
    el = $(event.currentTarget);
    el.show();
    console.log(el);
    if (el.width() > 850) {
      el.css('width', '850px');
    } else {
      el.css('width', 'auto');
    }
    $('#hotel-img-load').hide();
    el.animate({
      opacity: 1
    }, 300, function() {
      return console.log("opacitied");
    });
    return this.busy = false;
  };

  PhotoBox.prototype.next = function(context, event) {
    if (this.busy) {
      return;
    }
    if (this.activeIndex() >= this.length0) {
      return;
    }
    this.activeIndex(this.activeIndex() + 1);
    return this._load();
  };

  PhotoBox.prototype.prev = function(context, event) {
    if (this.busy) {
      return;
    }
    if (this.activeIndex() <= 0) {
      return;
    }
    this.activeIndex(this.activeIndex() - 1);
    return this._load();
  };

  PhotoBox.prototype._load = function(var1, var2) {
    var _this = this;
    $('#body-popup-Photo').find('table img').animate({
      opacity: 0
    }, 300, function() {
      _this.activePhoto(_this.photos[_this.activeIndex()]['largeUrl']);
      return _this.activeDesc(_this.photos[_this.activeIndex()]['description']);
    });
    return $('#hotel-img-load').show();
  };

  return PhotoBox;

})();
// Generated by CoffeeScript 1.4.0
var Slider,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Slider = (function() {

  function Slider() {
    this.handler = __bind(this.handler, this);

    this.click = __bind(this.click, this);

    this.init = __bind(this.init, this);
    this.speed = 400;
    this.plannerWidth = [143, 0];
    this.aviaticketsWidth = [135, 155];
    this.hotelWidth = [95, 295];
    this.finishStagesWidth = [148, 403];
  }

  Slider.prototype.init = function() {
    var activeLI, activeLIindex;
    activeLI = $('.slide-turn-mode ul').find('.active');
    activeLIindex = activeLI.index();
    if (activeLIindex === -1) {
      activeLIindex = 1;
    }
    console.log("activeLIindex", activeLIindex);
    this.switchSlide = $('.slide-turn-mode').find('.switch');
    this.valueWidth = [this.plannerWidth, this.aviaticketsWidth, this.hotelWidth, this.finishStagesWidth];
    this.switchSlide.css('width', this.valueWidth[activeLIindex][0] + 'px').css('left', this.valueWidth[activeLIindex][1] + 'px');
    return this.switchSlide.find('.c').css('width', (this.valueWidth[activeLIindex][0] - 27) + 'px');
  };

  Slider.prototype.click = function(scope, event) {
    event.preventDefault();
    return window.app.navigate($(event.currentTarget).find('a').attr('href'), {
      'trigger': true
    });
  };

  Slider.prototype.handler = function(newValue) {
    var activeLI, activeLIindex;
    if (newValue === undefined) {
      return;
    }
    console.log("HANDLER: ", newValue);
    activeLI = $('#h-' + newValue + '-slider');
    activeLIindex = activeLI.index();
    $('.btn').removeClass('active');
    this.switchSlide.animate({
      width: this.valueWidth[activeLIindex][0] + 'px',
      left: this.valueWidth[activeLIindex][1] + 'px'
    }, this.speed, function() {
      return activeLI.addClass('active');
    });
    return this.switchSlide.find('.c').animate({
      width: (this.valueWidth[activeLIindex][0] - 27) + 'px'
    }, this.speed);
  };

  return Slider;

})();
// Generated by CoffeeScript 1.4.0
var ACC_MONTHS, AVIA_TICKET_TIMELIMIT, HOTEL_TICKET_TIMELIMIT, MONTHS, SHORT_MONTHS, SHORT_WEEKDAYS, TOURS_TICKET_TIMELIMIT, Utils, dateUtils, exTrim, isEmail,
  _this = this;

AVIA_TICKET_TIMELIMIT = 15 * 60;

HOTEL_TICKET_TIMELIMIT = 15 * 60;

TOURS_TICKET_TIMELIMIT = 15 * 60;

MONTHS = ['', '', '', '', '', '', '', '', '', '', '', ''];

ACC_MONTHS = ['', '', '', '', '', '', '', '', '', '', '', ''];

SHORT_MONTHS = ['', '', '', '', '', '', '', '', '', '', '', ''];

SHORT_WEEKDAYS = ['', '', '', '', '', '', ''];

dateUtils = {
  formatDay: function(date) {
    var day, re;
    if (date.length === 0) {
      return;
    }
    if (date.getDay) {
      day = date.getDate();
    } else {
      re = /(\d+)\.(\d+)\.(\d+)/;
      day = re.exec(date)[1];
    }
    return day;
  },
  formatMonth: function(date) {
    var month, re;
    if (date.length === 0) {
      return;
    }
    if (date.getMonth) {
      month = date.getMonth();
    } else {
      re = /(\d+)\.(\d+)\.(\d+)/;
      month = re.exec(date)[2] - 1;
    }
    return SHORT_MONTHS[month];
  },
  formatDayMonth: function(date) {
    var result;
    if (date.length === 0) {
      return;
    }
    result = "";
    result += date.getDate();
    result += " ";
    return result += MONTHS[date.getMonth()];
  },
  formatDayMonthYear: function(date) {
    var result;
    if (date.length === 0) {
      return;
    }
    result = "";
    result += date.getDate();
    result += " ";
    result += MONTHS[date.getMonth()];
    result += " ";
    return result += date.getYear();
  },
  formatDayMonthInterval: function(dateStart, dateEnd) {
    var result;
    if (dateStart.length === 0 || dateEnd.length === 0) {
      return;
    }
    result = " ";
    result += dateStart.getDate();
    if (dateStart.getMonth() !== dateEnd.getMonth()) {
      result += ' ' + MONTHS[dateStart.getMonth()];
    }
    result += '  ' + dateEnd.getDate();
    return result += ' ' + MONTHS[dateEnd.getMonth()];
  },
  formatDayShortMonth: function(date) {
    var result;
    if (date.length === 0) {
      return;
    }
    result = "";
    result += date.getDate();
    result += " ";
    return result += SHORT_MONTHS[date.getMonth()];
  },
  formatHtmlDayShortMonth: function(date) {
    var result;
    if (!date.getDate) {
      date = date.toDate();
    }
    result = '<span class="f17">';
    result += date.getDate();
    result += "</span><br>";
    return result += SHORT_MONTHS[date.getMonth()];
  },
  formatDayMonthWeekday: function(date) {
    var result;
    console.log("formatDayMonthWeekday", date);
    if (!date.getDate()) {
      date = date.toDate();
    }
    result = "<b>";
    result += date.getDate();
    result += "</b> ";
    result += SHORT_MONTHS[date.getMonth()];
    result += ", ";
    return result += SHORT_WEEKDAYS[date.getDay()];
  },
  formatTime: function(date) {
    var minutes, result;
    result = "";
    result += date.getHours();
    result += ":";
    minutes = date.getMinutes().toString();
    if (minutes.length === 1) {
      minutes = "0" + minutes;
    }
    result += minutes;
    return result;
  },
  formatTimeInMinutes: function(date) {
    var result;
    result = date.getHours() * 60 + date.getMinutes();
    return result;
  },
  formatDuration: function(duration) {
    var all_minutes, hours, minutes;
    all_minutes = duration / 60;
    minutes = all_minutes % 60;
    hours = (all_minutes - minutes) / 60;
    return hours + " . " + minutes + " .";
  }
};

Utils = {
  implode: function(glue, pieces) {
    if (pieces instanceof Array) {
      return pieces.join(glue);
    } else {
      return pieces;
    }
  },
  inRange: function(value, range) {
    return range.from <= value && value <= range.to;
  },
  fromIso: function(dateIsoString) {
    var initArray;
    if (typeof dateIsoString === 'string') {
      initArray = dateIsoString.split('-');
      return new Date(initArray[0], initArray[1] - 1, initArray[2]);
    } else {
      return dateIsoString;
    }
  },
  scrollTo: function(selector, animation, callback) {
    var oPos;
    if (animation == null) {
      animation = true;
    }
    if (callback == null) {
      callback = null;
    }
    if (typeof selector === "string") {
      oPos = $(selector).offset();
    } else if (typeof selector === "object") {
      oPos = $(selector).offset();
    } else {
      oPos = {};
      oPos.top = selector;
    }
    if (oPos) {
      if (animation) {
        if (callback) {
          return $("html,body").animate({
            'scrollTop': oPos.top
          }, 1000, callback);
        } else {
          return $("html,body").animate({
            'scrollTop': oPos.top
          });
        }
      } else {
        return $("html,body").scrollTop(oPos.top);
      }
    }
  },
  wordAfterNum: function(number, oneWord, fourWord, sevenWord) {
    var iModulo, iNum;
    if (sevenWord == null) {
      sevenWord = false;
    }
    if (!sevenWord) {
      sevenWord = fourWord;
    }
    iNum = number % 100;
    if ((4 < iNum && iNum < 21)) {
      return number + ' ' + sevenWord;
    } else {
      iModulo = iNum % 10;
      if (iModulo === 1) {
        return number + ' ' + oneWord;
      } else if ((1 < iModulo && iModulo < 5)) {
        return number + ' ' + fourWord;
      } else {
        return number + ' ' + sevenWord;
      }
    }
  },
  limitTextLenght: function(text, limit) {
    var pos, result, rusCount, subText;
    result = {};
    pos = text.lastIndexOf(' ', limit);
    subText = text.substr(0, pos);
    rusCount = Utils.countRusChars(subText);
    if (rusCount > (limit / 2)) {
      limit = Math.round(limit * 0.84);
    }
    if (text.length > limit) {
      pos = text.lastIndexOf(' ', limit);
      result['startText'] = text.substr(0, pos);
      result['endText'] = text.substr(pos);
      result['isBigText'] = true;
    } else {
      result['isBigText'] = false;
      result['startText'] = text;
      result['endText'] = '';
    }
    return result;
  },
  countRusChars: function(text) {
    var endLen, re, startLen;
    startLen = text.length;
    re = new RegExp('[--]', 'gi');
    endLen = (text.replace(re, '')).length;
    return startLen - endLen;
  },
  submitPayment: function(params) {
    var form_html, key, value;
    form_html = '<form id="buy-form" method="GET" action="' + params.url + '" target="payment_frame">';
    delete params.url;
    for (key in params) {
      value = params[key];
      form_html += "<input type=\"hidden\" name=\"" + key + "\" value=\"" + value + "\" />";
    }
    form_html += '</form>';
    return $(form_html).appendTo('body').submit();
  },
  toBuySubmit: function(toBuy) {
    var form_html, index, key, params, value, _i, _len;
    form_html = '<form id="buy-form" method="GET" action="/buy">';
    for (index = _i = 0, _len = toBuy.length; _i < _len; index = ++_i) {
      params = toBuy[index];
      for (key in params) {
        value = params[key];
        key = "item[" + index + "][" + key + "]";
        form_html += "<input type=\"hidden\" name=\"" + key + "\" value=\"" + value + "\" />";
      }
    }
    form_html += '</form>';
    $('body').append(form_html);
    return $('#buy-form').submit();
  },
  formatPrice: function(price) {
    var i, intPrice, j, ret, strPrice, _i, _ref;
    intPrice = parseInt(price);
    strPrice = intPrice.toString();
    ret = "";
    j = 0;
    for (i = _i = _ref = strPrice.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      if (j !== 0 && j % 3 === 0) {
        ret = ' ' + ret;
      }
      ret = strPrice[i] + ret;
      j++;
    }
    return ret;
  },
  calculateTheDistance: function(lat1, lng1, lat2, lng2) {
    var $ad, $cdelta, $cl1, $cl2, $delta, $dist, $lat1, $lat2, $long1, $long2, $sdelta, $sl1, $sl2, $x, $y;
    $lat1 = lat1 * Math.PI / 180;
    $lat2 = lat2 * Math.PI / 180;
    $long1 = lng1 * Math.PI / 180;
    $long2 = lng2 * Math.PI / 180;
    $cl1 = Math.cos($lat1);
    $cl2 = Math.cos($lat2);
    $sl1 = Math.sin($lat1);
    $sl2 = Math.sin($lat2);
    $delta = $long2 - $long1;
    $cdelta = Math.cos($delta);
    $sdelta = Math.sin($delta);
    $y = Math.sqrt(Math.pow($cl2 * $sdelta, 2) + Math.pow($cl1 * $sl2 - $sl1 * $cl2 * $cdelta, 2));
    $x = $sl1 * $sl2 + $cl1 * $cl2 * $cdelta;
    $ad = Math.atan2($y, $x);
    $dist = $ad * 6372795;
    return $dist;
  }
};

exTrim = function(str, charlist) {
  var re;
  charlist = (!charlist ? " s" : charlist.replace(/([\[\]\(\)\.\?\/\*\{\}\+\$\^\:])/g, "$1"));
  re = new RegExp("^[" + charlist + "]+|[" + charlist + "]+$", "g");
  return str.replace(re, "");
};

String.prototype.format = function() {
  var args;
  args = arguments;
  return this.replace(/{(\d+)}/g, function(match, number) {
    if (typeof args[number] !== 'undefined') {
      return args[number];
    } else {
      return match;
    }
  });
};

isEmail = function(email) {
  var emailPatterh;
  emailPatterh = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/;
  return email.match(emailPattern);
};
// Generated by CoffeeScript 1.4.0

ko.extenders.integerOnly = function(target, config) {
  return ko.computed({
    read: target,
    write: function(newValue) {
      var current, valueToWrite;
      current = target();
      valueToWrite = parseInt(newValue);
      if (isNaN(valueToWrite) || valueToWrite < 0) {
        valueToWrite = 0;
      }
      if (config.max) {
        if (valueToWrite < config.min) {
          valueToWrite = config.min;
        }
        if (valueToWrite > config.max) {
          valueToWrite = config.max;
        }
      }
      if (valueToWrite !== current) {
        target(valueToWrite);
      }
      if (newValue !== current) {
        return target.notifySubscribers(valueToWrite);
      }
    }
  });
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.timeSlider = {
  init: function(element, valueAccessor) {
    var limits, value;
    value = ko.utils.unwrapObservable(valueAccessor().selection);
    limits = ko.utils.unwrapObservable(valueAccessor().limits);
    limits.from -= 15;
    if (limits.from < 0) {
      limits.from = 0;
    }
    limits.to += 15;
    if (limits.to > 1440) {
      limits.to = 1440;
    }
    if (!Utils.inRange(value.from, limits)) {
      value.from = limits.from;
    }
    if (!Utils.inRange(value.to, limits)) {
      value.to = limits.to;
    }
    $(element).val(value.from + ';' + value.to);
    $(element).jslider({
      from: limits.from,
      to: limits.to,
      step: 15,
      dimension: '',
      skin: 'round_voyanga',
      scale: false,
      limits: false,
      minInterval: 60,
      calculate: function(value) {
        var hours, mins;
        hours = Math.floor(value / 60);
        mins = value - hours * 60;
        if (hours < 10) {
          hours = "0" + hours;
        }
        if (mins === 0) {
          mins = "00";
        }
        return hours + ':' + mins;
      },
      callback: function(newValue) {
        return valueAccessor().selection(newValue);
      }
    });
    return valueAccessor().element = $(element);
  },
  update: function(element, valueAccessor) {
    var s;
    s = $(element).data("jslider");
    return setTimeout(function() {
      return s.onresize();
    }, 5);
  }
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.priceSlider = {
  init: function(element, valueAccessor) {
    var limits, value;
    value = ko.utils.unwrapObservable(valueAccessor().selection);
    limits = ko.utils.unwrapObservable(valueAccessor().limits);
    if (limits.from < 0) {
      limits.from = 0;
    }
    console.log(limits.to);
    if (!Utils.inRange(value.from, limits)) {
      value.from = limits.from;
    }
    if (!Utils.inRange(value.to, limits)) {
      value.to = limits.to;
    }
    $(element).val(value.from + ';' + value.to);
    $(element).jslider({
      from: limits.from,
      to: limits.to,
      dimension: '&nbsp;',
      skin: 'round_voyanga',
      scale: false,
      limits: false,
      minInterval: 60,
      calculate: function(value) {
        var strVal;
        strVal = value.toString();
        if (strVal.length > 3) {
          strVal = strVal.substr(0, strVal.length - 3) + '&nbsp;' + strVal.substr(-3);
        }
        return strVal;
      },
      callback: function(newValue) {
        return valueAccessor().selection(newValue);
      }
    });
    return valueAccessor().element = $(element);
  },
  update: function(element, valueAccessor) {
    var s;
    s = $(element).data("jslider");
    return setTimeout(function() {
      return s.onresize();
    }, 5);
  }
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.singleSlider = {
  init: function(element, valueAccessor) {
    var dimension, limits, value;
    value = ko.utils.unwrapObservable(valueAccessor().selection);
    limits = ko.utils.unwrapObservable(valueAccessor().limits);
    if (limits.from < 0) {
      limits.from = 0;
    }
    value = limits.to;
    dimension = $(element).data('dimension');
    if (dimension) {
      dimension = '&nbsp;' + dimension;
    }
    $(element).val(value);
    $(element).jslider({
      from: limits.from,
      to: limits.to,
      dimension: dimension,
      skin: 'round_voyanga',
      scale: false,
      limits: false,
      round: 1,
      calculate: function(value) {
        var strVal;
        strVal = value.toString();
        if (strVal.length > 3) {
          strVal = strVal.substr(0, strVal.length - 3) + '&nbsp;' + strVal.substr(-3);
        }
        return strVal;
      },
      callback: function(newValue) {
        return valueAccessor().selection(newValue);
      }
    });
    return valueAccessor().element = $(element);
  },
  update: function(element, valueAccessor) {
    var s;
    s = $(element).data("jslider");
    return setTimeout(function() {
      return s.onresize();
    }, 5);
  }
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.slider = {
  init: function(element, valueAccessor) {
    var value;
    value = ko.utils.unwrapObservable(valueAccessor());
    return $(element).selectSlider({});
  },
  update: function(element, valueAccessor) {}
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.photoSlider = {
  init: function(element, valueAccessor) {
    var value;
    value = ko.utils.unwrapObservable(valueAccessor());
    return $(element).photoSlider({});
  },
  update: function(element, valueAccessor) {}
};
// Generated by CoffeeScript 1.4.0
var checkVoybox, uncheckVoybox;

checkVoybox = function(el) {
  return el.find('.ui-control').addClass('on');
};

uncheckVoybox = function(el) {
  return el.find('.ui-control').removeClass('on');
};

ko.bindingHandlers.checkbox = {
  init: function(element, valueAccessor) {
    var checked, classCheck, el, htm, label, new_el;
    label = ko.utils.unwrapObservable(valueAccessor().label);
    checked = valueAccessor().checked;
    el = $(element);
    classCheck = 'checkbox';
    htm = '';
    htm += '<label class="ui-hover cF">';
    htm += '<div class="ui-control ' + classCheck + '"></div>';
    htm += '<div class="fl">';
    htm += '<div class="ui-label">' + label + '</div>';
    htm += '</div>';
    htm += '</label>';
    new_el = $(htm);
    new_el.click(function() {
      el = $(this);
      if (el.find('.ui-control').hasClass('on') !== true) {
        checkVoybox(el);
        if (_.isFunction(checked)) {
          return checked(true);
        } else {
          return $(element).attr('checked', 'checked');
        }
      } else {
        if (_.isFunction(checked)) {
          checked(false);
        } else {
          $(element).removeAttr('checked');
        }
        return uncheckVoybox(el);
      }
    });
    el.after(new_el);
    return el.hide();
  },
  update: function(element, valueAccessor) {
    var checked, el;
    checked = ko.utils.unwrapObservable(valueAccessor().checked);
    el = $(element).next();
    if (checked) {
      return checkVoybox(el);
    } else {
      return uncheckVoybox(el);
    }
  }
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.swapPanel = {
  update: function(element, valueAccessor) {
    var value;
    value = ko.utils.unwrapObservable(valueAccessor());
    $(element).off('click');
    return $(element).on('click', function() {
      var newHref;
      newHref = value.to;
      console.log("switching to " + newHref);
      return window.app.navigate(newHref, {
        'trigger': true
      });
    });
  }
};
// Generated by CoffeeScript 1.4.0

ko.bindingHandlers.gMap = {
  init: function(element, valueAccessor) {
    var disp, gMap, value;
    value = ko.utils.unwrapObservable(valueAccessor());
    disp = $(element).css('display');
    $(element).css('display', 'block');
    gMap = new google.maps.Map(element, {
      'mapTypeControl': false,
      'panControl': false,
      'zoomControlOptions': {
        position: google.maps.ControlPosition.LEFT_TOP,
        style: google.maps.ZoomControlStyle.SMALL
      },
      'streetViewControl': false,
      'zoom': 3,
      'mapTypeId': google.maps.MapTypeId.TERRAIN,
      'center': new google.maps.LatLng(value.lat, value.lng)
    });
    return window.setTimeout(function() {
      return $(element).css('display', disp);
    }, 700);
  },
  update: function(element, valueAccessor) {}
};
// Generated by CoffeeScript 1.4.0
var HotelPeopleSelector, Passengers, PeopleSelector, Roomers,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PeopleSelector = (function() {

  function PeopleSelector() {
    this.afterRender = __bind(this.afterRender, this);

    this.afterRenderPeoplePopup = __bind(this.afterRenderPeoplePopup, this);

    this.showPeoplePopup = __bind(this.showPeoplePopup, this);

    this.show = __bind(this.show, this);
    this.inside = false;
    this.inside2 = false;
    this.inside3 = false;
  }

  PeopleSelector.prototype.show = function(context, event) {
    var coords, el,
      _this = this;
    el = $(event.currentTarget);
    if (!el.hasClass('active')) {
      $(document.body).mousedown(function() {
        if (_this.inside || _this.inside2 || _this.inside3) {
          return;
        }
        return _this.close();
      });
      $('.how-many-man .btn').addClass('active');
      $('.how-many-man .content').addClass('active');
      el = $('.how-many-man').find('.popup');
      el.addClass('active');
      coords = $('.how-many-man').offset();
      el.css('top', coords.top + $('.how-many-man').height());
      return el.css('left', coords.left);
    } else {
      return this.close();
    }
  };

  PeopleSelector.prototype.showPeoplePopup = function(context, event) {
    var coords, el,
      _this = this;
    el = $('.popupPeople');
    if (!el.hasClass('active')) {
      $(document.body).mousedown(function(event) {
        console.log('click event', event);
        event.target;
        if ($(event.target).parents('.popupPeople').length > 0) {
          return;
        }
        return _this.close();
      });
      $('.how-many-man .btn').addClass('active');
      $('.how-many-man .content').addClass('active');
      el.addClass('active');
      coords = $('.how-many-man').offset();
      return el.css('left', coords.left);
    } else {
      return this.close();
    }
  };

  PeopleSelector.prototype.afterRenderPeoplePopup = function() {
    $('.popupPeople').find('input').hover(function() {
      $(this).parent().find('.plusOne').show();
      return $(this).parent().find('.minusOne').show();
    });
    $('.adults,.childs,.small-childs').hover(null, function() {
      $(this).parent().find('.plusOne').hide();
      return $(this).parent().find('.minusOne').hide();
    });
    $('.plusOne').hover(function() {
      $(this).addClass('active');
      return $('.minusOne').addClass('active');
    }, function() {
      $(this).removeClass('active');
      return $('.minusOne').removeClass('active');
    });
    $('.minusOne').hover(function() {
      $(this).addClass('active');
      return $('.plusOne').addClass('active');
    }, function() {
      $(this).removeClass('active');
      return $('.plusOne').removeClass('active');
    });
    $('.popupPeople').find('input').focus(function() {
      $(this).attr('rel', $(this).val());
      return $(this).val('');
    });
    return $('.popupPeople').find('input').blur(function() {
      if ($(this).val() === '') {
        $(this).val($(this).attr('rel'));
      }
      return $(this).trigger('change');
    });
  };

  PeopleSelector.prototype.afterRender = function() {
    var _this = this;
    $('.how-many-man .popup').find('input').hover(function() {
      $(this).parent().find('.plusOne').show();
      return $(this).parent().find('.minusOne').show();
    });
    $('.adults,.childs,.small-childs').hover(null, function() {
      $(this).parent().find('.plusOne').hide();
      return $(this).parent().find('.minusOne').hide();
    });
    $('.plusOne').hover(function() {
      $(this).addClass('active');
      return $('.minusOne').addClass('active');
    }, function() {
      $(this).removeClass('active');
      return $('.minusOne').removeClass('active');
    });
    $('.minusOne').hover(function() {
      $(this).addClass('active');
      return $('.plusOne').addClass('active');
    }, function() {
      $(this).removeClass('active');
      return $('.plusOne').removeClass('active');
    });
    $('.how-many-man .popup').find('input').focus(function() {
      $(this).attr('rel', $(this).val());
      return $(this).val('');
    });
    $('.how-many-man .popup').find('input').blur(function() {
      if ($(this).val() === '') {
        $(this).val($(this).attr('rel'));
      }
      return $(this).trigger('change');
    });
    $('.how-many-man').find('.popup').hover(function() {
      return _this.inside = true;
    }, function() {
      return _this.inside = false;
    });
    $('.how-many-man .content').hover(function() {
      return _this.inside2 = true;
    }, function() {
      return _this.inside2 = false;
    });
    return $('.how-many-man .btn').hover(function() {
      return _this.inside3 = true;
    }, function() {
      return _this.inside3 = false;
    });
  };

  PeopleSelector.prototype.close = function() {
    $(document.body).unbind('mousedown');
    $('.how-many-man .btn').removeClass('active');
    $('.how-many-man .content').removeClass('active');
    $('.popupPeople').removeClass('active');
    return $('.how-many-man').find('.popup').removeClass('active');
  };

  return PeopleSelector;

})();

Passengers = (function(_super) {

  __extends(Passengers, _super);

  function Passengers() {
    this.balanceTravelers = __bind(this.balanceTravelers, this);

    var _this = this;
    this.template = 'passengers-template';
    this.adults = ko.observable(1).extend({
      integerOnly: {
        min: 1,
        max: 6
      }
    });
    this.children = ko.observable(0).extend({
      integerOnly: {
        min: 0,
        max: 4
      }
    });
    this.infants = ko.observable(0).extend({
      integerOnly: {
        min: 0,
        max: 3
      }
    });
    this.MAX_TRAVELERS = 9;
    this.children.subscribe(function(newValue) {
      if (newValue > _this.MAX_TRAVELERS - 1) {
        _this.children(_this.MAX_TRAVELERS - 1);
      }
      return _this.balanceTravelers(["adults", 'infants'], _this);
    });
    this.infants.subscribe(function(newValue) {
      if (newValue > _this.adults()) {
        _this.adults(_this.infants());
      }
      return _this.balanceTravelers(["children", 'adults'], _this);
    });
    this.sum_children = ko.computed(function() {
      return _this.children() * 1 + _this.infants() * 1;
    });
    this.overall = ko.computed(function() {
      return _this.adults() * 1 + _this.children() * 1 + _this.infants() * 1;
    });
    this.adults.subscribe(function(newValue) {
      if (_this.infants() > _this.adults()) {
        _this.infants(_this.adults());
      }
      if (newValue > _this.MAX_TRAVELERS) {
        _this.adults(_this.MAX_TRAVELERS);
      }
      return _this.balanceTravelers(["children", 'infants'], _this);
    });
    this.overall.subscribe(function(newValue) {
      return resizePanel();
    });
  }

  /*
    Balances number of travelers, using those which was not affected by most recent user change
  */


  Passengers.prototype.balanceTravelers = function(others, model) {
    var delta, prop, _i, _len, _results;
    if (this.overall() > this.MAX_TRAVELERS) {
      delta = model.overall() - this.MAX_TRAVELERS;
      _results = [];
      for (_i = 0, _len = others.length; _i < _len; _i++) {
        prop = others[_i];
        if (model[prop]() >= delta) {
          model[prop](model[prop]() - delta);
          break;
        } else {
          delta -= model[prop]();
          _results.push(model[prop](0));
        }
      }
      return _results;
    }
  };

  Passengers.prototype.plusOne = function(model, e) {
    var prop;
    prop = $(e.target).attr("rel");
    return model[prop](model[prop]() + 1);
  };

  Passengers.prototype.minusOne = function(model, e) {
    var prop;
    prop = $(e.target).attr("rel");
    return model[prop](model[prop]() - 1);
  };

  return Passengers;

})(PeopleSelector);

Roomers = (function() {

  function Roomers(room, index, length) {
    this.room = room;
    this.index = index;
    this.length = length;
    this.last = __bind(this.last, this);

    this.minusOne = __bind(this.minusOne, this);

    this.plusOne = __bind(this.plusOne, this);

    this.adults = this.room.adults;
    this.children = this.room.children;
    this.ages = this.room.ages;
  }

  Roomers.prototype.plusOne = function(context, event) {
    var target;
    target = $(event.currentTarget).attr('rel');
    return this[target](this[target]() + 1);
  };

  Roomers.prototype.minusOne = function(context, event) {
    var target;
    target = $(event.currentTarget).attr('rel');
    if (this[target]() > 0) {
      return this[target](this[target]() - 1);
    }
  };

  Roomers.prototype.last = function() {
    return this.index + 1 === this.length;
  };

  return Roomers;

})();

HotelPeopleSelector = (function(_super) {

  __extends(HotelPeopleSelector, _super);

  function HotelPeopleSelector(sp) {
    var _this = this;
    this.sp = sp;
    this.removeRoom = __bind(this.removeRoom, this);

    this.addRoom = __bind(this.addRoom, this);

    HotelPeopleSelector.__super__.constructor.apply(this, arguments);
    this.template = 'roomers-template';
    this.rawRooms = this.sp.rooms;
    this.roomsView = ko.computed(function() {
      var current, index, item, r, result, _i, _len, _ref;
      result = [];
      current = [];
      _ref = _this.sp.rooms();
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        item = _ref[index];
        if (current.length === 2) {
          result.push(current);
          current = [];
        }
        r = new Roomers(item, index, _this.sp.rooms().length);
        r.addRoom = _this.addRoom;
        r.removeRoom = _this.removeRoom;
        current.push(r);
      }
      result.push(current);
      return result;
    });
    this.sp.overall.subscribe(resizePanel);
  }

  HotelPeopleSelector.prototype.addRoom = function() {
    if (this.sp.rooms().length === 4) {
      return;
    }
    if (this.sp.overall() > 8) {
      return;
    }
    return this.sp.rooms.push(new SpRoom(this.sp));
  };

  HotelPeopleSelector.prototype.removeRoom = function(roomer) {
    if (this.sp.rooms().length === 1) {
      return;
    }
    return this.sp.rooms.splice(this.sp.rooms.indexOf(roomer.room), 1);
  };

  return HotelPeopleSelector;

})(PeopleSelector);
// Generated by CoffeeScript 1.4.0
var SearchParams;

SearchParams = (function() {

  function SearchParams() {
    this.date = ko.observable('');
  }

  return SearchParams;

})();
// Generated by CoffeeScript 1.4.0

ko.rangeObservable = function(from, to) {
  var result, vm;
  vm = {
    from: ko.observable(from),
    to: ko.observable(to)
  };
  result = ko.computed({
    read: function() {
      return {
        from: this.from(),
        to: this.to()
      };
    },
    write: function(value) {
      var parts;
      parts = value.split(';');
      this.from(+parts[0]);
      return this.to(+parts[1]);
    },
    owner: vm
  });
  return result;
};
// Generated by CoffeeScript 1.4.0
var AviaFiltersT, DistancesFilter, Filter, HotelFiltersT, ListFilter, MaxStopoverFilter, OnlyDirectFilter, PriceFilter, ServiceClassFilter, StarOption, StarsFilter, TextFilter, TimeFilter,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Filter = (function() {

  function Filter() {
    this.setConfig = __bind(this.setConfig, this);

    this.getConfig = __bind(this.getConfig, this);

  }

  Filter.prototype.filter = function(item) {
    throw "override me";
  };

  Filter.prototype.resetLimits = function(item) {};

  Filter.prototype.updateLimits = function(item) {};

  Filter.prototype.get = function(item, key) {
    var value;
    value = ko.utils.unwrapObservable(item[key]);
    if ((typeof value) === 'function') {
      value = value.apply(item);
    }
    return value;
  };

  Filter.prototype.getConfig = function() {
    return this.selection();
  };

  Filter.prototype.setConfig = function(value) {
    return this.selection(value);
  };

  return Filter;

})();

TimeFilter = (function(_super) {

  __extends(TimeFilter, _super);

  function TimeFilter(key) {
    this.key = key;
    this.setConfig = __bind(this.setConfig, this);

    this.filter = __bind(this.filter, this);

    this.limits = ko.rangeObservable(1440, 0);
    this.selection = ko.rangeObservable(0, 1440);
    this.element = false;
    _.extend(this, Backbone.Events);
  }

  TimeFilter.prototype.filter = function(result) {
    return Utils.inRange(this.get(result, this.key), this.selection());
  };

  TimeFilter.prototype.updateLimits = function(item) {
    var limits, value;
    value = this.get(item, this.key);
    limits = this.limits();
    if (value < limits.from) {
      limits.from = value;
    }
    if (value > limits.to) {
      limits.to = value;
    }
    return this.limits(limits.from + ';' + limits.to);
  };

  TimeFilter.prototype.setConfig = function(value) {
    this.selection(value.from + ';' + value.to);
    if (this.element) {
      return this.element.jslider('value', value.from, value.to);
    }
  };

  return TimeFilter;

})(Filter);

PriceFilter = (function(_super) {

  __extends(PriceFilter, _super);

  function PriceFilter(key) {
    this.key = key;
    this.setConfig = __bind(this.setConfig, this);

    this.filter = __bind(this.filter, this);

    this.limits = ko.rangeObservable(999000, 0);
    this.selection = ko.rangeObservable(0, 999000);
    this.element = false;
    _.extend(this, Backbone.Events);
  }

  PriceFilter.prototype.filter = function(result) {
    return Utils.inRange(this.get(result, this.key), this.selection());
  };

  PriceFilter.prototype.updateLimits = function(item) {
    var limits, value;
    value = this.get(item, this.key);
    limits = this.limits();
    if (value < limits.from) {
      limits.from = value;
    }
    if (value > limits.to) {
      limits.to = value;
    }
    return this.limits(limits.from + ';' + limits.to);
  };

  PriceFilter.prototype.setConfig = function(value) {
    this.selection(value.from + ';' + value.to);
    if (this.element) {
      return this.element.jslider('value', value.from, value.to);
    }
  };

  return PriceFilter;

})(Filter);

DistancesFilter = (function(_super) {

  __extends(DistancesFilter, _super);

  function DistancesFilter(key) {
    this.key = key;
    this.setConfig = __bind(this.setConfig, this);

    this.filter = __bind(this.filter, this);

    this.limits = ko.rangeObservable(999000, 0);
    this.selection = ko.observable(999000);
    this.element = false;
    _.extend(this, Backbone.Events);
  }

  DistancesFilter.prototype.filter = function(result) {
    return this.get(result, this.key) <= this.selection();
  };

  DistancesFilter.prototype.updateLimits = function(item) {
    var limits, value;
    value = this.get(item, this.key);
    limits = this.limits();
    if (value < limits.from) {
      limits.from = value;
    }
    if (value > limits.to) {
      limits.to = value;
    }
    return this.limits(limits.from + ';' + limits.to);
  };

  DistancesFilter.prototype.setConfig = function(value) {
    this.selection(value);
    if (this.element) {
      return this.element.jslider('value', value);
    }
  };

  return DistancesFilter;

})(Filter);

ListFilter = (function(_super) {

  __extends(ListFilter, _super);

  function ListFilter(keys, caption, moreLabel) {
    var _this = this;
    this.keys = keys;
    this.caption = caption;
    this.moreLabel = moreLabel;
    this.setConfig = __bind(this.setConfig, this);

    this.getConfig = __bind(this.getConfig, this);

    this.showMore = __bind(this.showMore, this);

    this.reset = __bind(this.reset, this);

    this.filter = __bind(this.filter, this);

    this.options = ko.observableArray();
    this._known = {};
    this.active = ko.computed(function() {
      return _this.options().length > 1;
    });
    this.selection = ko.computed(function() {
      var item, result, _i, _len, _ref;
      result = [];
      _ref = _this.options();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.checked()) {
          result.push(item.key);
        }
      }
      return result;
    });
    _.extend(this, Backbone.Events);
  }

  ListFilter.prototype.addOption = function(value) {
    this._known[value] = 1;
    this.options.remove(function(item) {
      return item.key === value;
    });
    return this.options.unshift({
      key: value,
      checked: ko.observable(0)
    });
  };

  ListFilter.prototype.updateLimits = function(item) {
    var key, propValue, value, values, _i, _len, _ref, _results;
    _ref = this.keys;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      propValue = this.get(item, key);
      if (typeof propValue === 'undefined') {
        continue;
      } else if (typeof propValue !== 'object') {
        values = [];
        values.push(propValue);
      } else {
        values = propValue;
      }
      if (values) {
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
            value = values[_j];
            if (this._known[value]) {
              continue;
            }
            this._known[value] = 1;
            this.options.push({
              key: value,
              checked: ko.observable(0)
            });
            _results1.push(this.options.sort(function(left, right) {
              if (left.key === right.key) {
                return 0;
              }
              if (left.key > right.key) {
                return 1;
              }
              return -1;
            }));
          }
          return _results1;
        }).call(this));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  ListFilter.prototype.filter = function(result) {
    var find, key, propValue, value, values, _i, _j, _len, _len1, _ref, _ref1;
    if (this.selection().length === 0) {
      return true;
    }
    console.log('servFilters', this.selection());
    _ref = this.keys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      propValue = this.get(result, key);
      console.log('servFiltersProp', propValue);
      if (typeof propValue !== 'object') {
        if (this.selection().indexOf(propValue) < 0) {
          return false;
        }
      } else {
        if (propValue) {
          values = propValue;
          find = true;
          _ref1 = this.selection();
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            value = _ref1[_j];
            find = find && (propValue.indexOf(value) >= 0);
          }
          return find;
        } else {
          return false;
        }
      }
    }
    return true;
  };

  ListFilter.prototype.reset = function() {
    var item, _i, _len, _ref, _results;
    _ref = this.options();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(item.checked(false));
    }
    return _results;
  };

  ListFilter.prototype.showMore = function(context, event) {
    var btnText, div, el;
    el = $(event.currentTarget);
    div = el.parent().parent().find('.more-filters');
    if (!(div.css('display') === 'none')) {
      btnText = el.text(el.text().replace("", ""));
      return div.hide('fast', reInitJScrollPane);
    } else {
      btnText = el.text(el.text().replace("", ""));
      return div.show('fast', reInitJScrollPane);
    }
  };

  ListFilter.prototype.getConfig = function() {
    var item, result, _i, _len, _ref;
    result = {};
    _ref = this.options();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      result[item.key] = item.checked();
    }
    return result;
  };

  ListFilter.prototype.setConfig = function(value) {
    var item, _i, _len, _ref, _results;
    _ref = this.options();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(item.checked(value[item.key]));
    }
    return _results;
  };

  return ListFilter;

})(Filter);

StarOption = (function() {

  function StarOption(key) {
    var _this = this;
    this.key = key;
    this.starName = STARS_VERBOSE[this.key - 1];
    this.checked = ko.observable(0);
    this.cls = ko.computed(function() {
      if (_this.checked()) {
        return 'active';
      }
      return '';
    });
  }

  return StarOption;

})();

StarsFilter = (function(_super) {

  __extends(StarsFilter, _super);

  function StarsFilter(keys, caption, moreLabel) {
    var i, _i,
      _this = this;
    this.keys = keys;
    this.caption = caption;
    this.moreLabel = moreLabel;
    this.setConfig = __bind(this.setConfig, this);

    this.getConfig = __bind(this.getConfig, this);

    this.filter = __bind(this.filter, this);

    this.options = ko.observableArray();
    for (i = _i = 1; _i <= 5; i = ++_i) {
      this.options.push(new StarOption(i));
    }
    this.active = ko.computed(function() {
      return _this.options().length > 1;
    });
    this.selection = ko.computed(function() {
      var item, result, _j, _len, _ref;
      result = [];
      _ref = _this.options();
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        item = _ref[_j];
        if (item.checked()) {
          result.push(item.starName);
        }
      }
      return result;
    });
    _.extend(this, Backbone.Events);
  }

  StarsFilter.prototype.updateLimits = function(item) {};

  StarsFilter.prototype.filter = function(result) {
    var key, propValue, _i, _len, _ref;
    if (this.selection().length === 0) {
      return true;
    }
    _ref = this.keys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      propValue = this.get(result, key);
      console.log(this.selection());
      console.log(propValue);
      if (this.selection().indexOf(propValue) < 0) {
        return false;
      }
    }
    return true;
  };

  StarsFilter.prototype.starClick = function() {
    console.log(this);
    if (!$(this).hasClass('active')) {
      return $(this).addClass('active');
    } else {
      return $(this).removeClass('active');
    }
  };

  StarsFilter.prototype.getConfig = function() {
    var item, result, _i, _len, _ref;
    result = {};
    _ref = this.options();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      result[item.starName] = item.checked();
    }
    return result;
  };

  StarsFilter.prototype.setConfig = function(value) {
    var item, _i, _len, _ref, _results;
    _ref = this.options();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(item.checked(value[item.starName]));
    }
    return _results;
  };

  return StarsFilter;

})(Filter);

MaxStopoverFilter = (function(_super) {

  __extends(MaxStopoverFilter, _super);

  function MaxStopoverFilter(value, field) {
    this.value = value;
    this.field = field != null ? field : 'stopoverLength';
    this.filter = __bind(this.filter, this);

    this.selection = ko.observable(0);
  }

  MaxStopoverFilter.prototype.filter = function(item) {
    if (this.selection()) {
      return this.get(item, this.field) <= (60 * 60) * this.value;
    }
    return true;
  };

  return MaxStopoverFilter;

})(Filter);

OnlyDirectFilter = (function(_super) {

  __extends(OnlyDirectFilter, _super);

  function OnlyDirectFilter() {
    this.filter = __bind(this.filter, this);
    this.selection = ko.observable(0);
  }

  OnlyDirectFilter.prototype.filter = function(item) {
    if (+this.selection()) {
      return item.direct;
    }
    return true;
  };

  return OnlyDirectFilter;

})(Filter);

ServiceClassFilter = (function(_super) {

  __extends(ServiceClassFilter, _super);

  function ServiceClassFilter() {
    this.filter = __bind(this.filter, this);
    this.selection = ko.observable('A');
  }

  ServiceClassFilter.prototype.filter = function(item) {
    var lit;
    lit = this.selection();
    if (lit === 'A') {
      return item.serviceClass === 'E';
    } else {
      return item.serviceClass === 'B' || item.serviceClass === 'F';
    }
  };

  return ServiceClassFilter;

})(Filter);

TextFilter = (function(_super) {

  __extends(TextFilter, _super);

  function TextFilter(key, caption) {
    this.key = key;
    this.caption = caption;
    this.keyDown = __bind(this.keyDown, this);

    this.updateResults = __bind(this.updateResults, this);

    this.filter = __bind(this.filter, this);

    this.selection = ko.observable('');
    this.updateTimeout = null;
  }

  TextFilter.prototype.filter = function(item) {
    var expr, lit, result;
    lit = this.selection();
    result = true;
    if (lit !== '') {
      expr = new RegExp(lit, 'ig');
      result = expr.test(item[this.key]);
    }
    return result;
  };

  TextFilter.prototype.updateResults = function() {
    return this.updateTimeout = null;
  };

  TextFilter.prototype.keyDown = function() {
    var _this = this;
    if (this.updateTimeout !== null) {
      window.clearTimeout(this.updateTimeout);
      return this.updateTimeout = window.setTimeout(function() {
        return _this.updateResults();
      }, 1000);
    }
  };

  return TextFilter;

})(Filter);

AviaFiltersT = (function() {

  function AviaFiltersT(results) {
    var fields,
      _this = this;
    this.results = results;
    this.setConfig = __bind(this.setConfig, this);

    this.getConfig = __bind(this.getConfig, this);

    this.iterate = __bind(this.iterate, this);

    this.filter = __bind(this.filter, this);

    this.runFiltersFunc = __bind(this.runFiltersFunc, this);

    this.runFilters = __bind(this.runFilters, this);

    this.filterBackVoyage = __bind(this.filterBackVoyage, this);

    this.filterVoyage = __bind(this.filterVoyage, this);

    this.filterResult = __bind(this.filterResult, this);

    this.updateLimitsBackVoyage = __bind(this.updateLimitsBackVoyage, this);

    this.updateLimitsVoyage = __bind(this.updateLimitsVoyage, this);

    this.updateLimitsResult = __bind(this.updateLimitsResult, this);

    this.template = 'avia-filters';
    this.rt = this.results.roundTrip;
    this.showRt = ko.observable(0);
    this.showRtText = ko.observable('');
    this.showRt.subscribe(function(newValue) {
      if (+newValue) {
        return _this.showRtText('');
      } else {
        return _this.showRtText('');
      }
    });
    this.voyageFilters = ['departure', 'arrival', 'shortStopover', 'irrelevantlyLong', 'onlyDirect'];
    this.rtVoyageFilters = ['rtDeparture', 'rtArrival', 'shortStopover', 'irrelevantlyLong', 'onlyDirect'];
    this.resultFilters = ['departureAirport', 'arrivalAirport', 'airline', 'serviceClass'];
    this.departure = new PriceFilter('departureTimeNumeric');
    this.arrival = new TimeFilter('arrivalTimeNumeric');
    if (this.rt) {
      this.rtDeparture = new TimeFilter('departureTimeNumeric');
      this.rtArrival = new TimeFilter('arrivalTimeNumeric');
    }
    fields = this.rt ? ['departureAirport', 'rtArrivalAirport'] : ['departureAirport'];
    this.departureAirport = new ListFilter(fields, this.results.departureCity, ' ');
    fields = this.rt ? ['arrivalAirport', 'rtDepartureAirport'] : ['arrivalAirport'];
    this.arrivalAirport = new ListFilter(fields, this.results.arrivalCity, ' ');
    this.airline = new ListFilter(['airlineName'], '', ' ');
    this.shortStopover = new MaxStopoverFilter(2.5);
    this.irrelevantlyLong = new MaxStopoverFilter(30, 'maxStopoverLength');
    this.irrelevantlyLong.selection(1);
    this.onlyDirect = new OnlyDirectFilter();
    this.serviceClass = new ServiceClassFilter();
    this.refilter = (ko.computed(function() {
      var key, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      _ref = _this.resultFilters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        _this[key].selection();
      }
      _ref1 = _this.voyageFilters;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        key = _ref1[_j];
        _this[key].selection();
      }
      if (_this.rt) {
        _ref2 = _this.rtVoyageFilters;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          key = _ref2[_k];
          _results.push(_this[key].selection());
        }
        return _results;
      }
    })).extend({
      throttle: 50
    });
    this.refilter.subscribe(this.filter);
    this.iterate(this.updateLimitsResult, this.updateLimitsVoyage, this.updateLimitsBackVoyage);
  }

  AviaFiltersT.prototype.updateLimitsResult = function(result) {
    return this.runFiltersFunc(result, this.resultFilters, 'updateLimits');
  };

  AviaFiltersT.prototype.updateLimitsVoyage = function(voyage) {
    var visible;
    visible = true;
    return this.runFiltersFunc(voyage, this.voyageFilters, 'updateLimits');
  };

  AviaFiltersT.prototype.updateLimitsBackVoyage = function(backVoyage) {
    return this.runFiltersFunc(backVoyage, this.rtVoyageFilters, 'updateLimits');
  };

  AviaFiltersT.prototype.setVisibleIfChanged = function(item, visible) {
    if (item.visible() === visible) {
      return;
    }
    return item.visible(visible);
  };

  AviaFiltersT.prototype.filterResult = function(result) {
    return this.runFilters(result, this.resultFilters);
  };

  AviaFiltersT.prototype.filterVoyage = function(voyage) {
    return this.runFilters(voyage, this.voyageFilters);
  };

  AviaFiltersT.prototype.filterBackVoyage = function(backVoyage) {
    return this.runFilters(backVoyage, this.rtVoyageFilters);
  };

  AviaFiltersT.prototype.runFilters = function(item, filterSet) {
    var filter_key, visible, _i, _len;
    visible = true;
    for (_i = 0, _len = filterSet.length; _i < _len; _i++) {
      filter_key = filterSet[_i];
      visible = visible && this[filter_key].filter(item);
      if (!visible) {
        break;
      }
    }
    return this.setVisibleIfChanged(item, visible);
  };

  AviaFiltersT.prototype.runFiltersFunc = function(item, filterSet, methodName) {
    var filter_key, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = filterSet.length; _i < _len; _i++) {
      filter_key = filterSet[_i];
      _results.push(this[filter_key][methodName](item));
    }
    return _results;
  };

  AviaFiltersT.prototype.filter = function() {
    this.iterate(this.filterResult, this.filterVoyage, this.filterBackVoyage);
    ko.processAllDeferredBindingUpdates();
    return scrollValue('avia', {});
  };

  AviaFiltersT.prototype.iterate = function(onResult, onVoyage, onBackVoyage) {
    var backVoyage, result, voyage, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    _ref = this.results.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      onResult(result);
      _ref1 = result.voyages;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        voyage = _ref1[_j];
        onVoyage(voyage);
        if (this.rt) {
          _ref2 = voyage._backVoyages;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            backVoyage = _ref2[_k];
            onBackVoyage(backVoyage);
          }
          voyage.chooseActive();
        }
      }
      result.chooseActive();
    }
    return this.results.postFilters();
  };

  AviaFiltersT.prototype.getConfig = function() {
    var config, key, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    config = {};
    _ref = this.resultFilters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      config[key] = this[key].getConfig();
    }
    _ref1 = this.voyageFilters;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      key = _ref1[_j];
      config[key] = this[key].getConfig();
    }
    if (this.rt) {
      _ref2 = this.rtVoyageFilters;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        key = _ref2[_k];
        config[key] = this[key].getConfig();
      }
    }
    console.log('getConfig', config);
    return config;
  };

  AviaFiltersT.prototype.setConfig = function(config) {
    var cfg, key, _results;
    console.log('setConfig', config);
    _results = [];
    for (key in config) {
      cfg = config[key];
      _results.push(this[key].setConfig(cfg));
    }
    return _results;
  };

  return AviaFiltersT;

})();

HotelFiltersT = (function() {

  function HotelFiltersT(results) {
    var _this = this;
    this.results = results;
    this.setConfig = __bind(this.setConfig, this);

    this.getConfig = __bind(this.getConfig, this);

    this.iterate = __bind(this.iterate, this);

    this.filter = __bind(this.filter, this);

    this.runFiltersFunc = __bind(this.runFiltersFunc, this);

    this.runFilters = __bind(this.runFilters, this);

    this.filterRoom = __bind(this.filterRoom, this);

    this.filterHotel = __bind(this.filterHotel, this);

    this.updateLimitsRoom = __bind(this.updateLimitsRoom, this);

    this.updateLimitsHotel = __bind(this.updateLimitsHotel, this);

    this.showFullMap = __bind(this.showFullMap, this);

    this.template = 'hotels-filters';
    this.roomFilters = ['price'];
    this.hotelFilters = ['services', 'stars', 'distance', 'hotelName'];
    this.services = new ListFilter(['hotelServices'], '', ' ');
    this.stars = new StarsFilter(['stars'], '', ' ');
    this.price = new PriceFilter('pricePerNight');
    this.distance = new DistancesFilter('distanceToCenter');
    this.hotelName = new TextFilter('hotelName', '  ');
    this.refilter = (ko.computed(function() {
      var key, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = _this.hotelFilters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        _this[key].selection();
      }
      _ref1 = _this.roomFilters;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        key = _ref1[_j];
        _results.push(_this[key].selection());
      }
      return _results;
    })).extend({
      throttle: 50
    });
    this.refilter.subscribe(this.filter);
    this.iterate(this.updateLimitsHotel, this.updateLimitsRoom, false);
    this.services.addOption('');
    this.services.addOption('');
    this.services.addOption('');
  }

  HotelFiltersT.prototype.showFullMap = function() {
    console.log('FM');
    console.log();
    return this.results.showFullMapFunc();
  };

  HotelFiltersT.prototype.updateLimitsHotel = function(result) {
    return this.runFiltersFunc(result, this.hotelFilters, 'updateLimits');
  };

  HotelFiltersT.prototype.updateLimitsRoom = function(roomSet) {
    var visible;
    visible = true;
    return this.runFiltersFunc(roomSet, this.roomFilters, 'updateLimits');
  };

  HotelFiltersT.prototype.setVisibleIfChanged = function(item, visible) {
    if (item.visible() === visible) {
      return;
    }
    return item.visible(visible);
  };

  HotelFiltersT.prototype.filterHotel = function(result) {
    return this.runFilters(result, this.hotelFilters);
  };

  HotelFiltersT.prototype.filterRoom = function(roomSet) {
    return this.runFilters(roomSet, this.roomFilters);
  };

  HotelFiltersT.prototype.runFilters = function(item, filterSet) {
    var filter_key, visible, _i, _len;
    visible = true;
    for (_i = 0, _len = filterSet.length; _i < _len; _i++) {
      filter_key = filterSet[_i];
      visible = visible && this[filter_key].filter(item);
      if (!visible) {
        break;
      }
    }
    return this.setVisibleIfChanged(item, visible);
  };

  HotelFiltersT.prototype.runFiltersFunc = function(item, filterSet, methodName) {
    var filter_key, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = filterSet.length; _i < _len; _i++) {
      filter_key = filterSet[_i];
      _results.push(this[filter_key][methodName](item));
    }
    return _results;
  };

  HotelFiltersT.prototype.filter = function() {
    return this.iterate(this.filterHotel, this.filterRoom);
  };

  HotelFiltersT.prototype.iterate = function(onHotel, onRoom, fromInt) {
    var result, roomSet, someVisible, _i, _j, _len, _len1, _ref, _ref1;
    if (fromInt == null) {
      fromInt = true;
    }
    _ref = this.results.data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      onHotel(result);
      if (result.visible()) {
        someVisible = false;
        _ref1 = result.roomSets();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          roomSet = _ref1[_j];
          onRoom(roomSet);
          someVisible = someVisible || roomSet.visible();
        }
        result.visible(someVisible);
      }
    }
    return this.results.postFilters(true);
  };

  HotelFiltersT.prototype.getConfig = function() {
    var config, key, _i, _j, _len, _len1, _ref, _ref1;
    config = {};
    _ref = this.hotelFilters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      config[key] = this[key].getConfig();
    }
    _ref1 = this.roomFilters;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      key = _ref1[_j];
      config[key] = this[key].getConfig();
    }
    console.log('getConfig', config);
    return config;
  };

  HotelFiltersT.prototype.setConfig = function(config) {
    var cfg, key, _results;
    console.log('setConfig', config);
    _results = [];
    for (key in config) {
      cfg = config[key];
      _results.push(this[key].setConfig(cfg));
    }
    return _results;
  };

  return HotelFiltersT;

})();
// Generated by CoffeeScript 1.4.0
var SearchPanel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

SearchPanel = (function() {

  function SearchPanel(hideCalendar, fromTourPanel) {
    var _this = this;
    if (hideCalendar == null) {
      hideCalendar = true;
    }
    if (fromTourPanel == null) {
      fromTourPanel = false;
    }
    this.afterRender = __bind(this.afterRender, this);

    this.handlePanelSubmit = __bind(this.handlePanelSubmit, this);

    this.showCalendar = __bind(this.showCalendar, this);

    this.minimizeCalendar = __bind(this.minimizeCalendar, this);

    this.minimize = __bind(this.minimize, this);

    this.toggleCalendar = __bind(this.toggleCalendar, this);

    this.togglePanel = __bind(this.togglePanel, this);

    this.minimized = ko.observable(!hideCalendar);
    this.minimizedCalendar = ko.observable(hideCalendar);
    this.calendarHidden = ko.observable(this.minimizedCalendar);
    this.calendarShadow = ko.observable(this.minimizedCalendar);
    this.prevSearchPanel = ko.observable(null);
    this.nextSearchPanel = ko.observable(null);
    this.aPanelId = Math.floor(Math.random() * 10000);
    this.oldCalendarState = this.minimizedCalendar();
    this.togglePanel(this.minimized(), fromTourPanel);
    this.toggleCalendar(this.minimizedCalendar(), true);
    this.toggleSubscribers = this.minimized.subscribe(function(minimized) {
      return _this.togglePanel(minimized);
    });
    this.minimizedCalendar.subscribe(function(minimizedCalendar) {
      return _this.toggleCalendar(minimizedCalendar);
    });
  }

  SearchPanel.prototype.togglePanel = function(minimized, fromTourPanel) {
    var heightSubHead, speed;
    if (fromTourPanel == null) {
      fromTourPanel = false;
    }
    if (!fromTourPanel) {
      speed = 300;
      heightSubHead = $('.sub-head').height();
      if (!minimized) {
        return $('.sub-head').animate({
          'margin-top': '0px'
        }, speed);
      } else {
        return $('.sub-head').animate({
          'margin-top': '-' + (heightSubHead - 4) + 'px'
        }, speed);
      }
    }
  };

  SearchPanel.prototype.toggleCalendar = function(minimizedCalendar, initialize) {
    var heightCalendar1, heightCalendar2, heightSubHead, speed,
      _this = this;
    if (initialize == null) {
      initialize = false;
    }
    speed = 500;
    heightSubHead = $('.sub-head').height();
    heightCalendar1 = $('.calenderWindow').height();
    heightCalendar2 = heightSubHead;
    if (!minimizedCalendar) {
      this.calendarHidden(false);
      if (!initialize) {
        ResizeAvia();
        $('.calenderWindow .calendarSlide').animate({
          'top': '0px'
        });
        return $('.calenderWindow').animate({
          'height': '341px'
        }, speed);
      }
    } else {
      this.calendarShadow(true);
      if (!initialize) {
        ResizeAvia();
        this.calendarShadow(true);
        $('.calenderWindow .calendarSlide').animate({
          'top': '-341px'
        });
        return $('.calenderWindow').animate({
          'height': '0px'
        }, speed, function() {
          _this.calendarHidden(true);
          return _this.calendarShadow(false);
        });
      } else {
        this.calendarHidden(true);
        return this.calendarShadow(false);
      }
    }
  };

  SearchPanel.prototype.minimize = function() {
    if (this.minimized()) {
      this.minimized(false);
      return this.minimizedCalendar(this.oldCalendarState);
    } else {
      this.minimized(true);
      this.oldCalendarState = this.minimizedCalendar();
      if (!this.minimizedCalendar()) {
        return this.minimizedCalendar(true);
      }
    }
  };

  SearchPanel.prototype.minimizeCalendar = function() {
    if (this.minimizedCalendar()) {
      return this.minimizedCalendar(false);
    } else {
      return this.minimizedCalendar(true);
    }
  };

  SearchPanel.prototype.showCalendar = function() {
    $('.calenderWindow').show();
    if (this.minimizedCalendar()) {
      return this.minimizedCalendar(false);
    }
  };

  SearchPanel.prototype.handlePanelSubmit = function() {
    app.navigate(this.sp.getHash(), {
      trigger: true
    });
    return this.minimizedCalendar(true);
  };

  SearchPanel.prototype.afterRender = function() {
    throw "Implement me";
  };

  return SearchPanel;

})();
// Generated by CoffeeScript 1.4.0
var _this = this;

ko.bindingHandlers.autocomplete = {
  init: function(element, valueAccessor) {
    var showCode,
      _this = this;
    showCode = (valueAccessor().showCode === undefined ? valueAccessor().showCode : true);
    setTimeout(function() {
      $(element).bind("focus", function() {
        return $(element).change();
      });
      return $(element).autocomplete({
        serviceUrl: "http://api.voyanga.com/v1/helper/autocomplete/" + valueAccessor().source,
        minChars: 2,
        delimiter: /(,|;)\s*/,
        maxHeight: 400,
        zIndex: 9999,
        deferRequestBy: 0,
        delay: 0,
        showCode: showCode,
        onSelect: function(value, data) {
          valueAccessor().iata(data.code);
          valueAccessor().readable(data.name);
          valueAccessor().readableGen(data.nameGen);
          valueAccessor().readableAcc(data.nameAcc);
          $(element).val(data.name);
          return $(element).siblings('input.input-path').val(value);
        },
        onActivate: function(value, data) {
          valueAccessor().readable(data.name);
          valueAccessor().readableGen(data.nameGen);
          valueAccessor().readableAcc(data.nameAcc);
          $(element).val(data.name);
          return $(element).siblings('input.input-path').val(value);
        }
      });
    }, 500);
    return $(element).on("keyup", function(e) {
      if ((e.keyCode === 8) || (e.keyCode === 46)) {
        valueAccessor().iata('');
        valueAccessor().readable('');
        valueAccessor().readableGen('');
        return valueAccessor().readableAcc('');
      }
    });
  },
  update: function(element, valueAccessor) {
    var handleResults, iataCode, url;
    iataCode = valueAccessor().iata();
    url = function(code) {
      var params, result;
      result = 'http://api.voyanga.com/v1/helper/autocomplete/citiesReadable?';
      params = [];
      params.push('codes[0]=' + code);
      result += params.join("&");
      return result;
    };
    handleResults = function(data) {
      valueAccessor().readable(data[iataCode].name);
      valueAccessor().readableGen(data[iataCode].nameGen);
      valueAccessor().readableAcc(data[iataCode].nameAcc);
      $(element).val(data[iataCode].name);
      return $(element).siblings('input.input-path').val(data[iataCode].label);
    };
    if (iataCode.length > 0) {
      return $.ajax({
        url: url(iataCode),
        dataType: 'jsonp',
        success: handleResults
      });
    }
  }
};
// Generated by CoffeeScript 1.4.0
var API, AviaAPI, HotelsAPI, ToursAPI,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

API = (function() {

  function API() {
    this.call = __bind(this.call, this);
    this.endpoint = 'http://api.voyanga.com/v1/';
  }

  API.prototype.call = function(url, cb, showLoad) {
    var _this = this;
    if (showLoad == null) {
      showLoad = true;
    }
    if (showLoad) {
      $('#loadWrapBg').show();
      loaderChange(true);
    }
    return $.ajax({
      url: "" + this.endpoint + url,
      dataType: 'jsonp',
      timeout: 90000,
      success: function(data) {
        cb(data);
        if (showLoad) {
          $('#loadWrapBg').hide();
          return loaderChange(false);
        }
      },
      error: function() {
        console.log("ERROR");
        if (showLoad) {
          $('#loadWrapBg').hide();
          loaderChange(false);
        }
        return cb(false);
      }
    });
  };

  return API;

})();

ToursAPI = (function(_super) {

  __extends(ToursAPI, _super);

  function ToursAPI() {
    this.search = __bind(this.search, this);
    return ToursAPI.__super__.constructor.apply(this, arguments);
  }

  ToursAPI.prototype.search = function(url, cb) {
    return this.call(url, function(data) {
      return cb(data);
    });
  };

  return ToursAPI;

})(API);

AviaAPI = (function(_super) {

  __extends(AviaAPI, _super);

  function AviaAPI() {
    this.search = __bind(this.search, this);
    return AviaAPI.__super__.constructor.apply(this, arguments);
  }

  AviaAPI.prototype.search = function(url, cb) {
    return this.call(url, function(data) {
      return cb(data);
    });
  };

  return AviaAPI;

})(API);

HotelsAPI = (function(_super) {

  __extends(HotelsAPI, _super);

  function HotelsAPI() {
    this.search = __bind(this.search, this);
    return HotelsAPI.__super__.constructor.apply(this, arguments);
  }

  HotelsAPI.prototype.search = function(url, cb, showLoad) {
    if (showLoad == null) {
      showLoad = true;
    }
    return this.call(url, function(data) {
      return cb(data);
    }, showLoad);
  };

  return HotelsAPI;

})(API);
// Generated by CoffeeScript 1.4.0

Socialite.setup({
  facebook: {
    lang: "ru",
    appId: 463273800404070,
    onlike: function(url) {},
    onunlike: function(url) {},
    onsend: function(url) {}
  }
});

Socialite.setup({
  vkontakte: {
    apiId: 3377254,
    group: {
      id: 0,
      mode: 0,
      width: 300,
      height: 290
    },
    like: {
      type: "mini"
    }
  }
});

$(function() {
  var html;
  html = $('#socialSource').html();
  $('#socialSource').empty();
  $('.shareSocial').html(html);
  return Socialite.load($('#social'));
});
// Generated by CoffeeScript 1.4.0
var AviaPanel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

AviaPanel = (function(_super) {

  __extends(AviaPanel, _super);

  function AviaPanel() {
    this.afterRender = __bind(this.afterRender, this);

    this.handlePanelSubmit = __bind(this.handlePanelSubmit, this);

    this.selectRoundTrip = __bind(this.selectRoundTrip, this);

    this.selectOneWay = __bind(this.selectOneWay, this);

    this.setDate = __bind(this.setDate, this);

    var _this = this;
    AviaPanel.__super__.constructor.call(this);
    this.prevPanel = 'tours';
    this.nextPanel = 'hotels';
    this.mainLabel = ' ';
    this.icon = 'fly-ico';
    this.template = 'avia-panel-template';
    this.sp = new AviaSearchParams();
    this.passengers = this.sp.passengers;
    this.departureDate = this.sp.date;
    this.departureCity = this.sp.dep;
    this.departureCityReadable = ko.observable('');
    this.departureCityReadableGen = ko.observable('');
    this.departureCityReadableAcc = ko.observable('');
    this.rt = this.sp.rt;
    this.rtDate = this.sp.rtDate;
    this.arrivalCity = this.sp.arr;
    this.arrivalCityReadable = ko.observable('');
    this.arrivalCityReadableGen = ko.observable('');
    this.arrivalCityReadableAcc = ko.observable('');
    this.prefixText = ' <br>500+ ';
    this.oldCalendarState = this.minimizedCalendar();
    this.show = this.passengers.show;
    this.fromChosen = ko.computed(function() {
      if (_this.departureDate().getDay) {
        return true;
      }
      return _this.departureDate().length > 0;
    });
    this.rtFromChosen = ko.computed(function() {
      if (!_this.rt()) {
        return false;
      }
      if (_this.rtDate().getDay) {
        return true;
      }
      return _this.rtDate().length > 0;
    });
    this.formFilled = ko.computed(function() {
      var result;
      result = _this.departureCity() && _this.arrivalCity() && _this.fromChosen();
      if (_this.rt()) {
        result = result && _this.rtFromChosen();
      }
      return result;
    });
    this.formNotFilled = ko.computed(function() {
      return !_this.formFilled();
    });
    this.maximizedCalendar = ko.computed(function() {
      return _this.departureCity() && _this.arrivalCity();
    });
    this.maximizedCalendar.subscribe(function(newValue) {
      if (!newValue) {
        return;
      }
      if (_this.rt() && !_this.rtFromChosen()) {
        _this.showCalendar();
        return;
      }
      if (!_this.fromChosen()) {
        _this.showCalendar();
      }
    });
    this.calendarValue = ko.computed(function() {
      return {
        twoSelect: _this.rt(),
        from: _this.departureDate(),
        to: _this.rtDate(),
        hotels: false,
        activeSearchPanel: _this
      };
    });
    this.departureDateDay = ko.computed(function() {
      return dateUtils.formatDay(_this.departureDate());
    });
    this.departureDateMonth = ko.computed(function() {
      return dateUtils.formatMonth(_this.departureDate());
    });
    this.rtDateDay = ko.computed(function() {
      return dateUtils.formatDay(_this.rtDate());
    });
    this.rtDateMonth = ko.computed(function() {
      return dateUtils.formatMonth(_this.rtDate());
    });
    this.rt.subscribe(this.rtTumbler);
    this.rtTumbler(this.rt());
    $('.how-many-man .btn');
    this.calendarText = ko.computed(function() {
      var arrow, result;
      result = "   ";
      if (_this.rt()) {
        arrow = '  ';
      } else {
        arrow = '  ';
      }
      if ((_this.departureCityReadable().length > 0) && (_this.arrivalCityReadable().length > 0)) {
        result += _this.departureCityReadable() + arrow + _this.arrivalCityReadable();
      } else if ((_this.departureCityReadable().length === 0) && (_this.arrivalCityReadable().length > 0)) {
        result += '  ' + _this.arrivalCityReadableAcc();
      } else if ((_this.departureCityReadable().length > 0) && (_this.arrivalCityReadable().length === 0)) {
        result += '  ' + _this.departureCityReadableGen();
      }
      return result;
    });
  }

  AviaPanel.prototype.rtTumbler = function(newValue) {
    if (newValue) {
      return $('.tumblr .switch').animate({
        'left': '35px'
      }, 200);
    } else {
      return $('.tumblr .switch').animate({
        'left': '-1px'
      }, 200);
    }
  };

  AviaPanel.prototype.setDate = function(values) {
    if (values.length) {
      this.departureDate(values[0]);
      if (this.rt && values.length > 1) {
        if (values[1] > values[0]) {
          return this.rtDate(values[1]);
        } else {
          return this.rtDate('');
        }
      }
    }
  };

  /*
    # Click handlers
  */


  AviaPanel.prototype.selectOneWay = function() {
    return this.rt(false);
  };

  AviaPanel.prototype.selectRoundTrip = function() {
    return this.rt(true);
  };

  AviaPanel.prototype.handlePanelSubmit = function() {
    app.navigate(this.sp.getHash(), {
      trigger: true
    });
    return this.minimizedCalendar(true);
  };

  AviaPanel.prototype.navigateToNewSearch = function() {
    if (this.formNotFilled()) {
      return;
    }
    this.handlePanelSubmit();
    return this.minimizedCalendar(true);
  };

  AviaPanel.prototype.returnRecommend = function(context, event) {
    $('.recomended-content').slideDown();
    $('.order-hide').fadeIn();
    return $(event.currentTarget).animate({
      top: '-19px'
    }, 500, null, function() {
      return ResizeAvia();
    });
  };

  AviaPanel.prototype.afterRender = function() {
    var _this = this;
    $(function() {
      _this.sp.passengers.afterRender();
      _this.rtTumbler(_this.rt());
      return $('.how-many-man .btn');
    });
    return resizePanel();
  };

  return AviaPanel;

})(SearchPanel);

$(document).on("autocompleted", "input.departureCity", function() {
  return $('input.arrivalCity.second-path').focus();
});

$(document).on("keyup change", "input.second-path", function(e) {
  var firstValue, secondEl;
  firstValue = $(this).val();
  secondEl = $(this).siblings('input.input-path');
  if ((e.keyCode === 8) || (firstValue.length < 3)) {
    return secondEl.val('');
  }
});
// Generated by CoffeeScript 1.4.0
var Sibling, Siblings,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Sibling = (function() {

  function Sibling(graphHeight, parent, price, date, isActive) {
    var _this = this;
    this.graphHeight = graphHeight;
    this.parent = parent;
    this.price = price;
    if (isActive == null) {
      isActive = false;
    }
    this.rawDate = date;
    this.date = date.format('D');
    this.dow = date.format('dd');
    this.month = date.format('MMM');
    this.data = [];
    this.nodata = false;
    this.isActive = ko.observable(isActive);
    this.initialActive = isActive;
    if (this.price !== false) {
      if (this.parent.price) {
        this.price = this.price * 2 - this.parent.price;
      }
    }
    this.scaledHeight = ko.computed(function() {
      var ratio, spacing;
      if (_this.price === false) {
        return 0;
      }
      spacing = 10;
      ratio = _this.height / _this.absDelta;
      ratio = ratio * 0.6;
      if (isNaN(ratio)) {
        ratio = 0;
      }
      if (ratio > 0) {
        if (ratio < 0.1) {
          console.error(_this.height, _this.absDelta, _this.price);
        }
      }
      return ratio * (_this.graphHeight() - spacing) + spacing - 10;
    });
  }

  Sibling.prototype.columnValue = function() {
    return this.price;
  };

  Sibling.prototype.background = function() {
    if (this.nodata) {
      return "center " + this.graphHeight() + "px";
    }
    return "center " + this.scaledHeight() + "px";
  };

  return Sibling;

})();

Siblings = (function() {

  function Siblings(siblings, roundTrip, todayDate, rtTodayDate) {
    this.roundTrip = roundTrip;
    this.populate = __bind(this.populate, this);

    this.search = __bind(this.search, this);

    this.handleSearch = __bind(this.handleSearch, this);

    this.priceDisplay = __bind(this.priceDisplay, this);

    this.showPrice = __bind(this.showPrice, this);

    this.showControls = __bind(this.showControls, this);

    this.select = __bind(this.select, this);

    this.data = [];
    this.graphHeight = ko.observable(50);
    this.populate(this, siblings, todayDate, rtTodayDate);
    this.active = ko.observable(this.data[3]);
    this.selection = ko.observable(false);
  }

  Siblings.prototype.select = function(sibling) {
    var entry, sib, _i, _j, _len, _len1, _ref, _ref1;
    if (sibling.data.length) {
      this.active(sibling);
      _ref = sibling.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sib = _ref[_i];
        if (sib.isActive()) {
          this.selection(sib);
          break;
        }
      }
    } else {
      this.selection(sibling);
    }
    _ref1 = sibling.parent.data;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      entry = _ref1[_j];
      entry.isActive(false);
    }
    return sibling.isActive(true);
  };

  Siblings.prototype.showControls = function() {
    if (!this.selection()) {
      return false;
    }
    if (this.active().initialActive && this.selection().initialActive) {
      return false;
    }
    return true;
  };

  Siblings.prototype.showPrice = function() {
    if (!this.selection()) {
      return false;
    }
    if (this.active().nodata || this.selection().nodata) {
      return false;
    }
    return true;
  };

  Siblings.prototype.priceDisplay = function() {
    if (!this.showPrice()) {
      return '';
    }
    if (this.roundTrip) {
      return this.active().price + this.selection().price;
    } else {
      return this.selection().price;
    }
  };

  Siblings.prototype.handleSearch = function(date, rtDate) {
    var app, panel;
    if (rtDate == null) {
      rtDate = false;
    }
    app = window.app;
    panel = app.fakoPanel();
    panel.sp.date(date.toDate());
    if (rtDate !== false) {
      panel.sp.rtDate(rtDate.toDate());
    }
    return app.navigate(panel.sp.getHash(), {
      trigger: true
    });
  };

  Siblings.prototype.search = function() {
    if (this.roundTrip) {
      this.handleSearch(this.active().rawDate, this.selection().rawDate);
      return;
    }
    return this.handleSearch(this.selection().rawDate);
  };

  Siblings.prototype.populate = function(root, siblings, todayDate, rtTodayDate) {
    var absDelta, date, index, isActive, item, maxPrice, minPrice, newsib, prevMonth, showMonth, sib, siblingPrice, todayPrice, _i, _j, _len, _len1, _ref, _results;
    todayPrice = _.filter(siblings, function(item) {
      return item.price !== false;
    });
    if (todayPrice.length === 0) {
      todayPrice = 1;
    } else {
      todayPrice = todayPrice[0].price;
    }
    for (index = _i = 0, _len = siblings.length; _i < _len; index = ++_i) {
      sib = siblings[index];
      siblingPrice = sib.price;
      date = todayDate.clone().subtract('days', 3 - index);
      showMonth = false;
      if (index === 0) {
        showMonth = true;
        prevMonth = date.month();
      }
      if (prevMonth !== date.month()) {
        showMonth = true;
        prevMonth = date.month();
      }
      if (index === 3) {
        isActive = true;
      } else {
        isActive = false;
      }
      newsib = new Sibling(this.graphHeight, root, siblingPrice, date, isActive);
      if (sib.price === false) {
        newsib.nodata = true;
      }
      newsib.showMonth = showMonth;
      root.data.push(newsib);
      if (sib.siblings.length) {
        this.populate(newsib, sib.siblings, rtTodayDate);
      }
    }
    minPrice = _.min(root.data, function(item) {
      if (item.price === false) {
        return todayPrice;
      } else {
        return item.price;
      }
    });
    maxPrice = _.max(root.data, function(item) {
      if (item.price === false) {
        return todayPrice;
      } else {
        return item.price;
      }
    });
    if (maxPrice.price === false) {
      maxPrice = {
        price: todayPrice
      };
    }
    if (minPrice.price === false) {
      minPrice = {
        price: todayPrice
      };
    }
    absDelta = maxPrice.price - minPrice.price;
    _ref = root.data;
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      item = _ref[_j];
      if (item.price === false) {
        item.height = 0;
      } else {
        item.height = maxPrice.price - item.price;
      }
      _results.push(item.absDelta = absDelta);
    }
    return _results;
  };

  return Siblings;

})();
// Generated by CoffeeScript 1.4.0
var AviaResult, AviaResultSet, AviaSearchParams, FlightPart, Voyage,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

FlightPart = (function() {

  function FlightPart(part) {
    this.part = part;
    this.departureDate = new Date(part.datetimeBegin + '+04:00');
    this.arrivalDate = new Date(part.datetimeEnd + '+04:00');
    this.departureCity = part.departureCity;
    this.departureCityPre = part.departureCityPre;
    this.departureAirport = part.departureAirport;
    this.aircraftName = part.aircraftName;
    this.arrivalCity = part.arrivalCity;
    this.arrivalCityPre = part.arrivalCityPre;
    this.arrivalAirport = part.arrivalAirport;
    this._duration = part.duration;
    this.transportAirline = part.transportAirline;
    this.transportAirlineName = part.transportAirlineNameEn;
    this.markAirline = part.markAirline;
    this.markAirlineName = part.markAirlineNameEn;
    this.flightCode = part.markAirline + ' ' + part.flightCode;
    this.stopoverLength = 0;
  }

  FlightPart.prototype.departureTime = function() {
    return dateUtils.formatTime(this.departureDate);
  };

  FlightPart.prototype.arrivalTime = function() {
    return dateUtils.formatTime(this.arrivalDate);
  };

  FlightPart.prototype.duration = function() {
    return dateUtils.formatDuration(this._duration);
  };

  FlightPart.prototype.departureCityStopoverText = function() {
    return "  " + this.departureCityPre + ", " + this.stopoverText();
  };

  FlightPart.prototype.calculateStopoverLength = function(anotherPart) {
    return this.stopoverLength = Math.floor((anotherPart.departureDate.getTime() - this.arrivalDate.getTime()) / 1000);
  };

  FlightPart.prototype.stopoverText = function() {
    return dateUtils.formatDuration(this.stopoverLength);
  };

  return FlightPart;

})();

Voyage = (function() {

  function Voyage(flight, airline) {
    var index, part, _i, _j, _len, _len1, _ref, _ref1;
    this.airline = airline;
    this.parts = [];
    _ref = flight.flightParts;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      this.parts.push(new FlightPart(part));
    }
    this.flightKey = flight.flightKey;
    this.hasStopover = this.stopoverCount > 1 ? true : false;
    this.stopoverLength = 0;
    this.maxStopoverLength = 0;
    this.direct = this.parts.length === 1;
    if (!this.direct) {
      _ref1 = this.parts;
      for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
        part = _ref1[index];
        if (index < (this.parts.length - 1)) {
          part.calculateStopoverLength(this.parts[index + 1]);
        }
        this.stopoverLength += part.stopoverLength;
        if (part.stopoverLength > this.maxStopoverLength) {
          this.maxStopoverLength = part.stopoverLength;
        }
      }
    }
    this.departureDate = new Date(flight.departureDate + '+04:00');
    this.arrivalDate = new Date(this.parts[this.parts.length - 1].arrivalDate);
    this._duration = flight.fullDuration;
    this.departureAirport = this.parts[0].departureAirport;
    this.arrivalAirport = this.parts[this.parts.length - 1].arrivalAirport;
    this.departureCity = flight.departureCity;
    this.arrivalCity = flight.arrivalCity;
    this.departureCityPre = flight.departureCityPre;
    this.arrivalCityPre = flight.arrivalCityPre;
    this._backVoyages = [];
    this.activeBackVoyage = ko.observable();
    this.visible = ko.observable(true);
  }

  Voyage.prototype.departureInt = function() {
    return this.departureDate.getTime();
  };

  Voyage.prototype.hash = function() {
    return this.departureTime() + this.arrivalTime();
  };

  Voyage.prototype.similarityHash = function() {
    return this.hash() + this.airline;
  };

  Voyage.prototype.push = function(voyage) {
    return this._backVoyages.push(voyage);
  };

  Voyage.prototype.stacked = function() {
    var count, result, voyage, _i, _len, _ref;
    result = false;
    count = 0;
    _ref = this._backVoyages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      voyage = _ref[_i];
      if (voyage.visible()) {
        count++;
      }
      if (count > 1) {
        result = true;
        break;
      }
    }
    return result;
  };

  Voyage.prototype.departureDayMo = function() {
    return dateUtils.formatDayMonth(this.departureDate);
  };

  Voyage.prototype.departurePopup = function() {
    return dateUtils.formatDayMonthWeekday(this.departureDate);
  };

  Voyage.prototype.departureTime = function() {
    return dateUtils.formatTime(this.departureDate);
  };

  Voyage.prototype.departureTimeNumeric = function() {
    return dateUtils.formatTimeInMinutes(this.departureDate);
  };

  Voyage.prototype.arrivalDayMo = function() {
    return dateUtils.formatDayMonth(this.arrivalDate);
  };

  Voyage.prototype.arrivalTime = function() {
    return dateUtils.formatTime(this.arrivalDate);
  };

  Voyage.prototype.arrivalTimeNumeric = function() {
    return dateUtils.formatTimeInMinutes(this.arrivalDate);
  };

  Voyage.prototype.duration = function() {
    return dateUtils.formatDuration(this._duration);
  };

  Voyage.prototype.stopoverText = function() {
    var part, result, _i, _len, _ref;
    if (this.direct) {
      return " ";
    }
    result = [];
    if (this.parts.length === 2) {
      part = this.parts[0];
      return "  " + part.arrivalCityPre + ", " + this.parts[0].stopoverText();
    }
    _ref = this.parts.slice(0, -1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      result.push(part.arrivalCityPre);
    }
    return "  " + result.join(', ');
  };

  Voyage.prototype.stopoverRelText = function() {
    var part, result, _i, _len, _ref;
    if (this.direct) {
      return " ";
    }
    result = [];
    _ref = this.parts.slice(0, -1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      result.push('  ' + part.arrivalCityPre + ', ' + part.stopoverText());
    }
    return result.join('<br />');
  };

  Voyage.prototype.stopsRatio = function() {
    var data, duration, htmlResult, index, part, result, _i, _j, _k, _len, _len1, _len2, _ref;
    result = [];
    if (this.direct) {
      return '<span class="down"></span>';
    }
    duration = _.reduce(this.parts, function(memo, part) {
      return memo + part._duration;
    }, 0);
    _ref = this.parts.slice(0, -1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      result.push({
        left: Math.ceil(part._duration / duration * 80),
        part: part
      });
    }
    for (index = _j = 0, _len1 = result.length; _j < _len1; index = ++_j) {
      data = result[index];
      if (data.left < 18) {
        data.left = 18;
      }
      if (index > 0) {
        result[index].left = result[index - 1].left + data.left;
      } else {
        result[index].left = data.left;
      }
    }
    htmlResult = "";
    for (_k = 0, _len2 = result.length; _k < _len2; _k++) {
      data = result[_k];
      htmlResult += this.getCupHtmlForPart(data.part, "left: " + data.left + '%');
    }
    htmlResult += '<span class="down"></span>';
    return htmlResult;
  };

  Voyage.prototype.stopoverHtml = function() {
    var htmlResult, part, _i, _len, _ref;
    if (this.direct) {
      return '<span class="path"></span>';
    }
    htmlResult = '';
    _ref = this.parts.slice(0, -1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      console.log(part);
      if (part.stopoverLength > 0) {
        htmlResult += this.getCupHtmlForPart(part);
      }
    }
    return htmlResult;
  };

  Voyage.prototype.getCupHtmlForPart = function(part, style) {
    var cupClass;
    if (style == null) {
      style = "";
    }
    cupClass = part.stopoverLength < 2.5 * 60 * 60 ? "cup" : "cup long";
    return '<span class="' + cupClass + ' tooltip" rel="  ' + part.arrivalCityPre + ', ' + part.stopoverText() + '" style="' + style + '"></span>';
  };

  Voyage.prototype.recommendStopoverIco = function() {
    if (this.direct) {
      return;
    }
    return '<span class="cup"></span>';
  };

  Voyage.prototype.sort = function() {
    this._backVoyages.sort(function(a, b) {
      return a.departureInt() - b.departureInt();
    });
    return this.activeBackVoyage(this._backVoyages[0]);
  };

  Voyage.prototype.removeSimilar = function() {
    var item, key, voyage, _helper, _i, _len, _ref;
    if (this._backVoyages.length < 2) {
      return;
    }
    _helper = {};
    _ref = this._backVoyages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      voyage = _ref[_i];
      key = voyage.airline + voyage.departureInt();
      item = _helper[key];
      if (item) {
        _helper[key] = item.stopoverLength < voyage.stopoverLength ? item : voyage;
      } else {
        _helper[key] = voyage;
      }
    }
    this._backVoyages = [];
    for (key in _helper) {
      item = _helper[key];
      this._backVoyages.push(item);
    }
    return this.activeBackVoyage(this._backVoyages[0]);
  };

  Voyage.prototype.chooseActive = function() {
    var active;
    if (this._backVoyages.length === 0) {
      return;
    }
    if (this.activeBackVoyage().visible()) {
      return;
    }
    active = _.find(this._backVoyages, function(voyage) {
      return voyage.visible();
    });
    if (!active) {
      this.visible(false);
      return;
    }
    return this.activeBackVoyage(active);
  };

  return Voyage;

})();

AviaResult = (function() {

  function AviaResult(data, parent) {
    var fields, flights, name, rtName, _i, _len,
      _this = this;
    this.parent = parent;
    this.getPostData = __bind(this.getPostData, this);

    this.getParams = __bind(this.getParams, this);

    this.directRating = __bind(this.directRating, this);

    this.chooseActive = __bind(this.chooseActive, this);

    this.showDetails = __bind(this.showDetails, this);

    this.minimizeRtStacked = __bind(this.minimizeRtStacked, this);

    this.minimizeStacked = __bind(this.minimizeStacked, this);

    this.chooseNextRtStacked = __bind(this.chooseNextRtStacked, this);

    this.choosePrevRtStacked = __bind(this.choosePrevRtStacked, this);

    this.chooseRtStacked = __bind(this.chooseRtStacked, this);

    this.chooseNextStacked = __bind(this.chooseNextStacked, this);

    this.choosePrevStacked = __bind(this.choosePrevStacked, this);

    this.chooseStacked = __bind(this.chooseStacked, this);

    this.rtFlightCodes = __bind(this.rtFlightCodes, this);

    this.flightCodes = __bind(this.flightCodes, this);

    this.flightKey = __bind(this.flightKey, this);

    this.rtServiceClass = __bind(this.rtServiceClass, this);

    this.rtFlightCodesText = __bind(this.rtFlightCodesText, this);

    this.isFlight = true;
    this.isHotel = false;
    _.extend(this, Backbone.Events);
    this._data = data;
    this._stacked_data = [];
    flights = data.flights;
    this.searchId = data.searchId;
    this.cacheId = data.cacheId;
    this.key = data.key;
    this.pdfLink = '/buy/pdf/id/' + this.key;
    this.price = Math.ceil(data.price);
    this._stacked = false;
    if (!flights) {
      console.log('data', data);
    }
    this.roundTrip = flights.length === 2;
    this.visible = ko.observable(true);
    this.airline = data.valCompany;
    this.searchService = data.service;
    this.airlineName = data.valCompanyNameEn;
    this.serviceClass = data.serviceClass;
    this.serviceClassReadable = data.serviceClass === 'E' ? '' : '';
    this.refundable = data.refundable;
    this.refundableText = this.refundable ? " " : "  ";
    this.freeWeight = data.freeWeight;
    if (this.freeWeight === '0') {
      this.freeWeight = '$';
    }
    this.freeWeightText = data.freeWeightDescription;
    flights[0].flightKey = data.flightKey;
    this.activeVoyage = new Voyage(flights[0], this.airline);
    if (this.roundTrip) {
      flights[1].flightKey = data.flightKey;
      this.activeVoyage.push(new Voyage(flights[1], this.airline));
    }
    this.voyages = [];
    this.voyages.push(this.activeVoyage);
    this.activeVoyage = ko.observable(this.activeVoyage);
    this.stackedMinimized = ko.observable(true);
    this.rtStackedMinimized = ko.observable(true);
    this.flightCodesText = _.size(this.activeVoyage().parts) > 1 ? "" : "";
    this.totalPeople = 0;
    fields = ['departureCity', 'departureAirport', 'departureDayMo', 'departureDate', 'departurePopup', 'departureTime', 'arrivalCity', 'arrivalAirport', 'arrivalDayMo', 'arrivalDate', 'arrivalTime', 'duration', '_duration', 'direct', 'stopoverText', 'stopoverRelText', 'departureTimeNumeric', 'arrivalTimeNumeric', 'hash', 'similarityHash', 'stopsRatio', 'recommendStopoverIco'];
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      name = fields[_i];
      this[name] = (function(name) {
        return function() {
          var field;
          field = this.activeVoyage()[name];
          if ((typeof field) === 'function') {
            return field.apply(this.activeVoyage());
          }
          return field;
        };
      })(name);
      rtName = 'rt' + name.charAt(0).toUpperCase() + name.slice(1);
      this[rtName] = (function(name) {
        return function() {
          var field;
          field = this.activeVoyage().activeBackVoyage()[name];
          if ((typeof field) === 'function') {
            return field.apply(this.activeVoyage().activeBackVoyage());
          }
          return field;
        };
      })(name);
    }
  }

  AviaResult.prototype.rtFlightCodesText = function() {
    if (_.size(this.activeVoyage().activeBackVoyage().parts) > 1) {
      return "";
    } else {
      return "";
    }
  };

  AviaResult.prototype.rtServiceClass = function() {
    return this.activeVoyage().serviceClass;
  };

  AviaResult.prototype.flightKey = function() {
    if (this.roundTrip) {
      return this.activeVoyage().activeBackVoyage().flightKey;
    }
    return this.activeVoyage().flightKey;
  };

  AviaResult.prototype.flightCodes = function() {
    var codes;
    codes = _.map(this.activeVoyage().parts, function(flight) {
      return '<span class="tooltip" rel="' + flight.departureCity + ' - ' + flight.arrivalCity + '"><nobr>' + flight.flightCode + "</nobr></span>";
    });
    return Utils.implode(', ', codes);
  };

  AviaResult.prototype.rtFlightCodes = function() {
    var codes;
    codes = _.map(this.activeVoyage().activeBackVoyage().parts, function(flight) {
      return '<span class="tooltip" rel="' + flight.departureCity + ' - ' + flight.arrivalCity + '"><nobr>' + flight.flightCode + "</nobr></span>";
    });
    return Utils.implode(', ', codes);
  };

  AviaResult.prototype.isActive = function() {
    console.log(this.parent.selected_key(), this.key, this.parent.selected_best());
    if (this.parent.selected_best()) {
      return this.parent.selected_key() === this.key;
    }
    return this.parent.selected_key() === this.key;
  };

  AviaResult.prototype.stacked = function() {
    var count, voyage, _i, _len, _ref;
    count = 0;
    _ref = this.voyages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      voyage = _ref[_i];
      if (voyage.visible()) {
        count++;
      }
      if (count > 1) {
        return true;
      }
    }
    return false;
  };

  AviaResult.prototype.rtStacked = function() {
    var count, voyage, _i, _len, _ref;
    count = 0;
    _ref = this.activeVoyage()._backVoyages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      voyage = _ref[_i];
      if (voyage.visible()) {
        count++;
      }
      if (count > 1) {
        return true;
      }
    }
    return false;
  };

  AviaResult.prototype.push = function(data) {
    var backVoyage, newVoyage, result;
    this._stacked = true;
    data.flights[0].flightKey = data.flightKey;
    newVoyage = new Voyage(data.flights[0], this.airline);
    this._stacked_data.push(data);
    if (this.roundTrip) {
      data.flights[1].flightKey = data.flightKey;
      backVoyage = new Voyage(data.flights[1], this.airline);
      newVoyage.push(backVoyage);
      result = _.find(this.voyages, function(voyage) {
        return voyage.hash() === newVoyage.hash();
      });
      if (result) {
        result.push(backVoyage);
        return;
      }
    }
    return this.voyages.push(newVoyage);
  };

  AviaResult.prototype.chooseStacked = function(voyage) {
    var backVoyage, hash;
    if (this.roundTrip) {
      hash = this.activeVoyage().activeBackVoyage().hash();
    }
    this.activeVoyage(voyage);
    backVoyage = _.find(voyage._backVoyages, function(el) {
      return el.hash() === hash;
    });
    if (backVoyage) {
      return this.activeVoyage().activeBackVoyage(backVoyage);
    }
  };

  AviaResult.prototype.choosePrevStacked = function() {
    var active_index, index, voyage, _i, _len, _ref;
    active_index = 0;
    _ref = this.voyages;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      voyage = _ref[index];
      if (voyage.hash() === this.hash()) {
        active_index = index;
      }
    }
    if (active_index === 0) {
      return;
    }
    return this.activeVoyage(this.voyages[active_index - 1]);
  };

  AviaResult.prototype.chooseNextStacked = function() {
    var active_index, index, voyage, _i, _len, _ref;
    active_index = 0;
    _ref = this.voyages;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      voyage = _ref[index];
      if (voyage.hash() === this.hash()) {
        active_index = index;
      }
    }
    if (active_index === this.voyages.length - 1) {
      return;
    }
    return this.activeVoyage(this.voyages[active_index + 1]);
  };

  AviaResult.prototype.chooseRtStacked = function(voyage) {
    window.voyanga_debug("Choosing RT stacked voyage", voyage);
    return this.activeVoyage().activeBackVoyage(voyage);
  };

  AviaResult.prototype.choosePrevRtStacked = function() {
    var active_index, index, rtVoyages, voyage, _i, _len;
    active_index = 0;
    rtVoyages = this.rtVoyages();
    for (index = _i = 0, _len = rtVoyages.length; _i < _len; index = ++_i) {
      voyage = rtVoyages[index];
      if (voyage.hash() === this.rtHash()) {
        active_index = index;
      }
    }
    if (active_index === 0) {
      return;
    }
    return this.activeVoyage().activeBackVoyage(rtVoyages[active_index - 1]);
  };

  AviaResult.prototype.chooseNextRtStacked = function() {
    var active_index, index, rtVoyages, voyage, _i, _len;
    active_index = 0;
    rtVoyages = this.rtVoyages();
    for (index = _i = 0, _len = rtVoyages.length; _i < _len; index = ++_i) {
      voyage = rtVoyages[index];
      if (voyage.hash() === this.rtHash()) {
        active_index = index;
      }
    }
    if (active_index === rtVoyages.length - 1) {
      return;
    }
    return this.activeVoyage().activeBackVoyage(rtVoyages[active_index + 1]);
  };

  AviaResult.prototype.minimizeStacked = function() {
    return this.stackedMinimized(!this.stackedMinimized());
  };

  AviaResult.prototype.minimizeRtStacked = function() {
    return this.rtStackedMinimized(!this.rtStackedMinimized());
  };

  AviaResult.prototype.rtVoyages = function() {
    return this.activeVoyage()._backVoyages;
  };

  AviaResult.prototype.sort = function() {
    this.voyages.sort(function(a, b) {
      return a.departureInt() - b.departureInt();
    });
    if (this.roundTrip) {
      _.each(this.voyages, function(x) {
        x.sort();
        return x.removeSimilar();
      });
    }
    return this.activeVoyage(this.voyages[0]);
  };

  AviaResult.prototype.removeSimilar = function() {
    var item, key, voyage, _helper, _i, _len, _ref, _results;
    if (this.voyages.length < 2) {
      return;
    }
    _helper = {};
    _ref = this.voyages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      voyage = _ref[_i];
      key = voyage.airline + voyage.departureInt();
      item = _helper[key];
      if (item) {
        _helper[key] = item.stopoverLength < voyage.stopoverLength ? item : voyage;
      } else {
        _helper[key] = voyage;
      }
    }
    this.activeVoyage(_helper[key]);
    this.voyages = [];
    _results = [];
    for (key in _helper) {
      item = _helper[key];
      if (item.stopoverLength < this.activeVoyage().stopoverLength) {
        this.activeVoyage(item);
      }
      _results.push(this.voyages.push(item));
    }
    return _results;
  };

  AviaResult.prototype.showDetails = function(data, event) {
    this.parent._popup = new GenericPopup('#avia-body-popup', this);
    ko.processAllDeferredBindingUpdates();
    SizeBox('avia-body-popup');
    return ResizeBox('avia-body-popup');
  };

  AviaResult.prototype.chooseActive = function() {
    var active;
    if (this.visible() === false) {
      return;
    }
    if (this.activeVoyage().visible()) {
      return;
    }
    active = _.find(this.voyages, function(voyage) {
      return voyage.visible();
    });
    if (!active) {
      this.visible(false);
      return;
    }
    return this.activeVoyage(active);
  };

  AviaResult.prototype.directRating = function() {
    var base, d;
    base = 1;
    if (this.direct()) {
      base += 1;
    }
    if (this.roundTrip) {
      if (this.rtDirect()) {
        base += 1;
      }
    }
    d = this._duration();
    if (this.roundTrip) {
      d += this.rt_duration();
    }
    return d / base;
  };

  AviaResult.prototype.getParams = function() {
    var result;
    result = {};
    if (this.activeVoyage()) {
      result.airlineCode = this.airline;
      result.rt = this.roundTrip ? 'true' : 'false';
      result.departureDateTime = this.departureDate();
      result.arrivalDateTime = this.arrivalDate();
      if (this.roundTrip) {
        result.rtDepartureDateTime = this.rtDepartureDate();
        result.rtArrivalDateTime = this.rtArrivalDate();
      }
    }
    return JSON.stringify(result);
  };

  AviaResult.prototype.getPostData = function() {
    var result;
    result = {};
    result.data = this._data;
    result.type = 'avia';
    return result;
  };

  return AviaResult;

})();

AviaResultSet = (function() {

  function AviaResultSet(rawVoyages, siblings) {
    var filteredVoyages, flight, flightVoyage, item, key, part, result, _i, _interlines, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2,
      _this = this;
    this.siblings = siblings != null ? siblings : false;
    this.setBest = __bind(this.setBest, this);

    this.updateBest = __bind(this.updateBest, this);

    this.updateCheapest = __bind(this.updateCheapest, this);

    this.postFilters = __bind(this.postFilters, this);

    this.processSiblings = __bind(this.processSiblings, this);

    this.postInit = __bind(this.postInit, this);

    this.findAndSelect = __bind(this.findAndSelect, this);

    this.onAfterSelect = __bind(this.onAfterSelect, this);

    this.select = __bind(this.select, this);

    this.injectSearchParams = __bind(this.injectSearchParams, this);

    this.recommendTemplate = 'avia-cheapest-result';
    this.tours = false;
    this.selected_key = ko.observable('');
    this.selected_best = ko.observable(false);
    this.showBest = ko.observable(false);
    this.creationMoment = moment();
    this._results = {};
    if (!rawVoyages.length) {
      throw "404";
    }
    _interlines = {};
    for (_i = 0, _len = rawVoyages.length; _i < _len; _i++) {
      flightVoyage = rawVoyages[_i];
      key = '';
      _ref = flightVoyage.flights;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        flight = _ref[_j];
        _ref1 = flight.flightParts;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          part = _ref1[_k];
          key += part.datetimeBegin;
          key += part.datetimeEnd;
        }
      }
      if (_interlines[key]) {
        if (_interlines[key].price > flightVoyage.price) {
          _interlines[key] = flightVoyage;
        }
      } else {
        _interlines[key] = flightVoyage;
      }
    }
    filteredVoyages = [];
    for (key in _interlines) {
      item = _interlines[key];
      filteredVoyages.push(item);
    }
    for (_l = 0, _len3 = filteredVoyages.length; _l < _len3; _l++) {
      flightVoyage = filteredVoyages[_l];
      key = flightVoyage.price + "_" + flightVoyage.valCompany;
      if (this._results[key]) {
        this._results[key].push(flightVoyage);
      } else {
        result = new AviaResult(flightVoyage, this);
        this._results[key] = result;
        result.key = key;
      }
    }
    this.cheapest = ko.observable();
    this.best = ko.observable();
    this.data = [];
    this.numResults = ko.observable(0);
    this.filtersConfig = false;
    _ref2 = this._results;
    for (key in _ref2) {
      result = _ref2[key];
      result.sort();
      result.removeSimilar();
      this.data.push(result);
    }
    this.data.sort(function(left, right) {
      return left.price - right.price;
    });
    this.postFilters();
  }

  AviaResultSet.prototype.injectSearchParams = function(sp) {
    this.rawSP = sp;
    this.arrivalCity = sp.destinations[0].arrival;
    this.departureCity = sp.destinations[0].departure;
    this.rawDate = moment(new Date(sp.destinations[0].date + '+04:00'));
    this.date = dateUtils.formatDayShortMonth(new Date(sp.destinations[0].date + '+04:00'));
    this.dateHeadingText = this.date;
    this.roundTrip = sp.isRoundTrip;
    if (this.roundTrip) {
      this.rtDate = dateUtils.formatDayShortMonth(new Date(sp.destinations[1].date + '+04:00'));
      this.rawRtDate = moment(new Date(sp.destinations[1].date + '+04:00'));
      return this.dateHeadingText += ', ' + this.rtDate;
    }
  };

  AviaResultSet.prototype.select = function(ctx) {
    var selection, ticketValidCheck;
    if (ctx.ribbon) {
      selection = ctx.data;
    } else {
      selection = ctx;
    }
    ticketValidCheck = $.Deferred();
    ticketValidCheck.done(function(selection) {
      var result;
      result = {};
      result.module = 'Avia';
      result.type = 'avia';
      result.searchId = selection.cacheId;
      result.searchKey = selection.flightKey();
      return Utils.toBuySubmit([result]);
    });
    return this.checkTicket(selection, ticketValidCheck);
  };

  AviaResultSet.prototype.onAfterSelect = function() {
    if (this._popup) {
      return this._popup.close();
    }
  };

  AviaResultSet.prototype.findAndSelect = function(result) {
    var backHash, backVoyage, hash, voyage, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    hash = result.similarityHash();
    console.log('hash find avia ', hash);
    _ref = this.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      _ref1 = result.voyages;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        voyage = _ref1[_j];
        if (voyage.similarityHash() === hash) {
          result.activeVoyage(voyage);
          if (!this.roundTrip) {
            return result;
          }
          backHash = voyage.activeBackVoyage().similarityHash();
          _ref2 = voyage._backVoyages;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            backVoyage = _ref2[_k];
            if (backVoyage.similarityHash() === backHash) {
              voyage.activeBackVoyage(backVoyage);
              return result;
            }
          }
        }
      }
    }
    return false;
  };

  AviaResultSet.prototype.postInit = function() {
    var bCheapest, data, eCheapest,
      _this = this;
    this.filters = new AviaFiltersT(this);
    this.filters.serviceClass.selection.subscribe(function(newValue) {
      if (newValue === 'B') {
        _this.showBest(true);
        return;
      }
      return _this.showBest(false);
    });
    if (this.siblings) {
      eCheapest = _.reduce(this.data, function(el1, el2) {
        if (el1.price < el2.price) {
          return el1;
        } else {
          return el2;
        }
      }, this.data[0]);
      data = _.filter(this.data, function(item) {
        return item.serviceClass === 'B';
      });
      bCheapest = _.reduce(data, function(el1, el2) {
        if (el1.price < el2.price) {
          return el1;
        } else {
          return el2;
        }
      }, data[0]);
      if (!eCheapest) {
        eCheapest = {
          price: 0
        };
      }
      if (!bCheapest) {
        bCheapest = {
          price: 0
        };
      }
      this.ESiblings = this.processSiblings(this.siblings.E, eCheapest);
      return this.siblings = ko.observable(this.ESiblings);
    }
  };

  AviaResultSet.prototype.processSiblings = function(rawSiblings, cheapest) {
    var helper, index, min, siblings, sibs, todayPrices, _i, _j, _len, _len1,
      _this = this;
    helper = function(root, sibs, today) {
      var index, price, _i, _len, _results;
      if (today == null) {
        today = false;
      }
      _results = [];
      for (index = _i = 0, _len = sibs.length; _i < _len; index = ++_i) {
        price = sibs[index];
        _results.push(root[index] = {
          price: price,
          siblings: []
        });
      }
      return _results;
    };
    if (this.roundTrip) {
      rawSiblings[3][3] = Math.ceil(cheapest.price / 2);
    } else {
      rawSiblings[3] = cheapest.price;
    }
    if (rawSiblings[3].length) {
      siblings = [];
      todayPrices = [];
      for (index = _i = 0, _len = rawSiblings.length; _i < _len; index = ++_i) {
        sibs = rawSiblings[index];
        sibs = _.filter(sibs, function(item) {
          return item !== false;
        });
        if (sibs.length) {
          min = _.min(sibs);
        } else {
          min = false;
        }
        todayPrices[index] = min;
      }
      helper(siblings, todayPrices, true);
      for (index = _j = 0, _len1 = rawSiblings.length; _j < _len1; index = ++_j) {
        sibs = rawSiblings[index];
        helper(siblings[index].siblings, sibs);
      }
    } else {
      siblings = [];
      helper(siblings, rawSiblings, true);
    }
    return new Siblings(siblings, this.roundTrip, this.rawDate, this.rawRtDate);
  };

  AviaResultSet.prototype.hideRecommend = function(context, event) {
    return hideRecomendedBlockTicket.apply(event.currentTarget);
  };

  AviaResultSet.prototype.postFilters = function() {
    var data;
    data = _.filter(this.data, function(el) {
      return el.visible();
    });
    this.numResults(data.length);
    this.updateCheapest(data);
    this.updateBest(data);
    ko.processAllDeferredBindingUpdates();
    jsPaneScrollHeight();
    return ResizeAvia();
  };

  AviaResultSet.prototype.updateCheapest = function(data) {
    var new_cheapest;
    if (data.length === 0) {
      return;
    }
    new_cheapest = _.reduce(data, function(el1, el2) {
      if (el1.price < el2.price) {
        return el1;
      } else {
        return el2;
      }
    }, data[0]);
    if (this.cheapest() === void 0) {
      this.cheapest(new_cheapest);
      return;
    }
    if (this.cheapest().key !== new_cheapest.key) {
      return this.cheapest(new_cheapest);
    }
  };

  AviaResultSet.prototype.updateBest = function(data) {
    var backVoyage, backVoyages, result, voyage, voyages, _i, _j, _k, _len, _len1, _len2;
    if (data.length === 0) {
      return;
    }
    data = _.sortBy(data, function(el) {
      return el.price;
    });
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      result = data[_i];
      voyages = _.sortBy(result.voyages, function(el) {
        return el._duration;
      });
      for (_j = 0, _len1 = voyages.length; _j < _len1; _j++) {
        voyage = voyages[_j];
        if (voyage.visible() && voyage.maxStopoverLength < 60 * 60 * 3) {
          if (result.roundTrip) {
            backVoyages = _.sortBy(voyage._backVoyages, function(el) {
              return el._duration;
            });
            for (_k = 0, _len2 = backVoyages.length; _k < _len2; _k++) {
              backVoyage = backVoyages[_k];
              if (backVoyage.visible() && backVoyage.maxStopoverLength < 60 * 60 * 3) {
                voyage.activeBackVoyage(backVoyage);
                result.activeVoyage(voyage);
                this.setBest(result);
                return;
              }
            }
          } else {
            result.activeVoyage(voyage);
            this.setBest(result);
            return;
          }
        }
      }
    }
    return this.setBest(data[0], true);
  };

  AviaResultSet.prototype.setBest = function(oldresult, unconditional) {
    var item, key, result, _i, _len, _ref;
    if (unconditional == null) {
      unconditional = false;
    }
    key = oldresult.key;
    result = new AviaResult(oldresult._data, this);
    _ref = oldresult._stacked_data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      result.push(item);
    }
    result.sort();
    result.removeSimilar();
    result.best = true;
    result.key = key + '_optima';
    if (!unconditional) {
      result.voyages = _.filter(result.voyages, function(el) {
        return el.maxStopoverLength < 60 * 60 * 3;
      });
      _.each(result.voyages, function(voyage) {
        return voyage._backVoyages = _.filter(voyage._backVoyages, function(el) {
          return el.maxStopoverLength < 60 * 60 * 3;
        });
      });
    }
    result.chooseStacked(oldresult.activeVoyage());
    if (this.best() === void 0) {
      this.best(result);
      return;
    }
    if (this.best().key !== result.key) {
      return this.best(result);
    }
  };

  AviaResultSet.prototype.filtersRendered = function() {
    return ko.processAllDeferredBindingUpdates();
  };

  return AviaResultSet;

})();

AviaSearchParams = (function(_super) {

  __extends(AviaSearchParams, _super);

  function AviaSearchParams() {
    AviaSearchParams.__super__.constructor.apply(this, arguments);
    this.dep = ko.observable('');
    this.arr = ko.observable('');
    this.rt = ko.observable(true);
    this.rtDate = ko.observable('');
    this.passengers = new Passengers();
    this.adults = this.passengers.adults;
    this.children = this.passengers.children;
    this.infants = this.passengers.infants;
  }

  AviaSearchParams.prototype.url = function() {
    var params, result;
    result = 'flight/search/BE?';
    params = [];
    params.push('destinations[0][departure]=' + this.dep());
    params.push('destinations[0][arrival]=' + this.arr());
    params.push('destinations[0][date]=' + moment(this.date()).format('D.M.YYYY'));
    if (this.rt()) {
      params.push('destinations[1][departure]=' + this.arr());
      params.push('destinations[1][arrival]=' + this.dep());
      params.push('destinations[1][date]=' + moment(this.rtDate()).format('D.M.YYYY'));
    }
    params.push('adt=' + this.adults());
    params.push('chd=' + this.children());
    params.push('inf=' + this.infants());
    result += params.join("&");
    window.voyanga_debug("Generated search url", result);
    return result;
  };

  AviaSearchParams.prototype.key = function() {
    var key;
    key = this.dep() + this.arr() + this.date();
    if (this.rt()) {
      key += this.rtDate();
      key += '_rt';
    }
    key += this.adults();
    key += this.children();
    key += this.infants();
    return key;
  };

  AviaSearchParams.prototype.getHash = function() {
    var hash, parts;
    parts = [this.dep(), this.arr(), moment(this.date()).format('D.M.YYYY'), this.adults(), this.children(), this.infants()];
    if (this.rt()) {
      parts.push(moment(this.rtDate()).format('D.M.YYYY'));
    }
    hash = 'avia/search/' + parts.join('/') + '/';
    window.voyanga_debug("Generated hash for avia search", hash);
    return hash;
  };

  AviaSearchParams.prototype.fromList = function(data) {
    this.dep(data[0]);
    this.arr(data[1]);
    this.date(moment(data[2], 'D.M.YYYY').toDate());
    this.adults(data[3]);
    this.children(data[4]);
    this.infants(data[5]);
    if (data.length === 7) {
      this.rt(true);
      return this.rtDate(moment(data[6], 'D.M.YYYY').toDate());
    } else {
      return this.rt(false);
    }
  };

  AviaSearchParams.prototype.fromObject = function(data) {
    console.log(data);
    this.adults(data.adt);
    this.children(data.chd);
    this.infants(data.inf);
    this.rt(data.isRoundTrip);
    this.dep(data.destinations[0].departure_iata);
    this.arr(data.destinations[0].arrival_iata);
    this.date(new Date(data.destinations[0].date));
    if (this.rt()) {
      return this.rtDate(new Date(data.destinations[1].date));
    }
  };

  return AviaSearchParams;

})(SearchParams);
// Generated by CoffeeScript 1.4.0
/*
SEARCH controller, should be splitted once we will get more actions here
*/

var AviaController,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

AviaController = (function() {

  function AviaController(searchParams) {
    this.searchParams = searchParams;
    this.checkTicketAction = __bind(this.checkTicketAction, this);

    this.indexAction = __bind(this.indexAction, this);

    this.handleResults = __bind(this.handleResults, this);

    this.search = __bind(this.search, this);

    this.searchAction = __bind(this.searchAction, this);

    this.api = new AviaAPI;
    this.routes = {
      '/search/:from/:to/:when/:adults/:children/:infants/:rtwhen/': this.searchAction,
      '/search/:from/:to/:when/:adults/:children/:infants/': this.searchAction,
      '': this.indexAction
    };
    this.results = ko.observable();
    _.extend(this, Backbone.Events);
  }

  AviaController.prototype.searchAction = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    window.voyanga_debug("AVIA: Invoking searchAction", args);
    this.searchParams.fromList(args);
    return this.search();
  };

  AviaController.prototype.search = function() {
    var _this = this;
    return this.api.search(this.searchParams.url(), function(data) {
      var stacked;
      try {
        stacked = _this.handleResults(data);
      } catch (err) {
        if (err === '404') {
          new ErrorPopup('avia404');
          return;
        }
        new ErrorPopup('avia500');
        return;
      }
      _this.results(stacked);
      _this.render('results', {
        results: _this.results
      });
      return ko.processAllDeferredBindingUpdates();
    });
  };

  AviaController.prototype.handleResults = function(data) {
    var stacked;
    window.voyanga_debug("searchAction: handling results", data);
    stacked = new AviaResultSet(data.flights.flightVoyages, data.siblings);
    stacked.injectSearchParams(data.searchParams);
    stacked.postInit();
    stacked.checkTicket = this.checkTicketAction;
    return stacked;
  };

  AviaController.prototype.indexAction = function() {
    window.voyanga_debug("AVIA: invoking indexAction");
    return this.render("index", {});
  };

  AviaController.prototype.checkTicketAction = function(result, resultDeferred) {
    var diff, now,
      _this = this;
    now = moment();
    diff = now.diff(this.results().creationMoment, 'seconds');
    if (diff < AVIA_TICKET_TIMELIMIT) {
      resultDeferred.resolve(result);
      return;
    }
    return this.api.search(this.searchParams.url(), function(data) {
      var stacked;
      try {
        stacked = _this.handleResults(data);
      } catch (err) {
        new ErrorPopup('avia500');
        return;
      }
      result = stacked.findAndSelect(result);
      if (result) {
        return resultDeferred.resolve(result);
      } else {
        new ErrorPopup('aviaNoTicketOnValidation', "  ,  .", false, function() {});
        return _this.results(stacked);
      }
    });
  };

  AviaController.prototype.render = function(view, data) {
    return this.trigger("viewChanged", view, data);
  };

  return AviaController;

})();
// Generated by CoffeeScript 1.4.0
/*
Avia module
Controller + panel
*/

var AviaModule;

AviaModule = (function() {

  function AviaModule() {
    this.panel = new AviaPanel();
    this.controller = new AviaController(this.panel.sp);
  }

  AviaModule.prototype.resize = function() {
    return ResizeAvia();
  };

  return AviaModule;

})();
// Generated by CoffeeScript 1.4.0
var Voyasha, VoyashaCheapest, VoyashaOptima, VoyashaRich,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Voyasha = (function() {

  function Voyasha(toursResultSet) {
    var _this = this;
    this.toursResultSet = toursResultSet;
    this.choose = __bind(this.choose, this);

    this.handleHotels = __bind(this.handleHotels, this);

    this.handleAvia = __bind(this.handleAvia, this);

    this.selected = ko.computed(function() {
      var item, result, _i, _len, _ref;
      result = [];
      _ref = _this.toursResultSet.data();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.isAvia()) {
          result.push(_this.handleAvia(item));
        } else {
          result.push(_this.handleHotels(item));
        }
      }
      return result;
    });
    this.price = ko.computed(function() {
      var item, result, _i, _len, _ref;
      result = 0;
      _ref = _this.selected();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        result += item.price;
      }
      return result;
    });
    this.title = this.getTitle();
  }

  Voyasha.prototype.handleAvia = function() {
    throw "Implement me";
  };

  Voyasha.prototype.handleHotels = function() {
    throw "Implement me";
  };

  Voyasha.prototype.choose = function() {
    var item, _i, _len, _ref;
    _ref = this.toursResultSet.data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item.isAvia()) {
        item.select(this.handleAvia(item));
      } else {
        item.select(this.handleHotels(item));
      }
    }
    return this.toursResultSet.showOverview();
  };

  return Voyasha;

})();

VoyashaCheapest = (function(_super) {

  __extends(VoyashaCheapest, _super);

  function VoyashaCheapest() {
    this.handleHotels = __bind(this.handleHotels, this);

    this.handleAvia = __bind(this.handleAvia, this);

    this.getTitle = __bind(this.getTitle, this);
    return VoyashaCheapest.__super__.constructor.apply(this, arguments);
  }

  VoyashaCheapest.prototype.getTitle = function() {
    return ' ';
  };

  VoyashaCheapest.prototype.handleAvia = function(item) {
    return item.results().cheapest();
  };

  VoyashaCheapest.prototype.handleHotels = function(item) {
    var data, hotel, result, roomSet, _i, _j, _len, _len1, _ref, _ref1;
    data = item.results().data();
    result = {
      roomSet: data[0].roomSets()[0],
      hotel: data[0],
      price: data[0].roomSets()[0].price
    };
    _ref = item.results().data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hotel = _ref[_i];
      _ref1 = hotel.roomSets();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        roomSet = _ref1[_j];
        if (roomSet.price < result.roomSet.price) {
          result.roomSet = roomSet;
          result.hotel = hotel;
          result.price = result.roomSet.price;
        }
      }
    }
    return result;
  };

  return VoyashaCheapest;

})(Voyasha);

VoyashaOptima = (function(_super) {

  __extends(VoyashaOptima, _super);

  function VoyashaOptima() {
    this.handleHotels = __bind(this.handleHotels, this);

    this.handleAvia = __bind(this.handleAvia, this);

    this.getTitle = __bind(this.getTitle, this);
    return VoyashaOptima.__super__.constructor.apply(this, arguments);
  }

  VoyashaOptima.prototype.getTitle = function() {
    return ' ';
  };

  VoyashaOptima.prototype.handleAvia = function(item) {
    return item.results().best();
  };

  VoyashaOptima.prototype.handleHotels = function(item) {
    var data, result, results;
    data = item.results().data();
    result = {
      roomSet: data[0].roomSets()[0],
      hotel: data[0],
      price: data[0].roomSets()[0].price
    };
    results = _.filter(data, function(x) {
      return x.distanceToCenter <= 6;
    });
    results = _.filter(results, function(x) {
      return (x.starsNumeric === 3) || (x.starsNumeric === 4);
    });
    results.sort(function(a, b) {
      return a.roomSets()[0].price - b.roomSets()[0].price;
    });
    if (results.length) {
      data = results[0];
      result = {
        roomSet: data.roomSets()[0],
        hotel: data,
        price: data.roomSets()[0].price
      };
    }
    results = _.filter(results, function(x) {
      return x.rating > 2;
    });
    if (results.length) {
      data = results[0];
      result = {
        roomSet: data.roomSets()[0],
        hotel: data,
        price: data.roomSets()[0].price
      };
    }
    return result;
  };

  return VoyashaOptima;

})(Voyasha);

VoyashaRich = (function(_super) {

  __extends(VoyashaRich, _super);

  function VoyashaRich() {
    this.handleHotels = __bind(this.handleHotels, this);

    this.handleAvia = __bind(this.handleAvia, this);

    this.getTitle = __bind(this.getTitle, this);
    return VoyashaRich.__super__.constructor.apply(this, arguments);
  }

  VoyashaRich.prototype.getTitle = function() {
    return ' ';
  };

  VoyashaRich.prototype.handleAvia = function(item) {
    var data, result, _i, _len;
    data = item.results().data;
    result = {
      'direct': data[0].directRating(),
      'price': data[0].price,
      'result': data[0]
    };
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      item = data[_i];
      if (item.directRating() < result.direct) {
        result.direct = item.directRating();
        result.price = item.price;
        result.result = item;
      } else if (item.directRating() === result.direct) {
        if (item.price < result.price) {
          result.price = item.price;
          result.result = item;
        }
      }
    }
    return result.result;
  };

  VoyashaRich.prototype.getRating = function(x) {
    var hotelRating;
    hotelRating = Math.abs(4.5 - x.starsNumeric);
    if (x.rating === '-') {
      hotelRating += 4;
    } else {
      hotelRating = hotelRating + Math.abs(4 - x.rating);
    }
    if (x.distanceToCenter > 3) {
      hotelRating = hotelRating * 4;
    }
    return hotelRating;
  };

  VoyashaRich.prototype.handleHotels = function(item) {
    var data, result, results,
      _this = this;
    data = item.results().data();
    result = {
      roomSet: data[0].roomSets()[0],
      hotel: data[0],
      price: data[0].roomSets()[0].price
    };
    results = data;
    results.sort(function(a, b) {
      var aHotelRating, bHotelRating;
      aHotelRating = _this.getRating(a);
      bHotelRating = _this.getRating(b);
      return a.roomSets()[0].price * aHotelRating - b.roomSets()[0].price * bHotelRating;
    });
    data = results[0];
    result = {
      roomSet: data.roomSets()[0],
      hotel: data,
      price: data.roomSets()[0].price
    };
    return result;
  };

  return VoyashaRich;

})(Voyasha);
// Generated by CoffeeScript 1.4.0
var Timeline,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Timeline = (function() {

  function Timeline(toursData) {
    var _this = this;
    this.toursData = toursData;
    this.scrollTimelineLeft = __bind(this.scrollTimelineLeft, this);

    this.scrollTimelineRight = __bind(this.scrollTimelineRight, this);

    this.showTimeline = __bind(this.showTimeline, this);

    this.showConditions = __bind(this.showConditions, this);

    this.timelinePosition = ko.observable(0);
    this.termsActive = false;
    this.data = ko.computed(function() {
      var avia_map, end_date, has_first_avia, has_first_hotel, hotel_map, item, item_avia, item_hotel, left, middle_date, obj, results, right, spans, start_date, timeline_length, x, _i, _j, _k, _len, _ref;
      spans = [];
      avia_map = {};
      hotel_map = {};
      _ref = _this.toursData();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        obj = {
          start: moment(item.timelineStart()).clone().hours(0).minutes(5),
          end: moment(item.timelineEnd()).clone().hours(0).minutes(5)
        };
        spans.push(obj);
        if (item.isHotel()) {
          hotel_map[obj.start.format('M.D')] = {
            duration: obj.end.diff(obj.start, 'days'),
            item: item
          };
        } else {
          avia_map[obj.start.format('M.D')] = {
            duration: obj.end.diff(obj.start, 'days'),
            item: item
          };
        }
      }
      start_date = spans[0].start;
      end_date = spans[spans.length - 1].end;
      if (true) {
        item = _this.toursData()[0];
        if (item.isAvia()) {
          if (item.rt()) {
            end_date = moment(item.rtTimelineStart()).clone().hours(0).minutes(5);
            avia_map[end_date.format('M.D')] = {
              duration: 1,
              item: item
            };
          }
        }
      }
      timeline_length = end_date.diff(start_date, 'days');
      middle_date = start_date.clone().add('days', timeline_length / 2);
      if (timeline_length < 23) {
        timeline_length = 23;
      }
      left = Math.round(timeline_length / 2);
      right = Math.round(timeline_length / 2);
      results = [];
      has_first_avia = false;
      has_first_hotel = false;
      for (x = _j = 2; 2 <= left ? _j <= left : _j >= left; x = 2 <= left ? ++_j : --_j) {
        obj = {
          date: middle_date.clone().subtract('days', left - x + 1)
        };
        obj.day = obj.date.format('D');
        obj.hotel = false;
        obj.avia = false;
        obj.first = false;
        item_avia = avia_map[obj.date.format('M.D')];
        item_hotel = hotel_map[obj.date.format('M.D')];
        if (item_hotel) {
          obj.hotel = item_hotel;
          if (has_first_hotel === false) {
            obj.first = true;
            has_first_hotel = true;
          }
        }
        if (item_avia) {
          obj.avia = item_avia;
          if (has_first_avia === false) {
            obj.first = true;
            has_first_avia = true;
          }
        }
        results.push(obj);
      }
      for (x = _k = 0; 0 <= right ? _k <= right : _k >= right; x = 0 <= right ? ++_k : --_k) {
        obj = {
          date: middle_date.clone().add('days', x)
        };
        obj.day = obj.date.format('D');
        obj.hotel = false;
        obj.avia = false;
        obj.first = false;
        item_avia = avia_map[obj.date.format('M.D')];
        item_hotel = hotel_map[obj.date.format('M.D')];
        if (item_hotel) {
          obj.hotel = item_hotel;
          if (has_first_hotel === false) {
            obj.first = true;
            has_first_hotel = true;
          }
        }
        if (item_avia) {
          obj.avia = item_avia;
          if (has_first_avia === false) {
            obj.first = true;
            has_first_avia = true;
          }
        }
        results.push(obj);
      }
      return results;
    });
  }

  Timeline.prototype.showConditions = function(context, event) {
    var el,
      _this = this;
    el = $(event.currentTarget);
    if (!el.hasClass('active')) {
      $('.btn-timeline-and-condition a').removeClass('active');
      el.addClass('active');
      $('.divTimeline').addClass('hide');
      $('.divTimeline').animate({
        'top': '-' + $('.divTimeline').height() + 'px'
      }, 400, function() {
        $('.slide-tmblr').css('overflow', 'visible');
        return _this.termsActive = true;
      });
      return $('.divCondition').animate({
        'top': '0px'
      }, 400).removeClass('hide');
    }
  };

  Timeline.prototype.showTimeline = function(context, event) {
    var el,
      _this = this;
    el = $(event.currentTarget);
    if (!el.hasClass('active')) {
      $('.slide-tmblr').css('overflow', 'hidden');
      $('.btn-timeline-and-condition a').removeClass('active');
      el.addClass('active');
      $('.divTimeline').animate({
        'top': '0px'
      }, 400).removeClass('hide');
      return $('.divCondition').animate({
        'top': '64px'
      }, 400, function() {
        return _this.termsActive = false;
      }).addClass('hide');
    }
  };

  Timeline.prototype.scrollTimelineRight = function() {
    var scrollableFrame;
    scrollableFrame = this.data().length * 32 - 23 * 32;
    if (scrollableFrame < 0) {
      return;
    }
    this.timelinePosition(this.timelinePosition() + 32);
    if (this.timelinePosition() > scrollableFrame) {
      return this.timelinePosition(scrollableFrame);
    }
  };

  Timeline.prototype.scrollTimelineLeft = function() {
    var scrollableFrame;
    scrollableFrame = this.data().length * 32 - 23 * 32;
    if (scrollableFrame < 0) {
      return;
    }
    this.timelinePosition(this.timelinePosition() - 32);
    if (this.timelinePosition() < 0) {
      return this.timelinePosition(0);
    }
  };

  return Timeline;

})();
// Generated by CoffeeScript 1.4.0
var TourPanel, TourPanelSet,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TourPanelSet = (function() {

  function TourPanelSet() {
    this.afterRender = __bind(this.afterRender, this);

    this.calendarHidden = __bind(this.calendarHidden, this);

    this.setDate = __bind(this.setDate, this);

    this.showPanelCalendar = __bind(this.showPanelCalendar, this);

    this.addPanel = __bind(this.addPanel, this);

    this.isFirst = __bind(this.isFirst, this);

    this.deletePanel = __bind(this.deletePanel, this);

    this.saveStartParams = __bind(this.saveStartParams, this);

    this.navigateToNewSearchMainPage = __bind(this.navigateToNewSearchMainPage, this);

    this.navigateToNewSearch = __bind(this.navigateToNewSearch, this);

    var _this = this;
    _.extend(this, Backbone.Events);
    window.voyanga_debug('Init of TourPanelSet');
    this.template = 'tour-panel-template';
    this.sp = new TourSearchParams();
    this.prevPanel = 'hotels';
    this.nextPanel = 'avia';
    this.icon = 'constructor-ico';
    this.mainLabel = '   <img src="/themes/v2/images/saleTitle.png">';
    this.indexMode = true;
    this.startCity = this.sp.startCity;
    this.startCityReadable = ko.observable('');
    this.startCityReadableGen = ko.observable('');
    this.startCityReadableAcc = ko.observable('');
    this.panels = ko.observableArray([]);
    this.activeCity = ko.observable('');
    this.sp.calendarActivated = ko.observable(true);
    this.calendarText = ko.computed(function() {
      var result;
      result = '    ';
      if (_this.activeCity()) {
        result += ' ' + _this.activeCity();
      } else {
        result = ' ';
      }
      return result;
    });
    this.lastPanel = null;
    this.i = 0;
    this.addPanel();
    this.activeCalendarPanel = ko.observable(this.panels()[0]);
    this.height = ko.computed(function() {
      return 64 * _this.panels().length + 'px';
    });
    this.heightPanelSet = ko.computed(function() {
      return 64 * _this.panels().length;
    });
    this.isMaxReached = ko.computed(function() {
      return _this.panels().length > 4;
    });
    this.calendarValue = ko.computed(function() {
      return {
        twoSelect: true,
        hotels: true,
        from: _this.activeCalendarPanel().checkIn(),
        to: _this.activeCalendarPanel().checkOut(),
        activeSearchPanel: _this.activeCalendarPanel()
      };
    });
    this.formFilled = ko.computed(function() {
      var isFilled;
      isFilled = _this.startCity();
      _.each(_this.panels(), function(panel) {
        return isFilled = isFilled && panel.formFilled();
      });
      return isFilled;
    });
    this.formNotFilled = ko.computed(function() {
      return !_this.formFilled();
    });
  }

  TourPanelSet.prototype.navigateToNewSearch = function() {
    if (this.formNotFilled()) {
      return;
    }
    _.last(this.panels()).handlePanelSubmit();
    return _.last(this.panels()).minimizedCalendar(true);
  };

  TourPanelSet.prototype.navigateToNewSearchMainPage = function() {
    if (this.formNotFilled()) {
      return;
    }
    if (this.selectedParams) {
      _.last(this.panels()).selectedParams = this.selectedParams;
    }
    return _.last(this.panels()).handlePanelSubmit(false);
  };

  TourPanelSet.prototype.saveStartParams = function() {
    return _.last(this.panels()).saveStartParams();
  };

  TourPanelSet.prototype.deletePanel = function(elem) {
    var index;
    console.log("Panels before", this.panels());
    console.log("Destinations before", this.sp.destinations());
    console.log("Elem", elem);
    index = this.panels.indexOf(elem);
    this.panels.remove(elem);
    this.sp.destinations.splice(index, 1);
    console.log("Panels after", this.panels());
    console.log("Destinations after", this.sp.destinations());
    return _.last(this.panels()).isLast(true);
  };

  TourPanelSet.prototype.isFirst = function() {
    return this.i === 1;
  };

  TourPanelSet.prototype.addPanel = function() {
    var newPanel, prevPanel,
      _this = this;
    this.sp.destinations.push(new DestinationSearchParams());
    if (_.last(this.panels())) {
      _.last(this.panels()).isLast(false);
      prevPanel = _.last(this.panels());
    }
    newPanel = new TourPanel(this.sp, this.i, this.i === 0);
    newPanel.on("tourPanel:showCalendar", function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.activeCity(newPanel.cityReadable());
      return _this.showPanelCalendar(args);
    });
    newPanel.on("tourPanel:hasFocus", function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.activeCity(newPanel.cityReadable());
      return _this.showPanelCalendar(args);
    });
    if (prevPanel) {
      newPanel.prevSearchPanel(prevPanel);
      prevPanel.nextSearchPanel(newPanel);
    }
    this.panels.push(newPanel);
    this.lastPanel = newPanel;
    this.i = this.panels().length;
    return VoyangaCalendarStandart.clear();
  };

  TourPanelSet.prototype.showPanelCalendar = function(args) {
    return this.activeCalendarPanel(args[0]);
  };

  TourPanelSet.prototype.setDate = function(values) {
    var maxDate;
    if (values && values.length) {
      this.activeCalendarPanel().checkIn(values[0]);
      maxDate = this.activeCalendarPanel().checkIn();
      if (values.length > 1) {
        if (values[0] < values[1]) {
          this.activeCalendarPanel().checkOut(values[1]);
        } else {
          this.activeCalendarPanel().checkOut('');
        }
        if (maxDate < this.activeCalendarPanel().checkOut()) {
          maxDate = this.activeCalendarPanel().checkOut();
        }
      }
      if (this.activeCalendarPanel().nextSearchPanel() && maxDate > this.activeCalendarPanel().nextSearchPanel().checkIn()) {
        this.activeCalendarPanel().nextSearchPanel().checkIn(null);
        return this.activeCalendarPanel().nextSearchPanel().checkOut(null);
      }
    }
  };

  TourPanelSet.prototype.calendarHidden = function() {
    return this.activeCalendarPanel().calendarHidden();
  };

  TourPanelSet.prototype.afterRender = function() {
    return resizePanel();
  };

  TourPanelSet.prototype.beforeRemove = function(el) {
    if ($(el).hasClass('panel')) {
      $(el).remove();
      return resizePanel();
    } else {
      return $(el).remove();
    }
  };

  return TourPanelSet;

})();

TourPanel = (function(_super) {

  __extends(TourPanel, _super);

  function TourPanel(sp, ind, isFirst) {
    this.checkOutHtml = __bind(this.checkOutHtml, this);

    this.checkInHtml = __bind(this.checkInHtml, this);

    this.showCalendar = __bind(this.showCalendar, this);

    this.saveStartParams = __bind(this.saveStartParams, this);

    this.handlePanelSubmit = __bind(this.handlePanelSubmit, this);

    this.handlePanelSubmitToMain = __bind(this.handlePanelSubmitToMain, this);

    var _this = this;
    TourPanel.__super__.constructor.call(this, isFirst, true);
    this.toggleSubscribers.dispose();
    _.extend(this, Backbone.Events);
    this.hasfocus = ko.observable(false);
    this.sp = sp;
    this.isLast = ko.observable(true);
    this.peopleSelectorVM = new HotelPeopleSelector(sp);
    this.destinationSp = _.last(sp.destinations());
    this.city = this.destinationSp.city;
    this.checkIn = this.destinationSp.dateFrom;
    this.checkOut = this.destinationSp.dateTo;
    this.cityReadable = ko.observable('');
    this.cityReadableGen = ko.observable('');
    this.cityReadableAcc = ko.observable('');
    this.oldCalendarState = this.minimizedCalendar();
    this.formFilled = ko.computed(function() {
      return _this.city() && _this.checkIn() && _this.checkOut();
    });
    this.formNotFilled = ko.computed(function() {
      return !_this.formFilled();
    });
    this.maximizedCalendar = ko.computed(function() {
      return _this.city().length > 0;
    });
    this.calendarText = ko.computed(function() {
      var result;
      result = "   ";
      return result;
    });
    this.hasfocus.subscribe(function(newValue) {
      return _this.trigger("tourPanel:hasFocus", _this);
    });
    this.city.subscribe(function(newValue) {
      if (_this.sp.calendarActivated()) {
        return _this.showCalendar();
      }
    });
  }

  TourPanel.prototype.handlePanelSubmitToMain = function() {
    return handlePanelSubmit(false);
  };

  TourPanel.prototype.handlePanelSubmit = function(onlyHash) {
    var url;
    if (onlyHash == null) {
      onlyHash = true;
    }
    if (onlyHash) {
      return app.navigate(this.sp.getHash(), {
        trigger: true
      });
    } else {
      url = '/#' + this.sp.getHash();
      if (this.startParams === url) {
        url += 'eventId/' + this.selectedParams.eventId;
      }
      return window.location.href = url;
    }
  };

  TourPanel.prototype.saveStartParams = function() {
    var url;
    url = '/#' + this.sp.getHash();
    return this.startParams = url;
  };

  TourPanel.prototype.close = function() {
    $(document.body).unbind('mousedown');
    $('.how-many-man .btn').removeClass('active');
    $('.how-many-man .content').removeClass('active');
    return $('.how-many-man').find('.popup').removeClass('active');
  };

  TourPanel.prototype.showFromCityInput = function(panel, event) {
    var el, elem;
    event.stopPropagation();
    elem = $('.cityStart').find('.second-path');
    elem.data('old', elem.val());
    el = elem.closest('.cityStart');
    el.closest('.tdCityStart').animate({
      width: '+=130',
      300: 300
    });
    el.closest('.tdCityStart').find('.bgInput').animate({
      width: '+=150',
      300: 300
    });
    el.closest('.tdCityStart').next().find('.data').animate({
      width: '-=130',
      300: 300
    });
    el.find(".startInputTo").show();
    return el.find('.cityStart').animate({
      width: "261px"
    }, 300, function() {
      return el.find(".startInputTo").find("input").focus().select();
    });
  };

  TourPanel.prototype.hideFromCityInput = function(panel, event) {
    return hideFromCityInput(panel, event);
  };

  TourPanel.prototype.showCalendar = function() {
    $('.calenderWindow').show();
    this.trigger("tourPanel:showCalendar", this);
    if (this.minimizedCalendar()) {
      ResizeAvia();
      return this.minimizedCalendar(false);
    }
  };

  TourPanel.prototype.checkInHtml = function() {
    if (this.checkIn()) {
      return dateUtils.formatHtmlDayShortMonth(this.checkIn());
    }
    return '';
  };

  TourPanel.prototype.checkOutHtml = function() {
    if (this.checkOut()) {
      return dateUtils.formatHtmlDayShortMonth(this.checkOut());
    }
    return '';
  };

  return TourPanel;

})(SearchPanel);

$(document).on("keyup change", "input.second-path", function(e) {
  var firstValue, secondEl;
  firstValue = $(this).val();
  secondEl = $(this).siblings('input.input-path');
  if ((e.keyCode === 8) || (firstValue.length < 3)) {
    return secondEl.val('');
  }
});

$(document).on("keyup change", '.cityStart input.second-path', function(e) {
  var elem;
  elem = $('.from.active .second-path');
  if (e.keyCode === 13) {
    if (elem.parent().hasClass("overflow")) {
      elem.parent().animate({
        width: "271px"
      }, 300, function() {
        $(this).removeClass("overflow");
        return $('.from.active .second-path').focus();
      });
      $(".cityStart").animate({
        width: "115px"
      }, 300);
      return $(".cityStart").find(".startInputTo").animate({
        opacity: "1"
      }, 300, function() {
        return $(this).hide();
      });
    }
  }
});
// Generated by CoffeeScript 1.4.0
var DestinationSearchParams, RoomsSearchParams, TourEntry, TourSearchParams, TourTripResultSet, ToursAviaResultSet, ToursHotelsResultSet, ToursOverviewVM, ToursResultSet,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TourEntry = (function() {

  function TourEntry() {
    this.beforeRender = __bind(this.beforeRender, this);

    this.rt = __bind(this.rt, this);

    this.savings = __bind(this.savings, this);

    this.maxPriceHtml = __bind(this.maxPriceHtml, this);

    this.minPriceHtml = __bind(this.minPriceHtml, this);

    this.priceHtml = __bind(this.priceHtml, this);

    this.price = __bind(this.price, this);

    this.isHotel = __bind(this.isHotel, this);

    this.isAvia = __bind(this.isAvia, this);
    _.extend(this, Backbone.Events);
    this.savingsWithAviaOnly = false;
  }

  TourEntry.prototype.isAvia = function() {
    return this.avia;
  };

  TourEntry.prototype.isHotel = function() {
    return this.hotels;
  };

  TourEntry.prototype.price = function() {
    if (this.selection() === null) {
      return 0;
    }
    return this.selection().price;
  };

  TourEntry.prototype.priceHtml = function() {
    if (this.selection() === null) {
      return " ";
    }
    return this.price() + '<span class="rur">o</span>';
  };

  TourEntry.prototype.minPriceHtml = function() {
    return this.minPrice() + '<span class="rur">o</span>';
  };

  TourEntry.prototype.maxPriceHtml = function() {
    return this.maxPrice() + '<span class="rur">o</span>';
  };

  TourEntry.prototype.savings = function() {
    if (this.selection() === null) {
      return 0;
    }
    return 0;
  };

  TourEntry.prototype.rt = function() {
    return false;
  };

  TourEntry.prototype.beforeRender = function() {};

  return TourEntry;

})();

ToursAviaResultSet = (function(_super) {

  __extends(ToursAviaResultSet, _super);

  function ToursAviaResultSet(raw, sp) {
    this.afterRender = __bind(this.afterRender, this);

    this.beforeRender = __bind(this.beforeRender, this);

    this.rt = __bind(this.rt, this);

    this.timelineStartDate = __bind(this.timelineStartDate, this);

    this.timelineEndDate = __bind(this.timelineEndDate, this);

    this.rt = __bind(this.rt, this);

    this.rtTimelineStart = __bind(this.rtTimelineStart, this);

    this.timelineEnd = __bind(this.timelineEnd, this);

    this.timelineStart = __bind(this.timelineStart, this);

    this.dateHtml = __bind(this.dateHtml, this);

    this.dateClass = __bind(this.dateClass, this);

    this.additionalText = __bind(this.additionalText, this);

    this.destinationText = __bind(this.destinationText, this);

    this.maxPrice = __bind(this.maxPrice, this);

    this.minPrice = __bind(this.minPrice, this);

    this.numAirlines = __bind(this.numAirlines, this);

    this.overviewPeople = __bind(this.overviewPeople, this);

    this.overviewText = __bind(this.overviewText, this);

    this.doNewSearch = __bind(this.doNewSearch, this);

    this.toBuyRequest = __bind(this.toBuyRequest, this);

    this._selectResult = __bind(this._selectResult, this);

    this.select = __bind(this.select, this);

    this.findAndSelect = __bind(this.findAndSelect, this);

    this.newResults = __bind(this.newResults, this);
    ToursAviaResultSet.__super__.constructor.apply(this, arguments);
    this.api = new AviaAPI;
    this.template = 'avia-results';
    this.overviewTemplate = 'tours-overview-avia-no-selection';
    this.panel = new AviaPanel();
    this.panel.handlePanelSubmit = this.doNewSearch;
    this.panel.sp.fromObject(sp);
    this.panel.original_template = this.panel.template;
    this.results = ko.observable();
    this.selection = ko.observable(null);
    this.newResults(raw, sp);
    this.data = {
      results: this.results
    };
  }

  ToursAviaResultSet.prototype.newResults = function(raw, sp) {
    var result,
      _this = this;
    this.rawSP = sp;
    result = new AviaResultSet(raw);
    result.injectSearchParams(sp);
    result.postInit();
    result.recommendTemplate = 'avia-tours-recommend';
    result.tours = true;
    result.select = function(res) {
      _this.select(res, result);
      return _this.trigger('next');
    };
    this.avia = true;
    return this.results(result);
  };

  ToursAviaResultSet.prototype.findAndSelect = function(result) {
    result = this.results().findAndSelect(result);
    if (!result) {
      return false;
    }
    this._selectResult(result);
    return result;
  };

  ToursAviaResultSet.prototype.select = function(res) {
    if (res.ribbon) {
      res = res.data;
    }
    return this._selectResult(res);
  };

  ToursAviaResultSet.prototype._selectResult = function(res) {
    this.results().selected_key(res.key);
    res.parent.filtersConfig = res.parent.filters.getConfig();
    this.results().selected_best(res.best | false);
    this.overviewTemplate = 'tours-overview-avia-ticket';
    return this.selection(res);
  };

  ToursAviaResultSet.prototype.toBuyRequest = function() {
    var result;
    result = {};
    result.type = 'avia';
    result.searchId = this.selection().cacheId;
    result.searchKey = this.selection().flightKey();
    result.adults = this.rawSP.adt;
    result.children = this.rawSP.chd;
    result.infants = this.rawSP.inf;
    return result;
  };

  ToursAviaResultSet.prototype.doNewSearch = function() {
    var _this = this;
    return this.api.search(this.panel.sp.url(), function(data) {
      return _this.newResults(data.flights.flightVoyages, data.searchParams);
    });
  };

  ToursAviaResultSet.prototype.overviewText = function() {
    return " " + this.results().departureCity + ' &rarr; ' + this.results().arrivalCity;
  };

  ToursAviaResultSet.prototype.overviewPeople = function() {
    var sum;
    sum = this.panel.sp.adults() + this.panel.sp.children() + this.panel.sp.infants();
    return Utils.wordAfterNum(sum, '', '', '');
  };

  ToursAviaResultSet.prototype.numAirlines = function() {
    return this.results().filters.airline.options().length;
  };

  ToursAviaResultSet.prototype.minPrice = function() {
    var cheapest;
    cheapest = _.reduce(this.results().data, function(el1, el2) {
      if (el1.price < el2.price) {
        return el1;
      } else {
        return el2;
      }
    }, this.results().data[0]);
    return cheapest.price;
  };

  ToursAviaResultSet.prototype.maxPrice = function() {
    var mostExpensive;
    mostExpensive = _.reduce(this.results().data, function(el1, el2) {
      if (el1.price > el2.price) {
        return el1;
      } else {
        return el2;
      }
    }, this.results().data[0]);
    return mostExpensive.price;
  };

  ToursAviaResultSet.prototype.destinationText = function() {
    return "<span class='left-avia-city'>" + this.results().departureCity + "&rarr;</span> " + "<span class='left-avia-city'>" + this.results().arrivalCity + "</span>";
  };

  ToursAviaResultSet.prototype.additionalText = function() {
    if (this.selection() === null) {
      return "";
    }
    if (this.rt()) {
      return "";
    } else {
      return ", " + this.selection().departureTime() + ' - ' + this.selection().arrivalTime();
    }
  };

  ToursAviaResultSet.prototype.dateClass = function() {
    if (this.rt()) {
      return 'blue-two';
    } else {
      return 'blue-one';
    }
  };

  ToursAviaResultSet.prototype.dateHtml = function(startonly) {
    var result, source;
    if (startonly == null) {
      startonly = false;
    }
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    result = '<div class="day">';
    result += dateUtils.formatHtmlDayShortMonth(source.departureDate());
    result += '</div>';
    if (startonly) {
      return result;
    }
    if (this.rt()) {
      result += '<div class="day">';
      result += dateUtils.formatHtmlDayShortMonth(source.rtDepartureDate());
      result += '</div>';
    }
    return result;
  };

  ToursAviaResultSet.prototype.timelineStart = function() {
    var source;
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    return source.departureDate();
  };

  ToursAviaResultSet.prototype.timelineEnd = function() {
    var source;
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    return source.arrivalDate();
  };

  ToursAviaResultSet.prototype.rtTimelineStart = function() {
    var source;
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    return source.rtDepartureDate();
  };

  ToursAviaResultSet.prototype.rt = function() {
    var source;
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    return source.roundTrip;
  };

  ToursAviaResultSet.prototype.timelineEndDate = function() {
    var source;
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    return source.arrivalDate();
  };

  ToursAviaResultSet.prototype.timelineStartDate = function() {
    var source;
    source = this.selection();
    if (source === null) {
      source = this.results().data[0];
    }
    return source.departureDate();
  };

  ToursAviaResultSet.prototype.rt = function() {
    return this.results().roundTrip;
  };

  ToursAviaResultSet.prototype.beforeRender = function() {
    if (this.results().selectedKey) {
      return this.results().filters.getConfig(this.results().filtersConfig);
    }
  };

  ToursAviaResultSet.prototype.afterRender = function() {
    var _this = this;
    if (this.results()) {
      console.log('avia after rend');
      if (this.results().selected_key) {
        console.log('Yes, have selected');
        return window.setTimeout(function() {
          if ($('.ticket-content .pressButton.selected').parent().parent().parent().parent().length) {
            return Utils.scrollTo($('.ticket-content .pressButton.selected').parent().parent().parent().parent());
          }
        }, 50);
      }
    }
  };

  return ToursAviaResultSet;

})(TourEntry);

ToursHotelsResultSet = (function(_super) {

  __extends(ToursHotelsResultSet, _super);

  function ToursHotelsResultSet(raw, sp) {
    this.savings = __bind(this.savings, this);

    this.afterRender = __bind(this.afterRender, this);

    this.beforeRender = __bind(this.beforeRender, this);

    this.timelineEndDate = __bind(this.timelineEndDate, this);

    this.timelineStartDate = __bind(this.timelineStartDate, this);

    this.timelineEnd = __bind(this.timelineEnd, this);

    this.timelineStart = __bind(this.timelineStart, this);

    this.dateHtml = __bind(this.dateHtml, this);

    this.dateClass = __bind(this.dateClass, this);

    this.additionalText = __bind(this.additionalText, this);

    this.price = __bind(this.price, this);

    this.destinationText = __bind(this.destinationText, this);

    this.maxPrice = __bind(this.maxPrice, this);

    this.minPrice = __bind(this.minPrice, this);

    this.numHotels = __bind(this.numHotels, this);

    this.overviewPeople = __bind(this.overviewPeople, this);

    this.overviewText = __bind(this.overviewText, this);

    this.doNewSearch = __bind(this.doNewSearch, this);

    this.toBuyRequest = __bind(this.toBuyRequest, this);

    this._selectRoomSet = __bind(this._selectRoomSet, this);

    this.select = __bind(this.select, this);

    this.findAndSelectSame = __bind(this.findAndSelectSame, this);

    this.findAndSelect = __bind(this.findAndSelect, this);

    this.newResults = __bind(this.newResults, this);
    ToursHotelsResultSet.__super__.constructor.apply(this, arguments);
    this.api = new HotelsAPI;
    this.panel = new HotelsPanel();
    this.panel.handlePanelSubmit = this.doNewSearch;
    this.panel.sp.fromObject(sp);
    this.panel.original_template = this.panel.template;
    this.overviewTemplate = 'tours-overview-hotels-no-selection';
    this.template = 'hotels-results';
    this.activeHotel = ko.observable(0);
    this.selection = ko.observable(null);
    this.results = ko.observable();
    this.data = {
      results: this.results
    };
    this.savingsWithAviaOnly = true;
    this.newResults(raw, sp);
  }

  ToursHotelsResultSet.prototype.newResults = function(data, sp) {
    var result,
      _this = this;
    this.rawSP = sp;
    result = new HotelsResultSet(data, sp, this.activeHotel);
    result.tours(true);
    result.postInit();
    result.select = function(hotel) {
      hotel.parent = result;
      hotel.oldPageTop = $("html").scrollTop() | $("body").scrollTop();
      hotel.off('back');
      hotel.on('back', function() {
        return _this.trigger('setActive', _this, false, false, hotel.oldPageTop, function() {
          if (!hotel.parent.showFullMap()) {
            return Utils.scrollTo('#hotelResult' + hotel.hotelId);
          } else {
            return hotel.parent.showFullMapFunc(null, null, true);
          }
        });
      });
      hotel.off('select');
      hotel.on('select', function(roomData) {
        _this.select(roomData);
        return _this.trigger('next');
      });
      return _this.trigger('setActive', {
        'data': hotel,
        template: 'hotels-info-template',
        'parent': _this
      });
    };
    result.selectFromPopup = function(hotel) {
      hotel.parent = result;
      hotel.activePopup.close();
      hotel.oldPageTop = $("html").scrollTop() | $("body").scrollTop();
      hotel.off('back');
      hotel.on('back', function() {
        return _this.trigger('setActive', _this, false, false, hotel.oldPageTop, function() {
          if (!hotel.parent.showFullMap()) {
            return Utils.scrollTo('#hotelResult' + hotel.hotelId);
          }
        });
      });
      hotel.off('select');
      hotel.on('select', function(roomData) {
        _this.select(roomData);
        return _this.trigger('next');
      });
      return _this.trigger('setActive', {
        'data': hotel,
        template: 'hotels-info-template',
        'parent': _this
      });
    };
    this.hotels = true;
    this.selection(null);
    return this.results(result);
  };

  ToursHotelsResultSet.prototype.findAndSelect = function(result) {
    console.log('find THRS ', result);
    if (result.roomSet) {
      result = this.results().findAndSelect(ko.utils.unwrapObservable(result.roomSet));
    } else {
      console.log(ko.utils.unwrapObservable(result.roomSets));
      result = this.results().findAndSelect(ko.utils.unwrapObservable(result.roomSets)[0]);
    }
    if (!result) {
      console.log('not found =(', result);
      return false;
    }
    return this._selectRoomSet(result);
  };

  ToursHotelsResultSet.prototype.findAndSelectSame = function(result) {
    var ret;
    console.log('find THRS ', result);
    if (result.roomSet) {
      console.log('inif');
      ret = this.results().findAndSelectSame(ko.utils.unwrapObservable(result.roomSet));
    } else {
      console.log('inelse');
      console.log(ko.utils.unwrapObservable(result.roomSets));
      ret = this.results().findAndSelectSame(ko.utils.unwrapObservable(result.roomSets)[0]);
    }
    console.log('ret?', ret);
    if (!ret) {
      console.log('same not found and find by stars and coords');
      ret = this.results().findAndSelectSameParams(result.categoryId, result.getLatLng());
    }
    return this._selectRoomSet(ret);
  };

  ToursHotelsResultSet.prototype.select = function(roomData) {
    return this._selectRoomSet(roomData.roomSet);
  };

  ToursHotelsResultSet.prototype._selectRoomSet = function(roomSet) {
    var hotel;
    hotel = roomSet.parent;
    hotel.parent = this.results();
    this.activeHotel(hotel.hotelId);
    this.overviewTemplate = 'tours-overview-hotels-ticket';
    this.selection({
      roomSet: roomSet,
      hotel: hotel
    });
    hotel.parent.filtersConfig = hotel.parent.filters.getConfig();
    return hotel.parent.pagesLoad = hotel.parent.showParts();
  };

  ToursHotelsResultSet.prototype.toBuyRequest = function() {
    var result, room, _i, _len, _ref;
    result = {};
    result.type = 'hotel';
    result.searchId = this.selection().hotel.cacheId;
    result.searchKey = this.selection().roomSet.resultId;
    result.adults = 0;
    result.age = false;
    result.cots = 0;
    _ref = this.rawSP.rooms;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      room = _ref[_i];
      result.adults += room.adultCount * 1;
      if (room.childAge) {
        result.age = room.childAgeage;
      }
      result.cots += room.cots * 1;
    }
    return result;
  };

  ToursHotelsResultSet.prototype.doNewSearch = function() {
    var _this = this;
    return this.api.search(this.panel.sp.url(), function(data) {
      data.searchParams.cacheId = data.cacheId;
      return _this.newResults(data, data.searchParams);
    });
  };

  ToursHotelsResultSet.prototype.overviewText = function() {
    return this.destinationText();
  };

  ToursHotelsResultSet.prototype.overviewPeople = function() {
    var sum;
    sum = this.panel.sp.overall();
    return Utils.wordAfterNum(sum, '', '', '') + ', ' + this.results().wordDays;
  };

  ToursHotelsResultSet.prototype.numHotels = function() {
    return this.results().data().length;
  };

  ToursHotelsResultSet.prototype.minPrice = function() {
    return this.results().minPrice;
  };

  ToursHotelsResultSet.prototype.maxPrice = function() {
    return this.results().maxPrice;
  };

  ToursHotelsResultSet.prototype.destinationText = function() {
    return "<span class='hotel-left-long'>  " + this.rawSP.cityFull.casePre + "</span><span class='hotel-left-short'>" + this.rawSP.cityFull.caseNom + "</span>";
  };

  ToursHotelsResultSet.prototype.price = function() {
    if (this.selection() === null) {
      return 0;
    }
    return this.selection().roomSet.price;
  };

  ToursHotelsResultSet.prototype.additionalText = function() {
    if (this.selection() === null) {
      return "";
    }
    return ", " + this.selection().hotel.hotelName;
  };

  ToursHotelsResultSet.prototype.dateClass = function() {
    return 'orange-two';
  };

  ToursHotelsResultSet.prototype.dateHtml = function(startOnly) {
    var result;
    if (startOnly == null) {
      startOnly = false;
    }
    result = '<div class="day">';
    result += dateUtils.formatHtmlDayShortMonth(this.results().checkIn);
    result += '</div>';
    if (startOnly) {
      return result;
    }
    result += '<div class="day">';
    result += dateUtils.formatHtmlDayShortMonth(this.results().checkOut);
    return result += '</div>';
  };

  ToursHotelsResultSet.prototype.timelineStart = function() {
    return this.results().checkIn;
  };

  ToursHotelsResultSet.prototype.timelineEnd = function() {
    return this.results().checkOut;
  };

  ToursHotelsResultSet.prototype.timelineStartDate = function() {
    return this.results().checkIn._d;
  };

  ToursHotelsResultSet.prototype.timelineEndDate = function() {
    return this.results().checkOut._d;
  };

  ToursHotelsResultSet.prototype.beforeRender = function() {
    console.log('beforeRender hotels');
    if (this.results()) {
      this.results().toursOpened = true;
      if (this.activeHotel()) {
        this.results().filters.setConfig(this.results().filtersConfig);
        return this.results().showParts(this.results().pagesLoad);
      } else {
        return this.results().postFilters();
      }
    }
  };

  ToursHotelsResultSet.prototype.afterRender = function() {
    var _this = this;
    if (this.results()) {
      if (this.activeHotel()) {
        return window.setTimeout(function() {
          if ($('.hotels-tickets .pressButton.selected').parent().parent().parent().parent().length) {
            return Utils.scrollTo($('.hotels-tickets .pressButton.selected').parent().parent().parent().parent());
          }
        }, 50);
      }
    }
  };

  ToursHotelsResultSet.prototype.savings = function() {
    if (this.selection() === null) {
      return 0;
    }
    return this.selection().roomSet.price - this.selection().roomSet.discountPrice;
  };

  return ToursHotelsResultSet;

})(TourEntry);

ToursResultSet = (function() {

  function ToursResultSet(raw, searchParams) {
    var result, variant, _i, _len, _ref,
      _this = this;
    this.searchParams = searchParams;
    this.findAndSelectItems = __bind(this.findAndSelectItems, this);

    this.findAndSelect = __bind(this.findAndSelect, this);

    this.buy = __bind(this.buy, this);

    this.showOverview = __bind(this.showOverview, this);

    this.removeItem = __bind(this.removeItem, this);

    this.nextEntry = __bind(this.nextEntry, this);

    this.setActiveTimelineHotels = __bind(this.setActiveTimelineHotels, this);

    this.setActiveTimelineAvia = __bind(this.setActiveTimelineAvia, this);

    this.setActive = __bind(this.setActive, this);

    _.extend(this, Backbone.Events);
    this.creationMoment = moment();
    this.data = ko.observableArray();
    _ref = raw.allVariants;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      variant = _ref[_i];
      if (!variant) {
        continue;
      }
      if (variant.flights) {
        result = new ToursAviaResultSet(variant.flights.flightVoyages, variant.searchParams);
      } else {
        result = new ToursHotelsResultSet(variant, variant.searchParams);
      }
      this.data.push(result);
      result.on('setActive', function(entry, beforeRender, afterRender, scrollTo, callback) {
        if (beforeRender == null) {
          beforeRender = true;
        }
        if (afterRender == null) {
          afterRender = true;
        }
        if (scrollTo == null) {
          scrollTo = 0;
        }
        if (callback == null) {
          callback = null;
        }
        return _this.setActive(entry, beforeRender, afterRender, scrollTo, callback);
      });
      result.on('next', function(entry) {
        return _this.nextEntry();
      });
    }
    this.timeline = new Timeline(this.data);
    this.selection = ko.observable(this.data()[0]);
    this.panel = ko.computed({
      read: function() {
        if (_this.selection().panel) {
          _this.panelContainer = _this.selection().panel;
        }
        _this.panelContainer.timeline = _this.timeline;
        _this.panelContainer.setActiveTimelineAvia = _this.setActiveTimelineAvia;
        _this.panelContainer.setActiveTimelineHotels = _this.setActiveTimelineHotels;
        if (!_this.panelContainer.onlyTimeline) {
          _this.panelContainer.onlyTimeline = false;
        } else {
          _this.panelContainer.timeline.termsActive = false;
        }
        _this.panelContainer.selection = _this.selection;
        _this.panelContainer.template = 'tours-panel-template';
        return _this.panelContainer;
      }
    });
    this.price = ko.computed(function() {
      var item, sum, _j, _len1, _ref1;
      sum = 0;
      _ref1 = _this.data();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        item = _ref1[_j];
        sum += item.price();
      }
      return sum;
    });
    this.savings = ko.computed(function() {
      var has_avia, item, sum, _j, _k, _len1, _len2, _ref1, _ref2;
      has_avia = false;
      _ref1 = _this.data();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        item = _ref1[_j];
        if (item.selection() && item.isAvia()) {
          has_avia = true;
        }
      }
      sum = 0;
      _ref2 = _this.data();
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        item = _ref2[_k];
        if (item.savingsWithAviaOnly) {
          if (has_avia) {
            sum += item.savings();
          }
        } else {
          sum += item.savings();
        }
      }
      return sum;
    });
    this.someSegmentsSelected = ko.computed(function() {
      var x, _j, _len1, _ref1;
      _ref1 = _this.data();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        x = _ref1[_j];
        if (x.selection()) {
          return true;
        }
      }
      return false;
    });
    this.someSegmentsSelected.subscribe(function(newValue) {
      if (newValue) {
        return $('#tour-buy-btn').show('fast');
      } else {
        return $('#tour-buy-btn').hide('fast');
      }
    });
    this.vm = new ToursOverviewVM(this);
    this.voyashki = [];
    this.voyashki.push(new VoyashaCheapest(this));
    this.voyashki.push(new VoyashaOptima(this));
    this.voyashki.push(new VoyashaRich(this));
  }

  ToursResultSet.prototype.setActive = function(entry, beforeRender, afterRender, scrollTo, callback) {
    var _this = this;
    if (beforeRender == null) {
      beforeRender = true;
    }
    if (afterRender == null) {
      afterRender = true;
    }
    if (scrollTo == null) {
      scrollTo = 0;
    }
    if (callback == null) {
      callback = null;
    }
    $('#loadWrapBgMin').show();
    if (entry.overview) {
      $('.btn-timeline-and-condition').hide();
      window.toursOverviewActive = true;
    } else {
      window.toursOverviewActive = false;
    }
    console.log('br', beforeRender, afterRender);
    if (entry.beforeRender && beforeRender) {
      console.log('brin');
      entry.beforeRender();
    }
    this.trigger('inner-template', entry.template);
    return window.setTimeout(function() {
      console.log('TourOut', window.hrs.data()[0]);
      if (entry.afterRender && afterRender) {
        console.log('arin');
        entry.afterRender();
      }
      _this.selection(entry);
      ko.processAllDeferredBindingUpdates();
      ResizeAvia();
      $('#loadWrapBgMin').hide();
      if (!(scrollTo === false)) {
        Utils.scrollTo(scrollTo, false);
      }
      if (callback) {
        callback();
      }
      return console.log('TourOut2', window.hrs.data()[0]);
    }, 100);
  };

  ToursResultSet.prototype.setActiveTimelineAvia = function(entry) {
    return this.setActive(entry.avia.item);
  };

  ToursResultSet.prototype.setActiveTimelineHotels = function(entry) {
    return this.setActive(entry.hotel.item);
  };

  ToursResultSet.prototype.nextEntry = function() {
    var x, _i, _len, _ref;
    _ref = this.data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      if (!x.selection()) {
        this.setActive(x);
        return;
      }
    }
    return this.showOverview();
  };

  ToursResultSet.prototype.removeItem = function(item, event) {
    var idx;
    event.stopPropagation();
    if (this.data().length < 2) {
      return;
    }
    idx = this.data.indexOf(item);
    if (idx === -1) {
      return;
    }
    this.data.splice(idx, 1);
    if (item === this.selection()) {
      return this.setActive(this.data()[0]);
    }
  };

  ToursResultSet.prototype.showOverview = function() {
    var dummyPanel,
      _this = this;
    dummyPanel = {
      onlyTimeline: true,
      calendarHidden: function() {
        return true;
      },
      calendarValue: ko.observable({
        values: []
      })
    };
    this.setActive({
      template: 'tours-overview',
      data: this,
      overview: true,
      panel: dummyPanel
    });
    ResizeAvia();
    return window.setTimeout(function() {
      var aviaRes, calendarEvents, checkIn, checkOut, dest, flight, flights, hotelEvent, resSet, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      console.log('after render tours all tour page');
      console.log(_this.data());
      calendarEvents = [];
      _ref = _this.data();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        resSet = _ref[_i];
        if (resSet.isAvia()) {
          console.log('avia', resSet.data.results(), resSet.rawSP);
          flights = [];
          _ref1 = resSet.rawSP.destinations;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            dest = _ref1[_j];
            flight = {
              type: 'flight',
              description: dest.departure + ' || ' + dest.arrival,
              cityFrom: dest.departure_iata,
              cityTo: dest.arrival_iata
            };
            flight.dayStart = moment(dest.date)._d;
            flight.dayEnd = moment(dest.date)._d;
            flights.push(flight);
          }
          if (resSet.selection()) {
            console.log('select:', resSet.selection());
            aviaRes = resSet.selection();
            flights[0].dayEnd = aviaRes.arrivalDate();
            if (aviaRes.roundTrip) {
              flights[1].dayEnd = aviaRes.rtArrivalDate();
            }
            console.log('city:', aviaRes.arrivalCity(), 'date:', aviaRes.arrivalDate());
          }
          for (_k = 0, _len2 = flights.length; _k < _len2; _k++) {
            flight = flights[_k];
            calendarEvents.push(flight);
          }
        }
        if (resSet.isHotel()) {
          console.log('hotel', resSet.data.results(), resSet.rawSP);
          checkIn = moment(resSet.rawSP.checkIn).add('h', 8);
          checkOut = moment(resSet.rawSP.checkIn).add('d', resSet.rawSP.duration);
          hotelEvent = {
            dayStart: checkIn._d,
            dayEnd: checkOut._d,
            type: 'hotel',
            description: '',
            city: resSet.rawSP.city
          };
          if (resSet.selection()) {
            console.log('select:', resSet.selection());
            hotelEvent.description = resSet.selection().hotel.hotelName;
          }
          calendarEvents.push(hotelEvent);
        }
      }
      calendarEvents.sort(function(left, right) {
        if (left.dayStart > right.dayStart) {
          return 1;
        }
        if (left.dayStart < right.dayStart) {
          return -1;
        }
        return 0;
      });
      console.log(calendarEvents);
      /*VoyangaCalendarTimeline.calendarEvents = [
        {dayStart: Date.fromIso('2012-10-23'),dayEnd: Date.fromIso('2012-10-23'),type:'flight',color:'red',description:' || -',cityFrom:'MOW',cityTo:'LED'},
        {dayStart: Date.fromIso('2012-10-23'),dayEnd: Date.fromIso('2012-10-28'),type:'hotel',color:'red',description:'Californication Hotel2',city:'LED'},
        {dayStart: Date.fromIso('2012-10-28'),dayEnd: Date.fromIso('2012-10-28'),type:'flight',color:'red',description:'- || ',cityFrom:'LED',cityTo:'MOW'},
        {dayStart: Date.fromIso('2012-10-28'),dayEnd: Date.fromIso('2012-10-28'),type:'flight',color:'red',description:' || -',cityFrom:'MOW',cityTo:'LED'},
        {dayStart: Date.fromIso('2012-11-21'),dayEnd: Date.fromIso('2012-11-22'),type:'flight',color:'red',description:'- || ',cityFrom:'LED',cityTo:'MOW'},
        {dayStart: Date.fromIso('2012-11-21'),dayEnd: Date.fromIso('2012-11-28'),type:'hotel',color:'red',description:'Californication Hotel',city:'MOW'},
        {dayStart: Date.fromIso('2012-11-28'),dayEnd: Date.fromIso('2012-11-28'),type:'flight',color:'red',description:' || -',cityFrom:'MOW',cityTo:'LED'},
        {dayStart: Date.fromIso('2012-11-28'),dayEnd: Date.fromIso('2012-11-28'),type:'flight',color:'red',description:'- || ',cityFrom:'LED',cityTo:'AMS'},
        {dayStart: Date.fromIso('2012-11-28'),dayEnd: Date.fromIso('2012-11-28'),type:'flight',color:'red',description:' || -',cityFrom:'AMS',cityTo:'LED'},
        {dayStart: Date.fromIso('2012-11-28'),dayEnd: Date.fromIso('2012-11-28'),type:'flight',color:'red',description:'- || ',cityFrom:'LED',cityTo:'MOW'},
      ]
      */

      VoyangaCalendarTimeline.calendarEvents = calendarEvents;
      VoyangaCalendarTimeline.jObj = '#voyanga-calendar-timeline';
      return VoyangaCalendarTimeline.init();
    }, 1000);
  };

  ToursResultSet.prototype.buy = function() {
    var ticketValidCheck,
      _this = this;
    ticketValidCheck = $.Deferred();
    ticketValidCheck.done(function(resultSet) {
      var toBuy, x, _i, _len, _ref;
      toBuy = [];
      _ref = resultSet.data();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        if (x.selection()) {
          toBuy.push({
            module: 'Tours'
          });
          toBuy.push(x.toBuyRequest());
        }
      }
      return Utils.toBuySubmit(toBuy);
    });
    return this.checkTicket(this.data(), ticketValidCheck);
  };

  ToursResultSet.prototype.findAndSelect = function(data) {
    var entry, index, success, _i, _len;
    console.log('findAndSelect');
    success = true;
    for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
      entry = data[index];
      if (!this.data()[index].findAndSelect(entry.selection())) {
        success = false;
      }
    }
    return success;
  };

  ToursResultSet.prototype.findAndSelectItems = function(items) {
    var entry, index, result, success, ts, _i, _j, _len, _len1, _ref;
    console.log('findAndSelectItems', items);
    success = true;
    this.data.sort(function(left, right) {
      var leftDate, rightDate, _ref, _ref1;
      leftDate = dateUtils.formatDayMonthYear(left.timelineStartDate());
      rightDate = dateUtils.formatDayMonthYear(right.timelineStartDate());
      if (leftDate === rightDate) {
        if (left.isAvia() !== right.isAvia()) {
          return (_ref = left.timelineEndDate() > right.timelineEndDate()) != null ? _ref : -{
            1: 1
          };
        }
      }
      return (_ref1 = left.timelineStartDate() > right.timelineStartDate()) != null ? _ref1 : -{
        1: 1
      };
    });
    _ref = this.data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ts = _ref[_i];
      console.log('ts entry', ts.timelineStart());
    }
    console.log('allTs', this.data());
    for (index = _j = 0, _len1 = items.length; _j < _len1; index = ++_j) {
      entry = items[index];
      console.log('findAndSelectItems entry', entry, ' in ', index, this.data()[index]);
      if (this.data()[index].isAvia()) {
        result = this.data()[index].findAndSelect(this.data()[index].results().cheapest());
        if (!result) {
          success = false;
          console.log('false res1:', result, this.data()[index], this.data()[index].results().cheapest());
        }
      } else {
        result = this.data()[index].findAndSelectSame(entry);
        if (!result) {
          success = false;
          console.log('false res2:', result, this.data()[index], entry);
        }
      }
    }
    return success;
  };

  return ToursResultSet;

})();

DestinationSearchParams = (function() {

  function DestinationSearchParams() {
    this.city = ko.observable('');
    this.dateFrom = ko.observable('');
    this.dateTo = ko.observable('');
  }

  return DestinationSearchParams;

})();

RoomsSearchParams = (function() {

  function RoomsSearchParams() {
    this.adt = ko.observable(2);
    this.chd = ko.observable(0);
    this.chdAge = ko.observable(false);
    this.cots = ko.observable(false);
  }

  return RoomsSearchParams;

})();

TourSearchParams = (function(_super) {

  __extends(TourSearchParams, _super);

  function TourSearchParams() {
    this.removeItem = __bind(this.removeItem, this);

    this.addSpRoom = __bind(this.addSpRoom, this);

    var _this = this;
    TourSearchParams.__super__.constructor.call(this);
    this.startCity = ko.observable('LED');
    this.destinations = ko.observableArray([]);
    this.rooms = ko.observableArray([new SpRoom(this)]);
    this.overall = ko.computed(function() {
      var result, room, _i, _len, _ref;
      result = 0;
      _ref = _this.rooms();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        room = _ref[_i];
        result += room.adults();
        result += room.children();
      }
      return result;
    });
    this.adults = ko.computed(function() {
      var result, room, _i, _len, _ref;
      result = 0;
      _ref = _this.rooms();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        room = _ref[_i];
        result += room.adults();
      }
      return result;
    });
    this.children = ko.computed(function() {
      var result, room, _i, _len, _ref;
      result = 0;
      _ref = _this.rooms();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        room = _ref[_i];
        result += room.children();
      }
      return result;
    });
    this.returnBack = ko.observable(1);
  }

  TourSearchParams.prototype.addSpRoom = function() {
    return this.rooms.push(new SpRoom(this));
  };

  TourSearchParams.prototype.url = function() {
    var params, result,
      _this = this;
    result = 'tour/search?';
    params = [];
    params.push('start=' + this.startCity());
    _.each(this.destinations(), function(destination, ind) {
      params.push('destinations[' + ind + '][city]=' + destination.city());
      params.push('destinations[' + ind + '][dateFrom]=' + moment(destination.dateFrom()).format('D.M.YYYY'));
      return params.push('destinations[' + ind + '][dateTo]=' + moment(destination.dateTo()).format('D.M.YYYY'));
    });
    _.each(this.rooms(), function(room, ind) {
      return params.push(room.getUrl(ind));
    });
    if (this.eventId) {
      params.push('eventId=' + this.eventId);
    }
    result += params.join("&");
    window.voyanga_debug("Generated search url for tours", result);
    return result;
  };

  TourSearchParams.prototype.key = function() {
    var key;
    key = this.startCity();
    _.each(this.destinations(), function(destination) {
      return key += destination.city() + destination.dateFrom() + destination.dateTo();
    });
    _.each(this.rooms(), function(room) {
      return key += room.getHash();
    });
    return key;
  };

  TourSearchParams.prototype.getHash = function() {
    var hash, parts;
    parts = [this.startCity(), this.returnBack()];
    _.each(this.destinations(), function(destination) {
      console.log('destination', destination);
      parts.push(destination.city());
      parts.push(moment(destination.dateFrom()).format('D.M.YYYY'));
      return parts.push(moment(destination.dateTo()).format('D.M.YYYY'));
    });
    parts.push('rooms');
    _.each(this.rooms(), function(room) {
      return parts.push(room.getHash());
    });
    hash = 'tours/search/' + parts.join('/') + '/';
    window.voyanga_debug("Generated hash for tour search", hash);
    return hash;
  };

  TourSearchParams.prototype.fromList = function(data) {
    var destination, doingrooms, i, oldSelection, room, _i, _ref;
    window.voyanga_debug("Restoring TourSearchParams from list");
    this.startCity(data[0]);
    this.returnBack(data[1]);
    doingrooms = false;
    this.destinations([]);
    this.rooms([]);
    for (i = _i = 2, _ref = data.length; _i <= _ref; i = _i += 3) {
      if (data[i] === 'rooms') {
        break;
      }
      destination = new DestinationSearchParams();
      destination.city(data[i]);
      destination.dateFrom(moment(data[i + 1], 'D.M.YYYY').toDate());
      destination.dateTo(moment(data[i + 2], 'D.M.YYYY').toDate());
      this.destinations.push(destination);
    }
    i = i + 1;
    oldSelection = false;
    while (i < data.length) {
      if (data[i] === 'eventId') {
        oldSelection = true;
        break;
      }
      room = new SpRoom(this);
      room.fromList(data[i]);
      this.rooms.push(room);
      i++;
    }
    if (oldSelection) {
      console.log('really have oldParams');
      i++;
      console.log('old params is', data[i]);
      this.eventId = data[i];
      /*@oldParams = JSON.parse(decodeURIComponent(data[i]))
      @oldItems = []
      for elem in @oldParams.ticketParams
        params = JSON.parse(elem);
        if(params.hotelId)
          console.log('try make hotel from params:',params)
          hotelItem = new HotelResult(params,null,false,null,null);
          @oldItems.push( hotelItem)
        else
          console.log('try make avia from params:',params)
          aviaItem = new AviaResult(params,null);
          @oldItems.push(aviaItem)
      console.log('items',@oldItems)
      
      
      console.log(@oldParams)
      */

    }
    return window.voyanga_debug('Result', this);
  };

  TourSearchParams.prototype.fromObject = function(data) {
    window.voyanga_debug("Restoring TourSearchParams from object");
    _.each(data.destinations, function(destination) {
      destination = new DestinationSearchParams();
      destination.city(destination.city);
      destination.dateFrom(moment(destination.dateFrom, 'D.M.YYYY').toDate());
      destination.dateTo(moment(destination.dateTo, 'D.M.YYYY').toDate());
      return this.destinations.push(destination);
    });
    _.each(data.rooms, function(room) {
      room = new SpRoom(this);
      return this.rooms.push(this.room.fromObject(room));
    });
    if (data.eventId) {
      this.eventId = data.eventId;
    }
    return window.voyanga_debug('Result', this);
  };

  TourSearchParams.prototype.removeItem = function(item, event) {
    var idx;
    event.stopPropagation();
    if (this.data().length < 2) {
      return;
    }
    idx = this.data.indexOf(item);
    if (idx === -1) {
      return;
    }
    this.data.splice(idx, 1);
    if (item === this.selection()) {
      return this.setActive(this.data()[0]);
    }
  };

  return TourSearchParams;

})(SearchParams);

ToursOverviewVM = (function() {

  function ToursOverviewVM(resultSet) {
    this.resultSet = resultSet;
    this.afterRender = __bind(this.afterRender, this);

    this.dateHtml = __bind(this.dateHtml, this);

    this.dateClass = __bind(this.dateClass, this);

    this.startCity = __bind(this.startCity, this);

  }

  ToursOverviewVM.prototype.startCity = function() {
    var firstResult;
    firstResult = this.resultSet.data()[0];
    if (firstResult.isAvia()) {
      return firstResult.results().departureCity;
    } else {
      return firstResult.results().city.caseNom;
    }
  };

  ToursOverviewVM.prototype.dateClass = function() {
    return 'blue-one';
  };

  ToursOverviewVM.prototype.dateHtml = function() {
    var firstResult;
    firstResult = this.resultSet.data()[0];
    return firstResult.dateHtml(true);
  };

  ToursOverviewVM.prototype.afterRender = function() {};

  return ToursOverviewVM;

})();

TourTripResultSet = (function() {

  function TourTripResultSet(resultSet) {
    var newCity,
      _this = this;
    this.resultSet = resultSet;
    this.items = [];
    this.cities = [];
    this.hasFlight = false;
    this.hasHotel = false;
    this.flightCounter = ko.observable(0);
    this.hotelCounter = ko.observable(0);
    this.selected_key = ko.observable('');
    this.selected_best = ko.observable('');
    this.totalCost = 0;
    this.totalCostWithDiscount = 0;
    this.totalCostWithoutDiscount = 0;
    this.tour = false;
    this.additional = false;
    this.flightIds = ko.observableArray([]);
    this.flightIdsString = ko.computed(function() {
      var resArr;
      resArr = _this.flightIds();
      return resArr.join(':');
    });
    this.showTariffRules = function() {
      var aviaApi;
      console.log('i wonna show tariff rules');
      aviaApi = new AviaAPI();
      return aviaApi.search('flight/search/tariffRules?flightIds=' + _this.flightIdsString(), function(data) {
        var code, gp, item, key, tariff, tariffs, _i, _len, _ref, _ref1;
        if (data) {
          tariffs = [];
          _ref = _this.items;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            if (item.isFlight && data[item._data.flightKey]) {
              tariff = {};
              tariff.route = "  " + item.departureCity() + "  " + item.arrivalCity();
              tariff.codes = [];
              _ref1 = data[item._data.flightKey];
              for (key in _ref1) {
                code = _ref1[key];
                tariff.codes.push(code);
              }
              tariffs.push(tariff);
            }
          }
          if (tariffs) {
            console.log(tariffs);
            return gp = new GenericPopup('#tariff-rules', {
              'tariffs': tariffs
            });
          }
        }
      });
    };
    this.flightCounterWord = ko.computed(function() {
      var res;
      if (_this.flightCounter() === 0) {
        return;
      }
      res = Utils.wordAfterNum(_this.flightCounter(), '', '', '');
      if (_this.hotelCounter() > 0) {
        res = res + ', ';
      }
      return res;
    });
    this.hotelCounterWord = ko.computed(function() {
      if (_this.hotelCounter() === 0) {
        return;
      }
      return Utils.wordAfterNum(_this.hotelCounter(), '', '', '');
    });
    _.each(this.resultSet.items, function(item) {
      var aviaResult, totalPeople;
      if (item.isFlight) {
        _this.tour = true;
        _this.hasFlight = true;
        _this.flightCounter(_this.flightCounter() + 1);
        _this.roundTrip = item.flights.length === 2;
        aviaResult = new AviaResult(item, _this);
        _this.flightIds.push(aviaResult._data.flightKey);
        aviaResult.sort();
        aviaResult.totalPeople = Utils.wordAfterNum(item.searchParams.adt + item.searchParams.chd + item.searchParams.inf, '', '', '');
        aviaResult.totalPeopleGen = Utils.wordAfterNum(item.searchParams.adt + item.searchParams.chd + item.searchParams.inf, '', '', '');
        if (_this.roundTrip) {
          _this.cities.push({
            isLast: false,
            cityName: item.flights[0].departureCity
          });
          _this.cities.push({
            isLast: false,
            cityName: item.flights[0].arrivalCity
          });
          _this.additional = {
            isLast: false,
            cityName: item.flights[0].departureCity
          };
        } else {
          _this.cities.push({
            isLast: false,
            cityName: item.flights[0].departureCity
          });
          _this.cities.push({
            isLast: false,
            cityName: item.flights[0].arrivalCity
          });
        }
        _this.items.push(aviaResult);
        _this.totalCostWithDiscount += aviaResult.price;
        return _this.totalCostWithoutDiscount = _this.totalCostWithDiscount;
      } else if (item.isHotel) {
        _this.hasHotel = true;
        _this.hotelCounter(_this.hotelCounter() + 1);
        _this.lastHotel = new HotelResult(item, _this, item.duration, item, item.hotelDetails);
        _this.cities.push({
          cityName: _this.lastHotel.activeHotel.city
        });
        totalPeople = 0;
        _.each(item.searchParams.rooms, function(room) {
          return totalPeople += room.adultCount / 1 + room.childCount / 1 + room.cots / 1;
        });
        _this.lastHotel.totalPeople = Utils.wordAfterNum(totalPeople, '', '', '');
        _this.lastHotel.totalPeopleGen = Utils.wordAfterNum(totalPeople, '', '', '');
        _this.items.push(_this.lastHotel);
        _this.totalCostWithDiscount += _this.lastHotel.roomSets()[0].discountPrice;
        return _this.totalCostWithoutDiscount += _this.lastHotel.roomSets()[0].price;
      }
    });
    if (this.additional) {
      this.cities.push(this.additional);
    }
    newCity = [];
    _.each(this.cities, function(city, i) {
      var a;
      a = _.last(newCity);
      if (!_.isObject(a)) {
        newCity.push(city);
      }
      if (_.last(newCity).cityName !== city.cityName) {
        return newCity.push(city);
      }
    });
    this.cities = newCity;
    _.each(this.cities, function(city, i) {
      if (i === (_this.cities.length - 1)) {
        return city.isLast = true;
      } else {
        city.left = Math.round((100 / _this.cities.length) * (i + 1) - 8.4);
        if (city.left < 0) {
          return city.left = '0%';
        } else {
          return city.left = city.left + '%';
        }
      }
    });
    if (this.tour) {
      this.totalCost = this.totalCostWithDiscount;
    } else {
      this.totalCost = this.totalCostWithoutDiscount;
    }
  }

  return TourTripResultSet;

})();
// Generated by CoffeeScript 1.4.0
/*
SEARCH controller, should be splitted once we will get more actions here
*/

var ToursController,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

ToursController = (function() {

  function ToursController(searchParams) {
    this.searchParams = searchParams;
    this.checkTicketAction = __bind(this.checkTicketAction, this);

    this.handleResults = __bind(this.handleResults, this);

    this.searchAction = __bind(this.searchAction, this);

    this.indexAction = __bind(this.indexAction, this);

    this.api = new ToursAPI;
    this.routes = {
      '/search/*rest': this.searchAction,
      '': this.indexAction
    };
    this.key = "tours_10";
    _.extend(this, Backbone.Events);
  }

  ToursController.prototype.indexAction = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    window.voyanga_debug("TOURS: Invoking indexAction", args);
    this.trigger("index", {});
    this.render('index');
    return ResizeAvia();
  };

  ToursController.prototype.searchAction = function() {
    var args,
      _this = this;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    args[0] = exTrim(args[0], '/');
    args = args[0].split('/');
    window.voyanga_debug("TOURS: Invoking searchAction", args);
    this.searchParams.fromList(args);
    return this.api.search(this.searchParams.url(), function(data) {
      if (!data || data.error) {
        console.error('sup');
        alert('HANDLE ME');
      }
      _this.stacked = _this.handleResults(data);
      _this.stacked.on('inner-template', function(data) {
        return _this.trigger('inner-template', data);
      });
      _this.trigger("results", _this.stacked);
      _this.render('results', _this.stacked);
      return ko.processAllDeferredBindingUpdates();
    });
  };

  ToursController.prototype.handleResults = function(data) {
    var hotel, item, items, postData, resultSet, stacked, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    console.log("Handling results", data);
    stacked = new ToursResultSet(data, this.searchParams);
    if (data.items) {
      items = [];
      _ref = data.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.isHotel) {
          hotel = new HotelResult(item, stacked, item.duration, item, item.hotelDetails);
          items.push(hotel);
        } else {
          items.push(new AviaResult(item, stacked));
        }
      }
      if (stacked.findAndSelectItems(items)) {
        stacked.showOverview();
        console.log('ssseeellleecctt', items, true);
        postData = [];
        _ref1 = stacked.data();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          resultSet = _ref1[_j];
          if (resultSet.isAvia()) {
            postData.push(resultSet.selection().getPostData());
          } else {
            postData.push(resultSet.selection().hotel.getPostData());
          }
          console.log('result:', resultSet.selection());
        }
        console.log('post data', postData, this.searchParams);
        $.ajax({
          url: this.api.endpoint + 'tour/search/updateEvent',
          data: {
            eventId: this.searchParams.eventId,
            startCity: this.searchParams.startCity(),
            items: postData
          },
          dataType: 'json',
          timeout: 90000,
          type: 'POST',
          success: function(data) {
            cb(data);
            if (showLoad) {
              $('#loadWrapBg').hide();
              return loaderChange(false);
            }
          },
          error: function() {}
        });
      } else {
        console.log('ssseeellleecctt', items, false);
      }
    }
    stacked.checkTicket = this.checkTicketAction;
    return stacked;
  };

  ToursController.prototype.checkTicketAction = function(toursData, resultDeferred) {
    var diff, now,
      _this = this;
    now = moment();
    diff = now.diff(this.stacked.creationMoment, 'seconds');
    if (diff < TOURS_TICKET_TIMELIMIT) {
      resultDeferred.resolve(this.stacked);
      return;
    }
    return this.api.search(this.searchParams.url(), function(data) {
      var result, stacked;
      try {
        stacked = _this.handleResults(data);
      } catch (err) {
        new ErrorPopup('avia500');
        return;
      }
      result = stacked.findAndSelect(toursData);
      if (result) {
        return resultDeferred.resolve(stacked);
      } else {
        new ErrorPopup('toursNoTicketOnValidation', false, function() {});
        return _this.results(stacked);
      }
    });
  };

  ToursController.prototype.render = function(view, data) {
    return this.trigger("viewChanged", view, data);
  };

  return ToursController;

})();
// Generated by CoffeeScript 1.4.0
/*
Tours module
Controller + panel
*/

var ToursModule;

ToursModule = (function() {

  function ToursModule() {
    var _this = this;
    this.panel = ko.observable(null);
    this.p = new TourPanelSet();
    this.innerTemplate = '';
    this.controller = new ToursController(this.p.sp);
    this.controller.on('results', function(results) {
      _this.panel(results.panel);
      return ko.processAllDeferredBindingUpdates();
    });
    this.controller.on('index', function(results) {
      return _this.panel(_this.p);
    });
    this.controller.on('inner-template', function(data) {
      return _this.innerTemplate = data;
    });
  }

  ToursModule.prototype.resize = function() {
    return ResizeAvia();
  };

  return ToursModule;

})();
// Generated by CoffeeScript 1.4.0
var HotelsPanel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

HotelsPanel = (function(_super) {

  __extends(HotelsPanel, _super);

  function HotelsPanel() {
    this.afterRender = __bind(this.afterRender, this);

    this.setDate = __bind(this.setDate, this);

    this.haveDates = __bind(this.haveDates, this);

    this.checkOutHtml = __bind(this.checkOutHtml, this);

    this.checkInHtml = __bind(this.checkInHtml, this);

    this.handlePanelSubmit = __bind(this.handlePanelSubmit, this);

    var _this = this;
    this.template = 'hotels-panel-template';
    HotelsPanel.__super__.constructor.call(this);
    this.prevPanel = 'avia';
    this.nextPanel = 'tours';
    this.icon = 'hotel-ico';
    this.mainLabel = ' ';
    this.indexMode = ko.observable(true);
    this.sp = new HotelsSearchParams();
    this.calendarHidden = ko.observable(true);
    this.city = this.sp.city;
    this.checkIn = this.sp.checkIn;
    this.checkOut = this.sp.checkOut;
    this.peopleSelectorVM = new HotelPeopleSelector(this.sp);
    this.cityReadable = ko.observable();
    this.cityReadableAcc = ko.observable();
    this.cityReadableGen = ko.observable();
    this.calendarText = ko.computed(function() {
      var ret;
      ret = "  ";
      if (_this.cityReadable()) {
        return ret += "   " + _this.cityReadable();
      }
    });
    this.prefixText = " <br>200 000+ ";
    this.formFilled = ko.computed(function() {
      var cin, cout, result;
      if (_this.checkIn().getDay) {
        cin = true;
      } else {
        cin = _this.checkIn().length > 0;
      }
      if (_this.checkOut().getDay) {
        cout = true;
      } else {
        cout = _this.checkOut().length > 0;
      }
      result = _this.city() && cin && cout;
      return result;
    });
    this.formNotFilled = ko.computed(function() {
      return !_this.formFilled();
    });
    this.maximizedCalendar = ko.computed(function() {
      return (_this.city().length > 0) && (!_.isObject(_this.checkIn()));
    });
    this.maximizedCalendar.subscribe(function(newValue) {
      if (!newValue) {
        return;
      }
      return _this.showCalendar();
    });
    this.calendarValue = ko.computed(function() {
      return {
        twoSelect: true,
        hotels: true,
        from: _this.checkIn(),
        to: _this.checkOut(),
        activeSearchPanel: _this
      };
    });
  }

  HotelsPanel.prototype.handlePanelSubmit = function() {
    app.navigate(this.sp.getHash(), {
      trigger: true
    });
    return this.minimizedCalendar(true);
  };

  HotelsPanel.prototype.checkInHtml = function() {
    if (this.checkIn()) {
      return dateUtils.formatHtmlDayShortMonth(this.checkIn());
    }
    return '';
  };

  HotelsPanel.prototype.checkOutHtml = function() {
    if (this.checkOut()) {
      return dateUtils.formatHtmlDayShortMonth(this.checkOut());
    }
    return '';
  };

  HotelsPanel.prototype.haveDates = function() {
    return this.checkOut() && this.checkIn();
  };

  HotelsPanel.prototype.navigateToNewSearch = function() {
    if (this.formNotFilled()) {
      return;
    }
    this.handlePanelSubmit();
    return this.minimizedCalendar(true);
  };

  HotelsPanel.prototype.setDate = function(values) {
    if (values.length) {
      this.checkIn(values[0]);
      if (values.length > 1) {
        if (values[0] < values[1]) {
          return this.checkOut(values[1]);
        } else {
          return this.checkOut('');
        }
      }
    }
  };

  HotelsPanel.prototype.afterRender = function() {
    return resizePanel();
  };

  return HotelsPanel;

})(SearchPanel);
// Generated by CoffeeScript 1.4.0
var HOTEL_SERVICE_VERBOSE, HotelResult, HotelsResultSet, MEAL_VERBOSE, Room, RoomSet, STARS_VERBOSE,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

STARS_VERBOSE = ['one', 'two', 'three', 'four', 'five'];

HOTEL_SERVICE_VERBOSE = {
  '': 'service',
  '  ': 'sport',
  '': 'turist',
  '': 'internet',
  '  ': 'dosug',
  '': 'parkovka',
  '': 'dop',
  ' ': 'in-hotel'
};

MEAL_VERBOSE = {
  ' ': '',
  ' ': '',
  '  ': '',
  ' + ': '  ',
  ' +  + ': '    ',
  ' +  +  + ': '      ',
  ' + ': '  ',
  ' ': '',
  '  ': ''
};

/*class googleInfoDiv extends google.maps.OverlayView
  constructor: ->
    @div_ = null
    @latLng = null
    @content = ''
  setPosition: (latLng)=>
    @latLng = latLng
    pos = getPosFromLatLng_(@latLng)
    if(@div_)
      @div_.css({'top': pos.y+'px','left': pos.x+'px'})
  setContent: (content)=>
    @content = content
    if(@div_)
      @div_.html(@content)
  draw: ()=>
    if(@div_)
      @latLng = latLng
      pos = getPosFromLatLng_(@latLng)
      @div_.css({'top': pos.y+'px','left': pos.x+'px'})
  onAdd: =>
    pos = getPosFromLatLng_(@latLng)
    divEl = $('<div style="background-color: #0ff; width: 50px; height: 5px;position: absolute">'+@content+'</div>')


    divEl.css({'top': pos.y+'px','left': pos.x+'px'})
    @div_ = divEl
    panes = @getPanes()
    $(panes.overlayMouseTarget).append(divEl)
  getPosFromLatLng_: (LatLng)=>
    pos = this.getProjection().fromLatLngToDivPixel(latlng);
    #pos.x -= parseInt(this.width_ / 2, 10);
    #pos.y -= parseInt(this.height_ / 2, 10);
    return pos
  hide: ()=>
    @div_.hide()
  show: ()=>
    @div_.show()
*/


Room = (function() {

  function Room(data) {
    this.getParams = __bind(this.getParams, this);

    this.printDebug = __bind(this.printDebug, this);

    this.key = __bind(this.key, this);

    var _this = this;
    this.name = data.showName;
    this.nameNemo = data.roomNemoName;
    if (!this.nameNemo || data.roomName) {
      this.nameNemo = data.roomName;
    }
    if (this.nameNemo !== '' && typeof this.nameNemo !== 'undefined') {
      this.haveNemoName = true;
    } else {
      this.haveNemoName = false;
      this.nameNemo = '';
    }
    this.roomData = data;
    this.meal = data.meal;
    if (data.mealName) {
      this.meal = data.mealName;
    }
    this.last = ko.observable(false);
    if (typeof this.meal === "undefined" || this.meal === '') {
      this.meal = ' ';
    }
    this.mealIcon = "ico-breakfast";
    if (MEAL_VERBOSE[this.meal]) {
      this.meal = MEAL_VERBOSE[this.meal];
    }
    this.hasMeal = this.meal !== ' ' && this.meal !== ' ';
    if (this.hasMeal && this.meal !== '') {
      this.mealIcon = "ico-breakfast-dinner";
    }
    this.debugInfo = ko.computed(function() {
      var propName, propVal, text, _ref;
      if (window.app.debugMode()) {
        text = 'debugInfo:{';
        _ref = _this.roomData;
        for (propName in _ref) {
          propVal = _ref[propName];
          text += propName + '=' + propVal + ', ';
        }
        text += '}';
        return text;
      }
      return false;
    });
  }

  Room.prototype.key = function() {
    return this.nameNemo + this.name + this.meal;
  };

  Room.prototype.printDebug = function() {
    return console.log('room data:', this.roomData);
  };

  Room.prototype.getParams = function() {
    var result;
    result = {};
    result.showName = this.name;
    result.nemoName = this.nameNemo;
    result.meal = this.meal;
    return result;
  };

  return Room;

})();

RoomSet = (function() {

  function RoomSet(data, parent, duration) {
    var room, _i, _len, _ref,
      _this = this;
    this.parent = parent;
    if (duration == null) {
      duration = 1;
    }
    this.hideCancelationRules = __bind(this.hideCancelationRules, this);

    this.showCancelationRules = __bind(this.showCancelationRules, this);

    this.addCancelationRules = __bind(this.addCancelationRules, this);

    this.similarityHash = __bind(this.similarityHash, this);

    this.key = __bind(this.key, this);

    this.minusCount = __bind(this.minusCount, this);

    this.plusCount = __bind(this.plusCount, this);

    this.checkCount = __bind(this.checkCount, this);

    this.getParams = __bind(this.getParams, this);

    this.price = Math.ceil(data.rubPrice);
    this.discountPrice = Math.ceil(data.discountPrice);
    this.savings = 0;
    this.resultId = data.resultId;
    this.searchId = data.searchId;
    this._data = data;
    this.pricePerNight = Math.ceil(this.price / duration);
    this.visible = ko.observable(true);
    this.cancelRules = ko.observable(false);
    this.cancelText = ko.computed(function() {
      var cancelObject, nowDate, result, _i, _len, _ref;
      if (_this.cancelRules()) {
        result = [];
        _ref = _this.cancelRules();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cancelObject = _ref[_i];
          if (cancelObject.charge) {
            nowDate = dateUtils.formatDayMonth(moment()._d);
            if (nowDate === dateUtils.formatDayMonth(cancelObject.cancelDate._d)) {
              result.push('    ' + Math.ceil(cancelObject.price) + ' ');
            } else {
              result.push('    ' + Math.ceil(cancelObject.price) + '   ' + dateUtils.formatDayMonth(cancelObject.cancelDate._d));
            }
          } else {
            result.push('     ');
          }
        }
        return result.join('<br>');
      } else {
        return '   ';
      }
    });
    this.rooms = [];
    _ref = data.rooms;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      room = _ref[_i];
      this.rooms.push(new Room(room));
    }
    this.rooms[this.rooms.length - 1].last(true);
    this.selectedCount = ko.observable(0);
    this.selectedCount.subscribe(function(newValue) {
      return _this.checkCount(newValue);
    });
    this.selectText = ko.computed(function() {
      if (!_this.parent.tours()) {
        return "";
      }
      if (_this.parent.activeResultId()) {
        return '';
      } else {
        return '';
      }
    });
  }

  RoomSet.prototype.getParams = function() {
    var room, roomsArr, _i, _len, _ref;
    roomsArr = [];
    _ref = this.rooms;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      room = _ref[_i];
      roomsArr.push(room.getParams());
    }
    return roomsArr;
  };

  RoomSet.prototype.checkCount = function(newValue) {
    var count;
    count = parseInt(newValue);
    if (count < 0 || isNaN(count)) {
      return this.selectedCount(0);
    } else {
      return this.selectedCount(count);
    }
  };

  RoomSet.prototype.plusCount = function() {
    return this.selectedCount(this.selectedCount() + 1);
  };

  RoomSet.prototype.minusCount = function() {
    if (this.selectedCount() > 0) {
      return this.selectedCount(this.selectedCount() - 1);
    }
  };

  RoomSet.prototype.key = function() {
    var result, room, _i, _len, _ref;
    result = this.price;
    _ref = this.rooms;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      room = _ref[_i];
      result += room.key();
    }
    return result;
  };

  RoomSet.prototype.similarityHash = function() {
    var result, room, _i, _len, _ref;
    result = "";
    _ref = this.rooms;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      room = _ref[_i];
      result += room.key();
    }
    return result;
  };

  RoomSet.prototype.addCancelationRules = function(roomSetData) {
    var cancelObject, _i, _len, _ref;
    if (roomSetData.cancelCharges) {
      roomSetData.cancelCharges.sort(function(left, right) {
        if (left.fromTimestamp < right.fromTimestamp) {
          return 1;
        } else if (left.fromTimestamp > right.fromTimestamp) {
          return -1;
        }
        return 0;
      });
      console.log('adding cancel rules', roomSetData.cancelCharges);
      _ref = roomSetData.cancelCharges;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cancelObject = _ref[_i];
        cancelObject.cancelDate = moment.unix(cancelObject.fromTimestamp);
        console.log('date convert', cancelObject, cancelObject.fromTimestamp, cancelObject.cancelDate);
      }
      return this.cancelRules(roomSetData.cancelCharges);
    }
  };

  RoomSet.prototype.showCancelationRules = function(el, e) {
    var offset, widthThisElement;
    console.log(e);
    widthThisElement = $(e.currentTarget).width();
    this.parent.activeRoomSet(this);
    this.parent.showRulesPopup(true);
    offset = $('#content > :eq(0)').offset();
    return $('.miniPopUp').css('left', (e.pageX - (widthThisElement / 2) - offset.left) + 'px').css('top', (e.pageY + 50 - offset.top) + 'px');
  };

  RoomSet.prototype.hideCancelationRules = function(el, ev) {
    return this.parent.showRulesPopup(false);
  };

  return RoomSet;

})();

HotelResult = (function() {

  function HotelResult(data, parent, duration, activeHotel, hotelDatails) {
    var elemId, elements, groupName, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
      _this = this;
    this.activeHotel = activeHotel;
    this.getPostData = __bind(this.getPostData, this);

    this.getParams = __bind(this.getParams, this);

    this.getLatLng = __bind(this.getLatLng, this);

    this.putToMap = __bind(this.putToMap, this);

    this.smallMapUrl = __bind(this.smallMapUrl, this);

    this.select = __bind(this.select, this);

    this.back = __bind(this.back, this);

    this.combinationClick = __bind(this.combinationClick, this);

    this.getFullInfo = __bind(this.getFullInfo, this);

    this.initFullInfo = __bind(this.initFullInfo, this);

    this.showMap = __bind(this.showMap, this);

    this.showMapInfo = __bind(this.showMapInfo, this);

    this.showMapDetails = __bind(this.showMapDetails, this);

    this.selectFromPopup = __bind(this.selectFromPopup, this);

    this.showDetails = __bind(this.showDetails, this);

    this.showPhoto = __bind(this.showPhoto, this);

    this.isActive = __bind(this.isActive, this);

    this.isFlight = false;
    this.isHotel = true;
    _.extend(this, Backbone.Events);
    if (!hotelDatails) {
      hotelDatails = {};
    }
    this.totalPeople = 0;
    this.tours = parent.tours || this.falseFunction;
    this.hotelId = data.hotelId;
    this.checkIn = moment(data.checkIn) || false;
    this.checkOut = moment(data.checkOut) || false;
    this.cityCode = data.cityCode || false;
    this.key = data.key;
    if (!this.checkOut && this.checkIn && duration) {
      this.checkOut = moment(this.checkIn);
      this.checkOut.add('d', duration);
    }
    if (this.checkOut) {
      this.checkOutText = this.checkOut.format('LL');
    }
    this.cacheId = parent.cacheId;
    this.activeResultId = ko.observable(0);
    this.hotelName = data.hotelName;
    this.address = hotelDatails.address;
    this.description = hotelDatails.description;
    if (!this.description) {
      this.description = "";
    }
    this.limitDesc = Utils.limitTextLenght(this.description, 195);
    this.showMoreDesc = ko.observable(true);
    this.showMoreDescText = ko.computed(function() {
      if (_this.showMoreDesc()) {
        return '';
      } else {
        return '';
      }
    });
    this.photos = hotelDatails.images;
    this.site = hotelDatails.site;
    this.metroList = [];
    if (hotelDatails.metroList) {
      _ref = hotelDatails.metroList;
      for (elemId in _ref) {
        elements = _ref[elemId];
        this.metroList.push(elements);
      }
    }
    this.locations = [];
    if (hotelDatails.locations) {
      _ref1 = hotelDatails.locations;
      for (elemId in _ref1) {
        elements = _ref1[elemId];
        this.locations.push(elements);
      }
    }
    this.phone = hotelDatails.phone;
    this.fax = hotelDatails.fax;
    this.email = hotelDatails.email;
    this.numberFloors = parseInt(hotelDatails.numberFloors);
    this.builtIn = parseInt(hotelDatails.builtIn);
    this.numPhotos = 0;
    this.parent = parent;
    this.checkInTime = hotelDatails.earliestCheckInTime;
    if (this.checkInTime) {
      if (this.checkIn) {
        this.checkInText = this.checkIn.format('LL') + ", c " + this.checkInTime;
      } else {
        console.log('strange ...', this.checkIn, this.checkInText, this.hotelName, this.hotelId);
      }
    } else {
      this.checkInText = this.checkIn.format('LL');
    }
    this.frontPhoto = {
      smallUrl: 'http://upload.wikimedia.org/wikipedia/en/thumb/7/78/Trollface.svg/200px-Trollface.svg.png',
      largeUrl: 'http://ya.ru'
    };
    if (this.photos && this.photos.length) {
      this.frontPhoto = this.photos[0];
      this.numPhotos = this.photos.length;
    }
    this.activePhoto = this.frontPhoto['largeUrl'];
    this.starsNumeric = data.categoryId;
    this.stars = STARS_VERBOSE[this.starsNumeric - 1];
    this.rating = data.rating;
    if (this.rating === '-') {
      this.rating = 0;
    }
    this.ratingName = '';
    if ((0 <= (_ref2 = this.rating) && _ref2 < 2)) {
      this.ratingName = "<br>";
    } else if ((2 <= (_ref3 = this.rating) && _ref3 < 2.5)) {
      this.ratingName = "<br>";
    } else if ((2.5 <= (_ref4 = this.rating) && _ref4 < 3.5)) {
      this.ratingName = "<br>";
    } else if ((3.5 <= (_ref5 = this.rating) && _ref5 < 4)) {
      this.ratingName = "<br>";
    } else if ((4 <= (_ref6 = this.rating) && _ref6 < 4.5)) {
      this.ratingName = " <br>";
    } else if ((4.5 <= (_ref7 = this.rating) && _ref7 <= 5)) {
      this.ratingName = "<br>";
    }
    this.lat = hotelDatails.latitude / 1;
    this.lng = hotelDatails.longitude / 1;
    this.distanceToCenter = Math.ceil(data.centerDistance / 1000);
    if (this.distanceToCenter > 30) {
      this.distanceToCenter = 30;
    }
    this.duration = duration;
    this.haveFullInfo = ko.observable(false);
    this.selectText = ko.computed(function() {
      if (!_this.tours()) {
        return "";
      }
      if (_this.isActive()) {
        return '';
      } else {
        return '';
      }
    });
    this.showRulesPopup = ko.observable(false);
    this.activeRoomSet = ko.observable(null);
    this.hasHotelServices = hotelDatails.hotelServices ? true : false;
    this.hotelServices = hotelDatails.hotelServices;
    this.hasHotelGroupServices = hotelDatails.hotelGroupServices ? true : false;
    this.hotelGroupServices = [];
    if (hotelDatails.hotelGroupServices) {
      _ref8 = hotelDatails.hotelGroupServices;
      for (groupName in _ref8) {
        elements = _ref8[groupName];
        this.hotelGroupServices.push({
          groupName: groupName,
          elements: elements,
          groupIcon: HOTEL_SERVICE_VERBOSE[groupName]
        });
      }
    }
    this.hasRoomAmenities = hotelDatails.roomAmenities ? true : false;
    this.roomAmenities = hotelDatails.roomAmenities;
    this.roomSets = ko.observableArray([]);
    this.visible = ko.observable(true);
    this.wordDays = this.parent.wordDays;
    this.visibleRoomSets = ko.computed(function() {
      var result, roomSet, _i, _len, _ref9;
      result = [];
      _ref9 = _this.roomSets();
      for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
        roomSet = _ref9[_i];
        if (roomSet.visible()) {
          result.push(roomSet);
        }
      }
      return result;
    });
    this.isShowAll = ko.observable(false);
    this.showAllText = ko.computed(function() {
      if (_this.isShowAll()) {
        return '  ';
      } else {
        return '  ';
      }
    });
    this.push(data);
  }

  HotelResult.prototype.falseFunction = function() {
    return false;
  };

  HotelResult.prototype.push = function(data) {
    var set,
      _this = this;
    set = new RoomSet(data, this, this.duration);
    set.resultId = data.resultId;
    set.searchId = data.searchId;
    if (this.hotelId === '17897') {
      console.log('setPrice', set.price);
    }
    if (this.roomSets().length === 0) {
      this.cheapest = set.price;
      this.cheapestSet = set;
      this.minPrice = set.pricePerNight;
      this.maxPrice = set.pricePerNight;
    } else {
      if (set.price < this.cheapest) {
        this.cheapestSet = set;
        console.log('set cheapest setPrice', set.price);
      }
      this.cheapest = set.price < this.cheapest ? set.price : this.cheapest;
      this.minPrice = set.pricePerNight < this.minPrice ? set.pricePerNight : this.minPrice;
      this.maxPrice = set.pricePerNight > this.maxPrice ? set.pricePerNight : this.maxPrice;
    }
    this.roomSets.push(set);
    this.activeRoomSet(set);
    return this.roomSets.sort(function(left, right) {
      if (left.price > right.price) {
        return 1;
      } else if (left.price < right.price) {
        return -1;
      }
      return 0;
    });
  };

  HotelResult.prototype.isActive = function() {
    if (this.activeHotel) {
      return this.activeHotel() === this.hotelId;
    }
    return false;
  };

  HotelResult.prototype.showPhoto = function(fp, ev) {
    var ind;
    ind = $(ev.currentTarget).data('photo-index');
    if (!ind) {
      ind = 0;
    }
    return new PhotoBox(this.photos, this.hotelName, this.stars, ind);
  };

  HotelResult.prototype.showAllResults = function(data, event) {
    if (this.isShowAll()) {
      $(event.currentTarget).parent().parent().find('.hidden-roomSets').hide('fast');
      return this.isShowAll(false);
    } else {
      $(event.currentTarget).parent().parent().find('.hidden-roomSets').show('fast');
      return this.isShowAll(true);
    }
  };

  HotelResult.prototype.showDetails = function(data, event) {
    this.oldPageTop = $('html').scrollTop() | $('body').scrollTop();
    this.readMoreExpanded = false;
    this.activePopup = new GenericPopup('#hotels-body-popup', this);
    SizeBox('hotels-body-popup');
    ResizeBox('hotels-body-popup');
    return this.mapInitialized = false;
  };

  HotelResult.prototype.selectFromPopup = function(hotel, event) {
    var _this = this;
    this.activePopup.close();
    hotel.off('back');
    hotel.on('back', function() {
      window.app.render({
        results: ko.observable(hotel.parent)
      }, 'results');
      return window.setTimeout(function() {
        Utils.scrollTo(hotel.oldPageTop, false);
        return console.log(hotel.oldPageTop);
      }, 50);
    });
    hotel.getFullInfo();
    window.app.render(hotel, 'info-template');
    return Utils.scrollTo('#content', false);
  };

  HotelResult.prototype.showMapDetails = function(data, event) {
    this.showDetails(data, event);
    return this.showMap();
  };

  HotelResult.prototype.showMapInfo = function(context, event) {
    var coords, el, map, mapOptions, marker;
    event.preventDefault();
    el = $('#hotel-info-tumblr-map');
    if (el.hasClass('active')) {
      return;
    }
    $('.place-buy .tmblr li').removeClass('active');
    el.addClass('active');
    $('#descr').hide();
    $('#map').show();
    if (!this.mapInitialized) {
      coords = new google.maps.LatLng(this.lat, this.lng);
      mapOptions = {
        center: coords,
        zoom: 12,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      map = new google.maps.Map($('#hotel-info-gmap')[0], mapOptions);
      marker = new google.maps.Marker({
        position: coords,
        map: map,
        title: this.hotelName
      });
      return this.mapInitialized = true;
    }
  };

  HotelResult.prototype.showDescriptionInfo = function(context, event) {
    var el;
    el = $('#hotel-info-tumblr-description');
    if (el.hasClass('active')) {
      return;
    }
    $('.place-buy .tmblr li').removeClass('active');
    el.addClass('active');
    $('#map').hide();
    $('#descr').show();
    return $('#boxContent').css('height', 'auto');
  };

  HotelResult.prototype.showMap = function(context, event) {
    var coords, el, map, mapOptions, marker;
    el = $('#hotels-popup-tumblr-map');
    if (el.hasClass('active')) {
      return;
    }
    $('.place-buy .tmblr li').removeClass('active');
    el.addClass('active');
    $('.tab').hide();
    $('#hotels-popup-map').show();
    $('#boxContent').css('height', $('#hotels-popup-map').height() + $('#hotels-popup-header1').height() + $('#hotels-popup-header2').height() + 'px');
    if (!this.mapInitialized) {
      coords = new google.maps.LatLng(this.lat, this.lng);
      mapOptions = {
        center: coords,
        zoom: 12,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      map = new google.maps.Map($('#hotels-popup-gmap')[0], mapOptions);
      marker = new google.maps.Marker({
        position: coords,
        map: map,
        title: this.hotelName
      });
      this.mapInitialized = true;
    }
    return SizeBox('hotels-popup-body');
  };

  HotelResult.prototype.showDescription = function(context, event) {
    var el;
    el = $('#hotels-popup-tumblr-description');
    if (el.hasClass('active')) {
      return;
    }
    $('.place-buy .tmblr li').removeClass('active');
    el.addClass('active');
    $('.tab').hide();
    $('#hotels-popup-description').show();
    $('#boxContent').css('height', 'auto');
    return SizeBox('hotels-popup-body');
  };

  HotelResult.prototype.initFullInfo = function() {
    var _this = this;
    this.roomCombinations = ko.observableArray([]);
    this.combinedPrice = ko.computed(function() {
      var res, roomSet, _i, _len, _ref;
      res = 0;
      _ref = _this.roomCombinations();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        roomSet = _ref[_i];
        if (roomSet.selectedCount()) {
          res += roomSet.selectedCount() * roomSet.price;
        }
      }
      return res;
    });
    return this.combinedButtonLabel = ko.computed(function() {
      if (_this.combinedPrice() > 0) {
        return _this.selectText();
      } else {
        return '  ';
      }
    });
  };

  HotelResult.prototype.getFullInfo = function() {
    var api, hotelResults, key, roomSet, url, _i, _len, _ref,
      _this = this;
    if (!this.haveFullInfo()) {
      api = new HotelsAPI;
      hotelResults = [];
      _ref = this.roomSets();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        roomSet = _ref[_i];
        key = roomSet.resultId;
        hotelResults.push(roomSet.resultId + ':' + roomSet.searchId);
      }
      url = 'hotel/search/info/?hotelId=' + this.hotelId;
      url += '&hotelResult=' + hotelResults.join(',');
      console.log(this.parent.cacheId);
      return api.search(url, function(data) {
        var cancelObjs, ind, set, _j, _len1, _ref1, _ref2, _ref3;
        window.voyanga_debug('searchInfo', data);
        if (!data.hotel) {
          return false;
        }
        _this.initFullInfo();
        _ref1 = data.hotel.details;
        for (ind in _ref1) {
          roomSet = _ref1[ind];
          set = new RoomSet(roomSet, _this, _this.duration);
          _this.roomCombinations.push(set);
        }
        cancelObjs = {};
        _ref2 = data.hotel.oldHotels;
        for (ind in _ref2) {
          roomSet = _ref2[ind];
          key = roomSet.resultId;
          cancelObjs[key] = roomSet;
        }
        console.log(cancelObjs);
        _ref3 = _this.roomSets();
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          roomSet = _ref3[_j];
          key = roomSet.resultId;
          if (cancelObjs[key]) {
            roomSet.addCancelationRules(cancelObjs[key]);
          } else {
            console.log('not found result with key', key);
          }
        }
        _this.roomMixed = ko.computed(function() {
          var result, resultsObj, _k, _l, _len2, _len3, _ref4, _ref5;
          resultsObj = {};
          _ref4 = _this.roomSets();
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            roomSet = _ref4[_k];
            key = roomSet.key();
            if (typeof resultsObj[key] === 'undefined') {
              resultsObj[key] = roomSet;
            }
          }
          _ref5 = _this.roomCombinations();
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            roomSet = _ref5[_l];
            key = roomSet.key();
            if (typeof resultsObj[key] === 'undefined') {
              resultsObj[key] = roomSet;
            }
          }
          result = [];
          for (key in resultsObj) {
            roomSet = resultsObj[key];
            result.push(roomSet);
          }
          return result;
        });
        _this.haveFullInfo(true);
        return console.log(_this.roomCombinations());
      }, false);
    }
  };

  HotelResult.prototype.combinationClick = function() {
    return console.log('combinati data = _.filter @data(), (el) -> el.visible()on click');
  };

  HotelResult.prototype.readMore = function(context, event) {
    var el, text_el;
    el = $(event.currentTarget);
    text_el = el.parent().find('.text');
    if (this.showMoreDesc()) {
      text_el.find('.endDesc').fadeIn('fast', function() {
        return text_el.find('.endDesc').css('display', 'inline');
      });
      this.showMoreDesc(false);
    } else {
      text_el.find('.endDesc').fadeOut('fast');
      this.showMoreDesc(true);
    }
    return SizeBox('hotels-popup-body');
  };

  HotelResult.prototype.back = function() {
    return this.trigger('back');
  };

  HotelResult.prototype.select = function(room) {
    var ticketValidCheck,
      _this = this;
    console.log(room);
    if (room.roomSets) {
      room = room.roomSets()[0];
      Utils.scrollTo('.info-trip');
      return;
    }
    if (this.tours()) {
      this.activeResultId(room.resultId);
      return this.trigger('select', {
        roomSet: room,
        hotel: this
      });
    } else {
      ticketValidCheck = $.Deferred();
      ticketValidCheck.done(function(roomSet) {
        var result, _i, _len, _ref;
        result = {};
        result.module = 'Hotels';
        result.type = 'hotel';
        result.searchId = roomSet.parent.cacheId;
        result.searchKey = roomSet.resultId;
        result.adults = 0;
        result.age = false;
        result.cots = 0;
        _ref = _this.parent.rawSP.rooms;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          room = _ref[_i];
          result.adults += room.adultCount * 1;
          if (room.childAge) {
            result.age = room.childAgeage;
          }
          result.cots += room.cots * 1;
        }
        return Utils.toBuySubmit([result]);
      });
      return this.parent.checkTicket(room, ticketValidCheck);
    }
  };

  HotelResult.prototype.smallMapUrl = function() {
    var base;
    base = "http://maps.googleapis.com/maps/api/staticmap?zoom=13&size=310x259&maptype=roadmap&markers=icon:http://test.voyanga.com/themes/v2/images/pin1.png%7Ccolor:red%7Ccolor:red%7C";
    base += "%7C";
    base += this.lat + "," + this.lng;
    base += "&sensor=false";
    return base;
  };

  HotelResult.prototype.putToMap = function(gMap) {
    var city, country, gMarker, latLng,
      _this = this;
    if (this.lat && this.lng) {
      console.log('add point to coords', this.lat, this.lng);
      latLng = new google.maps.LatLng(this.lat, this.lng);
      this.parent.addMapPoint(latLng);
      gMarker = new google.maps.Marker({
        position: latLng,
        map: gMap,
        icon: this.parent.markerImage,
        draggable: false
      });
      this.gMarker = gMarker;
      google.maps.event.addListener(gMarker, 'mouseover', (function(hotel) {
        return function(ev) {
          return _this.parent.gMapPointShowWin(ev, hotel);
        };
      })(this));
      google.maps.event.addListener(gMarker, 'mouseout', (function(hotel) {
        return function(ev) {
          return _this.parent.gMapPointHideWin(ev, hotel);
        };
      })(this));
      google.maps.event.addListener(gMarker, 'click', (function(hotel) {
        return function(ev) {
          return _this.parent.gMapPointClick(ev, hotel);
        };
      })(this));
      return this.parent.gMarkers.push(gMarker);
    } else {
      city = this.parent.city.localEn;
      country = this.parent.city.country ? ', ' + this.parent.city.country : '';
      return this.parent.gMapGeocoder.geocode({
        address: this.address + ', ' + city + country
      }, function(geoInfo, status) {
        console.log(geoInfo);
        if (status === google.maps.GeocoderStatus.OK) {
          _this.lat = geoInfo[0].geometry.location.lat();
          _this.lng = geoInfo[0].geometry.location.lng();
          _this.putToMap(gMap);
          return _this.parent.mapCluster.addMarker(_this.gMarker);
        }
      });
    }
  };

  HotelResult.prototype.getLatLng = function() {
    var city, country, gMapGeocoder,
      _this = this;
    this.latLng = ko.observable(new google.maps.LatLng(this.lat, this.lng));
    if (this.lat && this.lng) {

    } else {
      city = this.parent.city.localEn;
      country = this.parent.city.country ? ', ' + this.parent.city.country : '';
      gMapGeocoder = new google.maps.Geocoder();
      gMapGeocoder.geocode({
        address: this.address + ', ' + city + country
      }, function(geoInfo, status) {
        console.log(geoInfo);
        if (status === google.maps.GeocoderStatus.OK) {
          _this.lat = geoInfo[0].geometry.location.lat();
          _this.lng = geoInfo[0].geometry.location.lng();
          return _this.latLng(new google.maps.LatLng(_this.lat, _this.lng));
        }
      });
    }
    return this.latLng;
  };

  HotelResult.prototype.getParams = function() {
    var result;
    result = {};
    result.hotelId = this.hotelId;
    result.roomSet = this.roomSets()[0].getParams();
    return JSON.stringify(result);
  };

  HotelResult.prototype.getPostData = function() {
    var result;
    result = {};
    result.data = this.roomSets()[0]._data;
    result.type = 'hotel';
    return result;
  };

  return HotelResult;

})();

HotelsResultSet = (function() {

  function HotelsResultSet(rawData, searchParams, activeHotel) {
    var checkIn, checkOut, duration, hotel, key, result, _i, _j, _len, _len1, _ref, _ref1, _ref2,
      _this = this;
    this.searchParams = searchParams;
    this.activeHotel = activeHotel;
    this.postFilters = __bind(this.postFilters, this);

    this.postInit = __bind(this.postInit, this);

    this.selectHotel = __bind(this.selectHotel, this);

    this.sortByRating = __bind(this.sortByRating, this);

    this.sortByPrice = __bind(this.sortByPrice, this);

    this.checkShowMore = __bind(this.checkShowMore, this);

    this.showMoreResults = __bind(this.showMoreResults, this);

    this.getDateInterval = __bind(this.getDateInterval, this);

    this.selectFromPopup = __bind(this.selectFromPopup, this);

    this.gMapPointClick = __bind(this.gMapPointClick, this);

    this.gMapPointHideWin = __bind(this.gMapPointHideWin, this);

    this.gMapPointShowWin = __bind(this.gMapPointShowWin, this);

    this.hideFullMap = __bind(this.hideFullMap, this);

    this.showFullMapFunc = __bind(this.showFullMapFunc, this);

    this.setFullMapZoom = __bind(this.setFullMapZoom, this);

    this.addMapPoint = __bind(this.addMapPoint, this);

    this.resetMapCenter = __bind(this.resetMapCenter, this);

    this.findAndSelectSameParams = __bind(this.findAndSelectSameParams, this);

    this.findAndSelectSame = __bind(this.findAndSelectSame, this);

    this.findAndSelect = __bind(this.findAndSelect, this);

    this.select = __bind(this.select, this);

    this._results = {};
    if (rawData.error) {
      throw rawData.error;
    }
    if (!rawData.hotels) {
      throw "404";
    }
    this.creationMoment = moment();
    this.rawSP = this.searchParams;
    this.cacheId = rawData.cacheId;
    this.tours = ko.observable(false);
    this.checkIn = moment(this.searchParams.checkIn);
    this.checkOut = moment(this.checkIn).add('days', this.searchParams.duration);
    window.voyanga_debug('checkOut', this.checkOut);
    this.city = this.searchParams.cityFull;
    if (this.searchParams.duration) {
      duration = this.searchParams.duration;
    }
    if (duration === 0 || typeof duration === 'undefined') {
      _ref = rawData.hotels;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hotel = _ref[_i];
        if (typeof hotel.duration === 'undefined') {
          checkIn = dateUtils.fromIso(hotel.checkIn);
          console.log(checkIn);
          checkOut = dateUtils.fromIso(hotel.checkOut);
          console.log(hotel.checkOut);
          console.log(checkOut);
          duration = checkOut.valueOf() - checkIn.valueOf();
          duration = Math.floor(duration / (3600 * 24 * 1000));
        } else {
          duration = hotel.duration;
          console.log('yes set');
        }
        break;
      }
    }
    this.wordDays = Utils.wordAfterNum(duration, '', '', '');
    this.wordNights = Utils.wordAfterNum(duration, '', '', '');
    this.fullMapInitialized = false;
    this.showFullMap = ko.observable(false);
    this.minPrice = false;
    this.maxPrice = false;
    _ref1 = rawData.hotels;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      hotel = _ref1[_j];
      key = hotel.hotelId;
      if (this._results[key]) {
        this._results[key].push(hotel);
        this.minPrice = this._results[key].minPrice < this.minPrice ? this._results[key].minPrice : this.minPrice;
        this.maxPrice = this._results[key].maxPrice > this.maxPrice ? this._results[key].maxPrice : this.maxPrice;
      } else {
        result = new HotelResult(hotel, this, duration, this.activeHotel, rawData.hotelsDetails[key + 'd']);
        this._results[key] = result;
        if (this.minPrice === false) {
          this.minPrice = this._results[key].minPrice;
          this.maxPrice = this._results[key].maxPrice;
        } else {
          this.minPrice = this._results[key].minPrice < this.minPrice ? this._results[key].minPrice : this.minPrice;
          this.maxPrice = this._results[key].maxPrice > this.maxPrice ? this._results[key].maxPrice : this.maxPrice;
        }
      }
    }
    this.data = ko.observableArray();
    this.showParts = ko.observable(1);
    this.showLimit = 20;
    this.sortBy = ko.observable('minPrice');
    this.ordBy = ko.observable(1);
    this.resultsForRender = ko.computed(function() {
      var limit, ordKey, results, sortKey, _k, _len2, _ref2;
      limit = _this.showParts() * _this.showLimit;
      results = [];
      sortKey = _this.sortBy();
      ordKey = _this.ordBy();
      _this.data.sort(function(left, right) {
        if (left[sortKey] < right[sortKey]) {
          return -1 * ordKey;
        }
        if (left[sortKey] > right[sortKey]) {
          return 1 * ordKey;
        }
        return 0;
      });
      _ref2 = _this.data();
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        result = _ref2[_k];
        if (result.visible()) {
          results.push(result);
          limit--;
        }
        if (limit <= 0) {
          break;
        }
      }
      return results;
    });
    this.numResults = ko.observable(0);
    this.filtersConfig = false;
    this.pagesLoad = false;
    this.toursOpened = false;
    window.hotelsScrollCallback = function(ev) {
      return _this.checkShowMore(ev);
    };
    _ref2 = this._results;
    for (key in _ref2) {
      result = _ref2[key];
      if (result.numPhotos) {
        this.data.push(result);
      }
    }
    this.sortByPriceClass = ko.computed(function() {
      var ret;
      ret = 'hotel-sort-by-item';
      if (_this.sortBy() === 'minPrice') {
        ret += ' active';
      }
      return ret;
    });
    this.sortByRatingClass = ko.computed(function() {
      var ret;
      ret = 'hotel-sort-by-item';
      if (_this.sortBy() === 'rating') {
        ret += ' active';
      }
      return ret;
    });
    this.data.sort(function(left, right) {
      if (left.minPrice < right.minPrice) {
        return -1;
      }
      if (left.minPrice > right.minPrice) {
        return 1;
      }
      return 0;
    });
    window.hrs = this;
  }

  HotelsResultSet.prototype.select = function(hotel, event) {
    var _this = this;
    window.voyanga_debug(' i wonna get hotel for you', hotel);
    hotel.oldPageTop = $("html").scrollTop() | $("body").scrollTop();
    hotel.off('back');
    hotel.on('back', function() {
      window.app.render({
        results: ko.observable(_this)
      }, 'results');
      return window.setTimeout(function() {
        if (!_this.showFullMap()) {
          Utils.scrollTo(hotel.oldPageTop, false);
          return Utils.scrollTo('#hotelResult' + hotel.hotelId);
        } else {
          _this.showFullMapFunc(null, null, true);
          _this.gAllMap.setCenter(_this.gMapCenter);
          return _this.gAllMap.setZoom(_this.gMapZoom);
        }
      }, 50);
    });
    hotel.getFullInfo();
    window.app.render(hotel, 'info-template');
    return Utils.scrollTo('#content', false);
  };

  HotelsResultSet.prototype.findAndSelect = function(roomSet) {
    var hotel, possibleRoomSet, _i, _j, _len, _len1, _ref, _ref1;
    console.log('find roomSet', roomSet, 'hotelId', roomSet.parent.hotelId);
    _ref = this.data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hotel = _ref[_i];
      if (hotel.hotelId === roomSet.parent.hotelId) {
        console.log('ok, hotel found2');
        _ref1 = hotel.roomSets();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          possibleRoomSet = _ref1[_j];
          if (possibleRoomSet.similarityHash() === roomSet.similarityHash()) {
            return possibleRoomSet;
          }
        }
      }
    }
    return false;
  };

  HotelsResultSet.prototype.findAndSelectSame = function(roomSet) {
    var hotel, possibleRoomSet, result, _i, _j, _len, _len1, _ref, _ref1;
    result = false;
    result = this.findAndSelect(roomSet);
    if (!result) {
      _ref = this.data();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hotel = _ref[_i];
        if (hotel.hotelId === roomSet.parent.hotelId) {
          console.log('ok, hotel found');
          _ref1 = hotel.roomSets();
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            possibleRoomSet = _ref1[_j];
            return possibleRoomSet;
          }
        }
      }
    }
    return result;
  };

  HotelsResultSet.prototype.findAndSelectSameParams = function(stars, latLngObservable) {
    var dist, hotel, minDistance, minPrice, possibleRoomSet, sameHotel, _i, _j, _len, _len1, _ref, _ref1;
    sameHotel = false;
    minDistance = 5000;
    minPrice = 99999;
    _ref = this.data();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hotel = _ref[_i];
      if (!sameHotel) {
        sameHotel = hotel;
      }
      if (hotel.categoryId === stars) {
        dist = Utils.calculateTheDistance(latLngObservable().lat(), latLngObservable().lng(), hotel.lat, hotel.lng);
        if (dist > 5000) {
          dist = 5000;
        }
        if ((dist * 2 + hotel.minPrice) < (minDistance * 2 + minPrice)) {
          sameHotel = hotel;
          minDistance = dist;
          minPrice = hotel.minPrice;
        }
      }
    }
    _ref1 = sameHotel.roomSets();
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      possibleRoomSet = _ref1[_j];
      return possibleRoomSet;
    }
  };

  HotelsResultSet.prototype.resetMapCenter = function() {
    return this.computedCenter = new google.maps.LatLngBounds();
  };

  HotelsResultSet.prototype.addMapPoint = function(latLng) {
    return this.computedCenter.extend(latLng);
  };

  HotelsResultSet.prototype.setFullMapZoom = function() {
    this.gAllMap.fitBounds(this.computedCenter);
    return this.gAllMap.setCenter(this.computedCenter.getCenter());
  };

  HotelsResultSet.prototype.showFullMapFunc = function(targetObject, event, fromBackAction, fromFilters) {
    var offset, posTop, stime,
      _this = this;
    if (fromBackAction == null) {
      fromBackAction = false;
    }
    if (fromFilters == null) {
      fromFilters = false;
    }
    console.log('show full map', fromBackAction, fromFilters);
    this.oldPageTop = $("html").scrollTop() | $("body").scrollTop();
    if (!this.showFullMap()) {
      Utils.scrollTo('#content');
    }
    stime = 400;
    offset = $('#content').offset();
    posTop = $('html').scrollTop() || $('body').scrollTop();
    if (!this.showFullMap() || Math.abs(posTop - offset.top) < 4) {
      stime = 100;
    }
    return window.setTimeout(function() {
      var center, hotel, options, _i, _len, _ref;
      _this.showFullMap(true);
      $('#all-hotels-results').hide();
      $('#all-hotels-map').show();
      mapAllPageView();
      center = new google.maps.LatLng(_this.city.latitude, _this.city.longitude);
      options = {
        'zoom': 10,
        'center': center,
        'mapTypeId': google.maps.MapTypeId.ROADMAP
      };
      _this.fullMapInitialized = false;
      _this.mapCluster = null;
      if (!_this.fullMapInitialized) {
        _this.gAllMap = new google.maps.Map($('#all-hotels-map')[0], options);
        window.gmap = _this.gAllMap;
        _this.markerImage = new google.maps.MarkerImage('/themes/v2/images/pin1.png', new google.maps.Size(31, 31));
        _this.markerImageHover = new google.maps.MarkerImage('/themes/v2/images/pin2.png', new google.maps.Size(31, 31));
        _this.gMapGeocoder = new google.maps.Geocoder();
        _this.resetMapCenter();
        _this.gMapOverlay = new googleInfoDiv();
        console.log(_this.gMapOverlay);
        _this.gMapOverlay.setPosition(center);
        _this.gMapOverlay.setMap(_this.gAllMap);
        console.log(_this.gMapOverlay);
        _this.gMapOverlay.hide();
        _this.clusterStyle = [
          {
            url: '/themes/v2/images/cluster_one.png',
            height: 43,
            width: 31,
            anchor: [7, 0],
            textColor: '#000',
            textSize: 18
          }, {
            url: '/themes/v2/images/cluster_two.png',
            height: 54,
            width: 39,
            anchor: [11, 0],
            textColor: '#000',
            textSize: 18
          }, {
            url: '/themes/v2/images/cluster_three.png',
            height: 65,
            width: 47,
            anchor: [15, 0],
            textColor: '#000',
            textSize: 18
          }
        ];
      }
      _this.gMarkers = [];
      _ref = _this.data();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hotel = _ref[_i];
        if (hotel.visible()) {
          hotel.putToMap(_this.gAllMap);
        }
      }
      if (!_this.fullMapInitialized) {
        _this.mapCluster = new MarkerClusterer(_this.gAllMap, _this.gMarkers, {
          styles: _this.clusterStyle
        });
        _this.fullMapInitialized = true;
      } else {
        _this.mapCluster.addMarkers(_this.gMarkers);
      }
      console.log(_this.gAllMap);
      console.log(_this.gMapInfoWin);
      if (fromBackAction && _this.gMapCenter && _this.gMapZoom) {
        _this.gAllMap.setCenter(_this.gMapCenter);
        _this.gAllMap.setZoom(_this.gMapZoom);
      } else if (_this.gMarkers.length > 0) {
        _this.setFullMapZoom();
      }
      if (!fromFilters) {
        console.log('minimizeFilter');
        return minimizeFilter();
      }
    }, stime);
  };

  HotelsResultSet.prototype.hideFullMap = function() {
    var _this = this;
    console.log('hideFullMap');
    $('#all-hotels-results').show();
    $('#all-hotels-map').hide();
    this.showFullMap(false);
    return window.setTimeout(function() {
      removeFilterShow();
      jsPaneScrollHeight();
      return Utils.scrollTo(_this.oldPageTop);
    }, 50);
  };

  HotelsResultSet.prototype.gMapPointShowWin = function(event, hotel) {
    var div;
    console.log('showDiv', event);
    div = '<div id="relInfoPosition"><div id="infoWrapperDiv"><div class="hotelMapInfo"><div class="hotelMapImage"><img src="' + hotel.frontPhoto.largeUrl + '"></div><div class="stars ' + hotel.stars + '"></div><div class="hotelMapName">' + hotel.hotelName + '</div><div class="mapPriceDiv"> <div class="mapPriceValue">' + hotel.minPrice + '</div> <span class="rur">o</span>/</div></div></div></div>';
    this.gMapOverlay.setContent(div);
    this.gMapOverlay.setPosition(event.latLng);
    this.gMapOverlay.show();
    console.log(this.gMapOverlay);
    return hotel.gMarker.setIcon(this.markerImageHover);
  };

  HotelsResultSet.prototype.gMapPointHideWin = function(event, hotel) {
    var rnd;
    hotel.gMarker.setIcon(this.markerImage);
    console.log('mouseout');
    rnd = Math.round(Math.random() * 5);
    this.gMapOverlay.hide();
    if (rnd === 40) {
      return this.gMapInfoWin.close();
    }
  };

  HotelsResultSet.prototype.gMapPointClick = function(event, hotel) {
    this.gMapCenter = this.gAllMap.getCenter();
    this.gMapZoom = this.gAllMap.getZoom();
    console.log('save map params', this.gMapCenter, this.gMapZoom);
    this.select(hotel);
    return console.log('gMapEventClick', event, hotel);
  };

  HotelsResultSet.prototype.selectFromPopup = function(hotel, event) {
    var _this = this;
    hotel.activePopup.close();
    hotel.off('back');
    hotel.on('back', function() {
      window.app.render({
        results: ko.observable(hotel.parent)
      }, 'results');
      return window.setTimeout(function() {
        Utils.scrollTo(hotel.oldPageTop, false);
        Utils.scrollTo('#hotelResult' + hotel.hotelId);
        return console.log(hotel.oldPageTop);
      }, 50);
    });
    hotel.getFullInfo();
    window.app.render(hotel, 'info-template');
    return Utils.scrollTo('#content', false);
  };

  HotelsResultSet.prototype.getDateInterval = function() {
    return dateUtils.formatDayMonthInterval(this.checkIn._d, this.checkOut._d);
  };

  HotelsResultSet.prototype.showMoreResults = function() {
    var fv, sv;
    fv = this.data()[0];
    sv = this.data()[1];
    console.log('before more results', fv, sv, this.showParts());
    if (this.numResults() > (this.showParts() * this.showLimit)) {
      this.showParts(this.showParts() + 1);
    }
    fv = this.data()[0];
    sv = this.data()[1];
    return console.log('after more results', fv, sv, this.showParts());
  };

  HotelsResultSet.prototype.checkShowMore = function(ev) {
    var fullHeight, posTop, winHeight;
    posTop = $('html').scrollTop() || $('body').scrollTop();
    fullHeight = $('html')[0].scrollHeight || $('body')[0].scrollHeight;
    winHeight = $(window).height();
    if (((fullHeight - (posTop + winHeight)) < 2) && !this.showFullMap()) {
      if ((window.app.activeView() === 'hotels-results') || (window.app.activeView() === 'tours-results' && window.app.activeModuleInstance().innerTemplate === 'hotels-results')) {
        return this.showMoreResults();
      }
    }
  };

  HotelsResultSet.prototype.sortByPrice = function() {
    if (this.sortBy() !== 'minPrice') {
      this.sortBy('minPrice');
      this.ordBy(1);
      return this.showParts(1);
    }
  };

  HotelsResultSet.prototype.sortByRating = function() {
    if (this.sortBy() !== 'rating') {
      this.sortBy('rating');
      this.ordBy(-1);
      return this.showParts(1);
    }
  };

  HotelsResultSet.prototype.selectHotel = function(hotel, event) {
    return this.select(hotel, event);
  };

  HotelsResultSet.prototype.postInit = function() {
    return this.filters = new HotelFiltersT(this);
  };

  HotelsResultSet.prototype.postFilters = function(fromFilters) {
    var data, fv, sv,
      _this = this;
    if (fromFilters == null) {
      fromFilters = false;
    }
    fv = this.data()[0];
    sv = this.data()[1];
    data = _.filter(this.data(), function(el) {
      return el.visible();
    });
    this.numResults(data.length);
    if (!this.pagesLoad || fromFilters) {
      this.showParts(1);
    } else {
      this.showParts(this.pagesLoad);
    }
    window.setTimeout(function() {
      var kb, offset, posTop;
      fv = _this.data()[0];
      sv = _this.data()[1];
      if (fromFilters) {
        jsPaneScrollHeight();
      }
      if (window.app.activeView() === 'hotels-results') {
        offset = $('#content').offset();
        posTop = $('html').scrollTop() || $('body').scrollTop();
        if ((posTop > offset.top) && !(fromFilters && _this.showFullMap())) {
          Utils.scrollTo('#content');
        }
      } else if ((_this.toursOpened && _this.tours() && _this.filtersConfig) || (_this.tours() && _this.showFullMap())) {
        kb = true;
      } else {
        Utils.scrollTo(0, false);
      }
      if (_this.showFullMap()) {
        _this.showFullMapFunc(null, null, false, true);
      }
      _this.toursOpened = false;
      fv = _this.data()[0];
      return sv = _this.data()[1];
    }, 50);
    fv = this.data()[0];
    return sv = this.data()[1];
  };

  return HotelsResultSet;

})();
// Generated by CoffeeScript 1.4.0
var HotelsSearchParams, SpRoom,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

SpRoom = (function() {

  function SpRoom(parent) {
    var _this = this;
    this.parent = parent;
    this.getUrl = __bind(this.getUrl, this);

    this.getHash = __bind(this.getHash, this);

    this.adults = ko.observable(1).extend({
      integerOnly: {
        min: 1,
        max: 4
      }
    });
    this.children = ko.observable(0).extend({
      integerOnly: {
        min: 0,
        max: 4
      }
    });
    this.ages = ko.observableArray();
    this.adults.subscribe(function(newValue) {
      if (newValue + _this.children() > 4) {
        _this.adults(4 - _this.children());
      }
      if ((_this.parent.overall() - _this.adults() + newValue) > 9) {
        return _this.adults(9 - _this.parent.overall() + _this.adults());
      }
    });
    this.children.subscribe(function(newValue) {
      var i, _i, _ref;
      if (newValue + _this.adults() > 4) {
        newValue = 4 - _this.adults();
        _this.children(newValue);
      }
      if ((_this.parent.overall() - _this.children() + newValue) > 9) {
        _this.children(9 - _this.parent.overall() + _this.children());
      }
      if (_this.ages().length === newValue) {
        return;
      }
      if (_this.ages().length < newValue) {
        for (i = _i = 0, _ref = newValue - _this.ages().length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _this.ages.push({
            age: ko.observable(12).extend({
              integerOnly: {
                min: 12,
                max: 17
              }
            })
          });
        }
      } else if (_this.ages().length > newValue) {
        _this.ages.splice(newValue);
      }
      return ko.processAllDeferredBindingUpdates();
    });
  }

  SpRoom.prototype.fromList = function(item) {
    var parts;
    parts = item.split(':');
    this.adults(parts[0]);
    return this.children(parts[1]);
  };

  SpRoom.prototype.fromObject = function(item) {
    this.adults(+item.adultCount);
    return this.children(+item.childCount);
  };

  SpRoom.prototype.getHash = function() {
    var age, parts, _i, _len, _ref;
    parts = [this.adults(), this.children()];
    _ref = this.ages();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      age = _ref[_i];
      parts.push(age.age());
    }
    return parts.join(':');
  };

  SpRoom.prototype.getUrl = function(i) {
    return ("rooms[" + i + "][adt]=") + this.adults() + ("&rooms[" + i + "][chd]=") + this.children() + ("&rooms[" + i + "][chdAge]=0&rooms[" + i + "][cots]=0");
  };

  return SpRoom;

})();

HotelsSearchParams = (function() {

  function HotelsSearchParams() {
    this.url = __bind(this.url, this);

    this.fromObject = __bind(this.fromObject, this);

    this.fromList = __bind(this.fromList, this);

    this.getHash = __bind(this.getHash, this);

    var _this = this;
    this.city = ko.observable('');
    this.checkIn = ko.observable(false);
    this.checkOut = ko.observable(false);
    this.rooms = ko.observableArray([new SpRoom(this)]);
    this.overall = ko.computed(function() {
      var result, room, _i, _len, _ref;
      result = 0;
      _ref = _this.rooms();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        room = _ref[_i];
        result += room.adults();
        result += room.children();
      }
      return result;
    });
  }

  HotelsSearchParams.prototype.getHash = function() {
    var hash, parts, room, _i, _len, _ref;
    parts = [this.city(), moment(this.checkIn()).format('D.M.YYYY'), moment(this.checkOut()).format('D.M.YYYY')];
    _ref = this.rooms();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      room = _ref[_i];
      parts.push(room.getHash());
    }
    hash = 'hotels/search/' + parts.join('/') + '/';
    window.voyanga_debug("Generated hash for hotels search", hash);
    return hash;
  };

  HotelsSearchParams.prototype.fromList = function(data) {
    var item, r, rest, _i, _len, _results;
    this.city(data[0]);
    this.checkIn(moment(data[1], 'D.M.YYYY').toDate());
    this.checkOut(moment(data[2], 'D.M.YYYY').toDate());
    this.rooms.splice(0);
    rest = data[3].split('/');
    _results = [];
    for (_i = 0, _len = rest.length; _i < _len; _i++) {
      item = rest[_i];
      if (item) {
        r = new SpRoom(this);
        r.fromList(item);
        _results.push(this.rooms.push(r));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  HotelsSearchParams.prototype.fromObject = function(data) {
    var item, r, _i, _len, _ref, _results;
    this.city(data.city);
    this.checkIn(moment(data.checkIn, 'YYYY-M-D').toDate());
    this.checkOut(moment(data.checkIn, 'YYYY-M-D').add('days', data.duration).toDate());
    this.rooms.splice(0);
    _ref = data.rooms;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      r = new SpRoom(this);
      r.fromObject(item);
      _results.push(this.rooms.push(r));
    }
    return _results;
  };

  HotelsSearchParams.prototype.url = function() {
    var i, result, room, _i, _len, _ref;
    result = "hotel/search?city=" + this.city();
    result += '&checkIn=' + moment(this.checkIn()).format('YYYY-M-D');
    result += '&duration=' + moment(this.checkOut()).diff(moment(this.checkIn()), 'days');
    _ref = this.rooms();
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      room = _ref[i];
      result += '&' + room.getUrl(i);
    }
    return result;
  };

  return HotelsSearchParams;

})();
// Generated by CoffeeScript 1.4.0
/*
SEARCH controller, should be splitted once we will get more actions here
*/

var HotelsController,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

HotelsController = (function() {

  function HotelsController(searchParams) {
    this.searchParams = searchParams;
    this.timelineAction = __bind(this.timelineAction, this);

    this.indexAction = __bind(this.indexAction, this);

    this.checkTicketAction = __bind(this.checkTicketAction, this);

    this.handleResults = __bind(this.handleResults, this);

    this.searchAction = __bind(this.searchAction, this);

    this.api = new HotelsAPI;
    this.routes = {
      '/search/:from/:in/:out/*rest': this.searchAction,
      '/timeline/': this.timelineAction,
      '': this.indexAction
    };
    this.results = ko.observable();
    _.extend(this, Backbone.Events);
  }

  HotelsController.prototype.searchAction = function() {
    var args,
      _this = this;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    window.voyanga_debug("HOTELS: Invoking searchAction", args);
    this.searchParams.fromList(args);
    return this.api.search(this.searchParams.url(), function(data) {
      var stacked;
      try {
        stacked = _this.handleResults(data);
      } catch (err) {
        if (err === 'e404') {
          new ErrorPopup('hotels404');
          return;
        }
        new ErrorPopup('e500withText', [err]);
        return;
      }
      _this.results(stacked);
      return _this.render('results', {
        'results': _this.results
      });
    });
  };

  HotelsController.prototype.handleResults = function(data) {
    var stacked;
    window.voyanga_debug("HOTELS: searchAction: handling results", data);
    stacked = new HotelsResultSet(data, data.searchParams);
    stacked.postInit();
    stacked.checkTicket = this.checkTicketAction;
    return stacked;
  };

  HotelsController.prototype.checkTicketAction = function(roomSet, resultDeferred) {
    var diff, now,
      _this = this;
    now = moment();
    diff = now.diff(this.results().creationMoment, 'seconds');
    if (diff < HOTEL_TICKET_TIMELIMIT) {
      resultDeferred.resolve(roomSet);
      return;
    }
    return this.api.search(this.searchParams.url(), function(data) {
      var result, stacked;
      try {
        stacked = _this.handleResults(data);
      } catch (err) {
        new ErrorPopup('e500withText', [err]);
        return;
      }
      result = stacked.findAndSelect(roomSet);
      if (result) {
        return resultDeferred.resolve(result);
      } else {
        new ErrorPopup('hotelsNoTicketOnValidation', false, function() {});
        return _this.results(stacked);
      }
    });
  };

  HotelsController.prototype.indexAction = function() {
    window.voyanga_debug("HOTELS: indexAction");
    return this.render('index', {});
  };

  HotelsController.prototype.timelineAction = function() {
    var _this = this;
    this.render('timeline-template');
    return window.setTimeout(function() {
      VoyangaCalendarTimeline.calendarEvents = [
        {
          dayStart: Date.fromIso('2012-10-23'),
          dayEnd: Date.fromIso('2012-10-23'),
          type: 'flight',
          color: 'red',
          description: ' || -',
          cityFrom: 'MOW',
          cityTo: 'LED'
        }, {
          dayStart: Date.fromIso('2012-10-23'),
          dayEnd: Date.fromIso('2012-10-28'),
          type: 'hotel',
          color: 'red',
          description: 'Californication Hotel2',
          city: 'LED'
        }, {
          dayStart: Date.fromIso('2012-10-28'),
          dayEnd: Date.fromIso('2012-10-28'),
          type: 'flight',
          color: 'red',
          description: '- || ',
          cityFrom: 'LED',
          cityTo: 'MOW'
        }, {
          dayStart: Date.fromIso('2012-10-28'),
          dayEnd: Date.fromIso('2012-10-28'),
          type: 'flight',
          color: 'red',
          description: ' || -',
          cityFrom: 'MOW',
          cityTo: 'LED'
        }, {
          dayStart: Date.fromIso('2012-11-21'),
          dayEnd: Date.fromIso('2012-11-22'),
          type: 'flight',
          color: 'red',
          description: '- || ',
          cityFrom: 'LED',
          cityTo: 'MOW'
        }, {
          dayStart: Date.fromIso('2012-11-21'),
          dayEnd: Date.fromIso('2012-11-28'),
          type: 'hotel',
          color: 'red',
          description: 'Californication Hotel',
          city: 'MOW'
        }, {
          dayStart: Date.fromIso('2012-11-28'),
          dayEnd: Date.fromIso('2012-11-28'),
          type: 'flight',
          color: 'red',
          description: ' || -',
          cityFrom: 'MOW',
          cityTo: 'LED'
        }, {
          dayStart: Date.fromIso('2012-11-28'),
          dayEnd: Date.fromIso('2012-11-28'),
          type: 'flight',
          color: 'red',
          description: '- || ',
          cityFrom: 'LED',
          cityTo: 'AMS'
        }, {
          dayStart: Date.fromIso('2012-11-28'),
          dayEnd: Date.fromIso('2012-11-28'),
          type: 'flight',
          color: 'red',
          description: ' || -',
          cityFrom: 'AMS',
          cityTo: 'LED'
        }, {
          dayStart: Date.fromIso('2012-11-28'),
          dayEnd: Date.fromIso('2012-11-28'),
          type: 'flight',
          color: 'red',
          description: '- || ',
          cityFrom: 'LED',
          cityTo: 'MOW'
        }
      ];
      VoyangaCalendarTimeline.calendarEvents = [
        {
          dayStart: Date.fromIso('2012-11-29'),
          dayEnd: Date.fromIso('2012-11-29'),
          type: 'flight',
          color: 'red',
          description: ' || -',
          cityFrom: 'MOW',
          cityTo: 'LED'
        }, {
          dayStart: Date.fromIso('2012-11-29'),
          dayEnd: Date.fromIso('2012-12-01'),
          type: 'hotel',
          color: 'red',
          description: 'Californication Hotel2',
          city: 'LED'
        }
      ];
      return VoyangaCalendarTimeline.init();
    }, 1000);
  };

  HotelsController.prototype.render = function(view, data) {
    window.voyanga_debug("HOTELS: rendering", view, data);
    return this.trigger("viewChanged", view, data);
  };

  return HotelsController;

})();
// Generated by CoffeeScript 1.4.0
/*
Hotels module
Controller + panel
*/

var HotelsModule;

HotelsModule = (function() {

  function HotelsModule() {
    this.panel = new HotelsPanel();
    this.controller = new HotelsController(this.panel.sp);
  }

  HotelsModule.prototype.resize = function() {
    return ResizeAvia();
  };

  return HotelsModule;

})();
// Generated by CoffeeScript 1.4.0
var City, Event, EventCategory, EventCategorySet, EventLink, EventLinkSet, EventPhotoBox, EventPrice, EventPriceSet, EventSet, EventTag, EventTagSet, EventTour, EventTourResultSet, EventTourSet,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ko.bindingHandlers.highlightChange = {
  update: function(element, valueAccessor, allBindingsAccessor) {
    var allBindings, newEl, previousImage, value, valueUnwrapped, varLeftPos, varLeftPosStart, varTopPos, varTopPosStart;
    value = valueAccessor();
    allBindings = allBindingsAccessor();
    valueUnwrapped = ko.utils.unwrapObservable(value);
    previousImage = allBindings.previousImage;
    newEl = $('<div class="IMGmain" style="visible:hidden"><img src=""></div>');
    newEl.appendTo(".centerTours");
    $(".IMGmain").eq(0).find('img').attr("src", previousImage());
    CenterIMGResize(0);
    $(".IMGmain").eq(0).show();
    varLeftPos = $(".IMGmain").eq(1).css("left");
    varTopPos = $(".IMGmain").eq(1).css("top");
    varLeftPos = parseInt(varLeftPos.slice(0, -2));
    varTopPos = parseInt(varTopPos.slice(0, -2));
    varLeftPosStart = varLeftPos;
    varTopPosStart = varTopPos;
    $(".IMGmain").eq(1).css("opacity", "0").css("left", varLeftPosStart + "px").css("top", varTopPosStart + "px").find("img").attr("src", valueUnwrapped);
    previousImage(valueUnwrapped);
    slideToursSlide();
    return $(".IMGmain").eq(1).find("img").load(function() {
      CenterIMGResize(1);
      $(".IMGmain").eq(0).animate({
        opacity: 0
      }, speedAnimateChangePic, function() {
        return $(".IMGmain:not(:last-child)").eq(0).remove();
      });
      return $(".IMGmain").eq(1).animate({
        opacity: 1
      }, speedAnimateChangePic);
    });
  }
};

Event = (function(_super) {

  __extends(Event, _super);

  function Event(data) {
    var _this = this;
    this.startDate = ko.observable(new Date(data.startDate));
    this.endDate = ko.observable(new Date(data.endDate));
    this.address = ko.observable(data.address);
    this.contact = ko.observable(data.contact);
    this.eventId = data.id;
    this.eventPageUrl = '/eventInfo/info/eventId/' + this.eventId;
    this.preview = ko.observable(data.preview);
    this.description = ko.observable(data.description);
    this.title = ko.observable(data.title);
    this.categories = ko.observableArray(new EventCategorySet(data.categories));
    this.links = ko.observableArray(new EventLinkSet(data.links));
    this.tags = ko.observableArray(new EventTagSet(data.tags));
    this.prices = ko.observableArray(new EventPriceSet(data.prices));
    this.tour = ko.observable(new EventTourSet(data.tours));
    this.image = ko.observable(data.image);
    this.thumb = ko.observable(data.thumb);
    this.active = ko.observable(data.active);
    this.minimalPrice = ko.computed(function() {
      if (_this.prices()[0]) {
        return _this.prices()[0].price;
      } else {
        return 0;
      }
    });
  }

  Event.prototype.duration = function() {
    return dateUtils.formatDuration(this._duration);
  };

  return Event;

})(Backbone.Events);

EventSet = (function() {

  function EventSet(events) {
    this.afterRender = __bind(this.afterRender, this);

    this.mapsInit = __bind(this.mapsInit, this);

    this.closeEventsMaps = __bind(this.closeEventsMaps, this);

    this.closeEventsPhoto = __bind(this.closeEventsPhoto, this);

    this.setActive = __bind(this.setActive, this);

    var _this = this;
    this.events = ko.observableArray(events);
    this.currentTitle = ko.observable('HUY');
    this.currentEvent = ko.computed(function() {
      var activeEvents;
      activeEvents = _.filter(_this.events(), function(event) {
        return event.active();
      });
      console.log("SETTING TAITL", activeEvents[0].title());
      _this.currentTitle(activeEvents[0].title());
      return activeEvents[0];
    });
    this.previousImage = ko.observable('');
    this.activeMaps = 0;
    this.mapsInited = false;
    this.isRendered = false;
  }

  EventSet.prototype.setActive = function(valueAccessor, event) {
    var _this = this;
    if ($(event.target).hasClass('lookEyes')) {
      return true;
    }
    if (this.activeMaps === 1) {
      this.closeEventsMaps();
    }
    $('.slideTours').find('.triangle').animate({
      'top': '0px'
    }, 200);
    this.events(_.map(this.events(), function(event) {
      return event.active(false);
    }));
    valueAccessor.active(true);
    return $(event.target).closest('.toursTicketsMain').find('.triangle').animate({
      'top': '-16px'
    }, 200);
  };

  EventSet.prototype.closeEventsPhoto = function() {
    if ($(".mapsBigAll").is(':visible')) {
      return;
    }
    $(".slideTours").find(".active").find(".triangle").animate({
      top: "0px"
    }, 200);
    $(".toursTicketsMain").removeClass("active");
    $(".mapsBigAll").css("opacity", "0");
    $(".toursBigAll").animate({
      opacity: 0
    }, 700, function() {
      return $(this).css("display", "none");
    });
    $(".mapsBigAll").show();
    if (!this.mapsInited) {
      this.mapsInit();
    }
    $(".mapsBigAll").animate({
      opacity: 1
    }, 700);
    return this.activeMaps = 1;
  };

  EventSet.prototype.closeEventsMaps = function() {
    $(".toursBigAll").css("opacity", "0");
    $(".mapsBigAll").animate({
      opacity: 0
    }, 700, function() {
      return $(this).css("display", "none");
    });
    $(".toursBigAll").show();
    $(".toursBigAll").animate({
      opacity: 1
    }, 700);
    return this.activeMaps = 0;
  };

  EventSet.prototype.mapsInit = function() {
    var element, gMap, value;
    value = {
      lat: 52,
      lng: 10
    };
    this.mapsInited = true;
    element = $(".mapsBigAll")[0];
    return gMap = new google.maps.Map(element, {
      'mapTypeControl': false,
      'panControl': false,
      'zoomControlOptions': {
        position: google.maps.ControlPosition.LEFT_TOP,
        style: google.maps.ZoomControlStyle.SMALL
      },
      'streetViewControl': false,
      'zoom': 3,
      'mapTypeId': google.maps.MapTypeId.TERRAIN,
      'center': new google.maps.LatLng(value.lat, value.lng)
    });
  };

  EventSet.prototype.afterRender = function() {
    this.mapsInited = false;
    window.app.toggleGMaps(true);
    this.isRendered = true;
    return ResizeAvia();
  };

  return EventSet;

})();

EventCategory = (function() {

  function EventCategory(data) {
    this.id = ko.observable(data.id);
    this.title = ko.observable(data.title);
  }

  return EventCategory;

})();

EventCategorySet = (function() {

  function EventCategorySet(data) {
    var set;
    set = [];
    $.each(data, function(i, eventCategory) {
      return set.push(new EventCategory(eventCategory));
    });
    return set;
  }

  return EventCategorySet;

})();

EventLink = (function() {

  function EventLink(data) {
    this.title = ko.observable(data.title);
    this.url = ko.observable(data.url);
  }

  return EventLink;

})();

EventLinkSet = (function() {

  function EventLinkSet(data) {
    var set;
    set = [];
    $.each(data, function(i, eventLink) {
      return set.push(new EventLink(eventLink));
    });
    return set;
  }

  return EventLinkSet;

})();

EventTag = (function() {

  function EventTag(data) {
    this.name = ko.observable(data.name);
  }

  return EventTag;

})();

EventTagSet = (function() {

  function EventTagSet(data) {
    var set;
    set = [];
    $.each(data, function(i, eventTag) {
      return set.push(new EventTag(eventTag));
    });
    return set;
  }

  return EventTagSet;

})();

City = (function() {

  function City(data) {
    this.title = ko.observable(data.title);
  }

  return City;

})();

EventPrice = (function() {

  function EventPrice(data) {
    this.city = ko.observable(new City(data.city));
    this.price = ko.observable(data.price);
  }

  return EventPrice;

})();

EventPriceSet = (function() {

  function EventPriceSet(data) {
    var set;
    set = [];
    $.each(data, function(i, eventPrice) {
      return set.push(new EventPrice(eventPrice));
    });
    return set;
  }

  return EventPriceSet;

})();

EventTour = (function() {

  function EventTour(data) {
    this.name = data.name;
  }

  return EventTour;

})();

EventTourSet = (function() {

  function EventTourSet(data) {
    var set;
    set = [];
    $.each(data, function(i, tour) {
      return set.push(new EventTour(tour));
    });
    return set;
  }

  return EventTourSet;

})();

EventTourResultSet = (function() {

  function EventTourResultSet(resultSet, eventId) {
    var _this = this;
    this.eventId = eventId;
    this.hidePanel = __bind(this.hidePanel, this);

    this.showPanel = __bind(this.showPanel, this);

    this.togglePanel = __bind(this.togglePanel, this);

    this.gotoAndShowPanel = __bind(this.gotoAndShowPanel, this);

    this.reinit = __bind(this.reinit, this);

    this.items = ko.observableArray([]);
    this.selectedCity = ko.observable(resultSet.city.id);
    this.fullPrice = ko.observable(0);
    this.fullPriceUpdateTime = ko.observable(window.priceData[this.selectedCity()]["updateTime"]);
    this.fullPriceUpdateTimeText = ko.computed(function() {
      var upTime, updateText;
      upTime = moment(_this.fullPriceUpdateTime());
      console.log('upDate', upTime, upTime._d);
      updateText = dateUtils.formatDayMonth(upTime._d) + ', ' + dateUtils.formatTime(upTime._d);
      return updateText;
    });
    this.selectedCity.subscribe(function(newCityId) {
      _this.fullPriceUpdateTime(window.priceData[newCityId]["updateTime"]);
      return _this.reinit(window.toursArr[newCityId]);
    });
    this.startCity = ko.observable(resultSet.city.localRu);
    this.activePanel = ko.observable(null);
    this.overviewPeople = ko.observable(0);
    this.overviewPricePeople = ko.observable('');
    this.photoBox = new EventPhotoBox(window.eventPhotos);
    this.visiblePanel = ko.observable(false);
    this.visiblePanel.subscribe(function(newValue) {
      if (newValue) {
        return _this.showPanel();
      } else {
        return _this.hidePanel();
      }
    });
    this.showPanelText = ko.computed(function() {
      if (_this.visiblePanel()) {
        return "";
      } else {
        return "";
      }
    });
    this.reinit(resultSet);
  }

  EventTourResultSet.prototype.reinit = function(resultSet) {
    var firstHotel, i, item, panelSet, room, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    this.resultSet = resultSet;
    this.hasFlight = false;
    this.hasHotel = false;
    this.items([]);
    this.flightCounter = ko.observable(0);
    this.hotelCounter = ko.observable(0);
    this.selected_key = ko.observable('');
    this.selected_best = ko.observable('');
    this.correctTour = ko.observable(false);
    this.totalCost = 0;
    panelSet = new TourPanelSet();
    this.activePanel(panelSet);
    this.activePanel().startCity(this.resultSet.city.code);
    this.activePanel().selectedParams = {
      ticketParams: [],
      eventId: this.eventId
    };
    this.activePanel().sp.calendarActivated(false);
    window.app.fakoPanel(panelSet);
    this.startCity(this.resultSet.city.localRu);
    console.log('reinitEventData', this);
    this.flightCounterWord = ko.computed(function() {
      var res;
      res = Utils.wordAfterNum(_this.flightCounter(), '', '', '');
      if (_this.hotelCounter() > 0) {
        res = res + ', ';
      }
      return res;
    });
    this.hotelCounterWord = ko.computed(function() {
      return Utils.wordAfterNum(_this.hotelCounter(), '', '', '');
    });
    try {
      _.each(this.resultSet.items, function(item) {
        var aviaResult;
        if (item.isFlight) {
          _this.hasFlight = true;
          _this.flightCounter(_this.flightCounter() + 1);
          _this.roundTrip = item.flights.length === 2;
          aviaResult = new AviaResult(item, _this);
          aviaResult.sort();
          aviaResult.priceHtml = ko.observable(aviaResult.price + '<span class="rur">o</span>');
          aviaResult.overviewText = ko.observable(" " + aviaResult.departureCity() + ' &rarr; ' + aviaResult.arrivalCity());
          aviaResult.overviewTemplate = 'tours-event-avia-ticket';
          aviaResult.dateClass = ko.observable(_this.roundTrip ? 'blue-two' : 'blue-one');
          aviaResult.isAvia = ko.observable(item.isFlight);
          aviaResult.isHotel = ko.observable(item.isHotel);
          aviaResult.startDate = aviaResult.departureDate();
          aviaResult.dateHtml = ko.observable('<div class="day">' + dateUtils.formatHtmlDayShortMonth(aviaResult.departureDate()) + '</div>' + (_this.roundTrip ? '<div class="day">' + dateUtils.formatHtmlDayShortMonth(aviaResult.rtDepartureDate()) + '</div>' : ''));
          _this.activePanel().selectedParams.ticketParams.push(aviaResult.getParams());
          aviaResult.overviewPeople = ko.observable;
          _this.items.push(aviaResult);
          return _this.totalCost += aviaResult.price;
        } else if (item.isHotel) {
          _this.hasHotel = true;
          _this.hotelCounter(_this.hotelCounter() + 1);
          _this.lastHotel = new HotelResult(item, _this, item.duration, item, item.hotelDetails);
          _this.lastHotel.priceHtml = ko.observable(_this.lastHotel.roomSets()[0].price + '<span class="rur">o</span>');
          _this.lastHotel.dateClass = ko.observable('orange-two');
          _this.lastHotel.overviewTemplate = 'tours-event-hotels-ticket';
          _this.lastHotel.isAvia = ko.observable(item.isFlight);
          _this.lastHotel.isHotel = ko.observable(item.isHotel);
          _this.lastHotel.startDate = _this.lastHotel.checkIn;
          _this.lastHotel.serachParams = item.searchParams;
          _this.lastHotel.overviewText = ko.observable("<span class='hotel-left-long'>  " + _this.lastHotel.serachParams.cityFull.casePre + "</span><span class='hotel-left-short'>" + _this.lastHotel.address + "</span>");
          _this.lastHotel.dateHtml = ko.observable('<div class="day">' + dateUtils.formatHtmlDayShortMonth(_this.lastHotel.checkIn) + '</div>' + '<div class="day">' + dateUtils.formatHtmlDayShortMonth(_this.lastHotel.checkOut) + '</div>');
          _this.activePanel().selectedParams.ticketParams.push(_this.lastHotel.getParams());
          console.log("Add to items hotel ", _this.lastHotel);
          _this.items.push(_this.lastHotel);
          return _this.totalCost += _this.lastHotel.roomSets()[0].discountPrice;
        }
      });
      _.sortBy(this.items(), function(item) {
        return item.startDate;
      });
      this.startDate = this.items()[0].startDate;
      this.dateHtml = ko.observable('<div class="day">' + dateUtils.formatHtmlDayShortMonth(this.startDate) + '</div>');
      firstHotel = true;
      console.log('items', this.items());
      _ref = this.items();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.isHotel()) {
          if (!firstHotel) {
            this.activePanel().addPanel();
          } else {
            i = 0;
            _ref1 = item.serachParams.rooms;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              room = _ref1[_j];
              if (!this.activePanel().sp.rooms()[i]) {
                this.activePanel().sp.addSpRoom();
              }
              this.activePanel().sp.rooms()[i].adults(room.adultCount);
              this.activePanel().sp.rooms()[i].children(room.childCount);
              this.activePanel().sp.rooms()[i].ages(room.childAge);
              i++;
            }
            firstHotel = false;
          }
          this.activePanel().lastPanel.checkIn(moment(item.checkIn)._d);
          this.activePanel().lastPanel.checkOut(moment(item.checkOut)._d);
          this.activePanel().lastPanel.city(item.cityCode);
          console.log('try set destData', moment(item.checkIn)._d, moment(item.checkOut)._d, item.cityCode, 'to', this.activePanel().lastPanel, this.activePanel().lastPanel.checkIn());
        }
      }
      this.overviewPeople(Utils.wordAfterNum(this.activePanel().sp.overall(), '', '', ''));
      this.overviewPricePeople('  ' + (this.activePanel().sp.adults() ? Utils.wordAfterNum(this.activePanel().sp.adults(), '', '', '') : '') + (this.activePanel().sp.children() ? ' ' + Utils.wordAfterNum(this.activePanel().sp.children(), '', '', '') : ''));
      console.log('activePanel', this.activePanel());
      this.activePanel().saveStartParams();
      _.last(this.activePanel().panels()).minimizedCalendar(true);
      window.setTimeout(function() {
        console.log('calendar activated');
        return _this.activePanel().sp.calendarActivated(true);
      }, 1000);
      window.setTimeout(function() {
        if (_this.visiblePanel()) {
          console.log('need showPanel');
          return $('.sub-head.event').css('margin-top', '0px');
        } else {
          $('.sub-head.event').stop(true);
          $('.sub-head.event').css('margin-top', (-_this.activePanel().heightPanelSet() + 4) + 'px');
          return console.log('need hidePanel', $('.sub-head.event'), _this.activePanel().heightPanelSet(), $('.sub-head.event').css('margin-top'));
        }
      }, 200);
      this.correctTour(true);
    } catch (exept) {
      console.log("Cannot process tour");
      this.correctTour(false);
    }
    if (this.resultSet.price) {
      this.totalCost = this.resultSet.price;
    }
    return this.fullPrice(this.totalCost);
  };

  EventTourResultSet.prototype.gotoAndShowPanel = function() {
    Utils.scrollTo('.panel');
    return this.visiblePanel(true);
  };

  EventTourResultSet.prototype.togglePanel = function() {
    return this.visiblePanel(!this.visiblePanel());
  };

  EventTourResultSet.prototype.showPanel = function() {
    console.log('showPanel');
    return $('.sub-head.event').animate({
      'margin-top': '0px'
    });
  };

  EventTourResultSet.prototype.hidePanel = function() {
    console.log('hidePanel', this.activePanel().heightPanelSet());
    return $('.sub-head.event').animate({
      'margin-top': (-this.activePanel().heightPanelSet() + 4) + 'px'
    });
  };

  return EventTourResultSet;

})();

EventPhotoBox = (function() {

  function EventPhotoBox(picturesRaw) {
    this.next = __bind(this.next, this);

    this.prev = __bind(this.prev, this);

    this.onResize = __bind(this.onResize, this);

    this.onComplete = __bind(this.onComplete, this);

    this.onAnimate = __bind(this.onAnimate, this);

    this.afterLoad = __bind(this.afterLoad, this);

    this.afterRender = __bind(this.afterRender, this);

    this.getIndex = __bind(this.getIndex, this);

    var photoObj, picture, pictures, _i, _len,
      _this = this;
    this.photos = ko.observableArray([]);
    this.imagesServer = ko.observable('');
    this.totalCount = 0;
    this.unloadedCount = 0;
    this.activeIndex = ko.observable(0);
    this.picturesPadding = ko.observable(5);
    this.animation = false;
    this.boxHeight = ko.observable(0);
    this.picturesLoaded = false;
    this.afterRendered = false;
    this.renderedPhotos = ko.computed(function() {
      var result;
      return result = [];
    });
    pictures = [];
    for (_i = 0, _len = picturesRaw.length; _i < _len; _i++) {
      photoObj = picturesRaw[_i];
      picture = new Image();
      this.unloadedCount++;
      $(picture).bind('load error', function(e) {
        var photo;
        console.log('image is loaded', e, _this);
        if (e.type === 'load') {
          _this.totalCount++;
          photo = {};
          photo.url = e.currentTarget.src;
          photo.height = e.currentTarget.height;
          photo.width = e.currentTarget.width;
          photo.width = Math.round(photo.width * (400 / photo.height));
          photo.height = 400;
          _this.boxHeight(400);
          _this.photos.push(photo);
        }
        _this.unloadedCount--;
        if (_this.unloadedCount <= 0) {
          _this.picturesLoaded = true;
          return _this.afterLoad();
        }
      });
      picture.src = this.imagesServer() + photoObj.url;
    }
  }

  EventPhotoBox.prototype.getIndex = function(ind) {
    var result;
    result = ind % this.totalCount;
    if (result < 0) {
      result = this.totalCount + result;
    }
    return result;
  };

  EventPhotoBox.prototype.afterRender = function() {
    this.afterRendered = true;
    return this.afterLoad();
  };

  EventPhotoBox.prototype.afterLoad = function() {
    var divInfo, dw, elem, i, tmpdw, _i, _j, _k, _l, _len, _ref;
    if (this.afterRendered && this.picturesLoaded) {
      this.renderedDivs = [];
      console.log('phts', this.photos(), this.boxHeight());
      for (i = _i = -2; _i <= 2; i = ++_i) {
        divInfo = {};
        console.log('cmpW', i, 'out', this.getIndex(i));
        divInfo.div = $('<div class="eventPhoto"><img src="' + this.photos()[this.getIndex(i)].url + '" height="400"/></div>');
        divInfo.prevInd = this.getIndex(i - 1);
        divInfo.nextInd = this.getIndex(i + 1);
        divInfo.thisInd = this.getIndex(i);
        this.renderedDivs.push(divInfo);
      }
      dw = Math.round(this.photos()[this.renderedDivs[2].thisInd].width / 2);
      tmpdw = dw + this.picturesPadding();
      this.renderedDivs[2].left = -dw;
      for (i = _j = 3; _j <= 4; i = ++_j) {
        this.renderedDivs[i].left = tmpdw;
        tmpdw += this.photos()[this.renderedDivs[i].thisInd].width + this.picturesPadding();
      }
      tmpdw = -dw;
      for (i = _k = 1; _k >= 0; i = --_k) {
        tmpdw -= this.photos()[this.renderedDivs[i].thisInd].width + this.picturesPadding();
        this.renderedDivs[i].left = tmpdw;
      }
      _ref = this.renderedDivs;
      for (_l = 0, _len = _ref.length; _l < _len; _l++) {
        elem = _ref[_l];
        elem.div.css('left', elem.left + 'px');
        $('#eventsContent .photoGallery .centerPosition').append(elem.div);
      }
      console.log('all loaded', this.renderedDivs);
      return $('.events .center-block').css('position', 'static');
    }
  };

  EventPhotoBox.prototype.onAnimate = function(pos, info) {
    var deltaLeft, elem, _i, _len, _ref, _results;
    deltaLeft = pos - info.start;
    _ref = this.renderedDivs;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      _results.push(elem.div.css('left', (elem.left + deltaLeft) + 'px'));
    }
    return _results;
  };

  EventPhotoBox.prototype.onComplete = function() {
    var divInfo, elem, i, left, _i, _len, _ref;
    console.log('animation complete');
    _ref = this.renderedDivs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      elem.left = elem.left + this.delta;
    }
    if (this.delta < 0) {
      console.log('next');
      this.renderedDivs[0].div.remove();
      this.renderedDivs.shift();
      i = this.renderedDivs[3].nextInd;
      left = this.renderedDivs[3].left + this.photos()[this.renderedDivs[3].thisInd].width + this.picturesPadding();
    } else {
      console.log('prev');
      this.renderedDivs[4].div.remove();
      this.renderedDivs.pop();
      i = this.renderedDivs[0].prevInd;
      left = this.renderedDivs[0].left - this.photos()[i].width - this.picturesPadding();
    }
    divInfo = {};
    divInfo.div = $('<div class="eventPhoto"><img src="' + this.photos()[this.getIndex(i)].url + '" height="400"/></div>');
    divInfo.prevInd = this.getIndex(i - 1);
    divInfo.nextInd = this.getIndex(i + 1);
    divInfo.thisInd = this.getIndex(i);
    divInfo.left = left;
    divInfo.div.css('left', divInfo.left + 'px');
    if (this.delta < 0) {
      this.renderedDivs.push(divInfo);
      $('#eventsContent .photoGallery .centerPosition').append(divInfo.div);
    } else {
      this.renderedDivs.unshift(divInfo);
      $('#eventsContent .photoGallery .centerPosition').prepend(divInfo.div);
    }
    console.log('divs', this.renderedDivs);
    return this.animation = false;
  };

  EventPhotoBox.prototype.onResize = function() {
    return console.log('resize');
  };

  EventPhotoBox.prototype.prev = function() {
    var dw,
      _this = this;
    if (!this.animation) {
      this.animation = true;
      dw = -Math.round(this.photos()[this.renderedDivs[1].thisInd].width / 2);
      this.delta = dw - this.renderedDivs[1].left;
      console.log('delta', this.delta);
      return this.renderedDivs[1].div.animate({
        left: dw + 'px'
      }, {
        step: function(pos, info) {
          return _this.onAnimate(pos, info);
        },
        complete: function() {
          return _this.onComplete();
        }
      });
    }
  };

  EventPhotoBox.prototype.next = function() {
    var dw,
      _this = this;
    if (!this.animation) {
      this.animation = true;
      dw = -Math.round(this.photos()[this.renderedDivs[3].thisInd].width / 2);
      this.delta = dw - this.renderedDivs[3].left;
      console.log('delta', this.delta);
      return this.renderedDivs[3].div.animate({
        left: dw + 'px'
      }, {
        step: function(pos, info) {
          return _this.onAnimate(pos, info);
        },
        complete: function() {
          return _this.onComplete();
        }
      });
    }
  };

  return EventPhotoBox;

})();
// Generated by CoffeeScript 1.4.0
var Application,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

Application = (function(_super) {

  __extends(Application, _super);

  function Application() {
    this.isEvent = __bind(this.isEvent, this);

    this.isNotEvent = __bind(this.isNotEvent, this);

    this.mapRendered = __bind(this.mapRendered, this);

    this.contentRendered = __bind(this.contentRendered, this);

    this.handle404 = __bind(this.handle404, this);

    this.bindItemsToEvent = __bind(this.bindItemsToEvent, this);

    this.bindItemsToBuy = __bind(this.bindItemsToBuy, this);

    this.bindEvents = __bind(this.bindEvents, this);

    this.runWithModule = __bind(this.runWithModule, this);

    this.render = __bind(this.render, this);

    this.reRenderCalendarEvent = __bind(this.reRenderCalendarEvent, this);

    this.reRenderCalendarStatic = __bind(this.reRenderCalendarStatic, this);

    this.reRenderCalendar = __bind(this.reRenderCalendar, this);

    this.minimizeCalendar = __bind(this.minimizeCalendar, this);

    this.initCalendar = __bind(this.initCalendar, this);

    var result,
      _this = this;
    window.onerror = function(error) {
      return new ErrorPopup('e500withText', [error]);
    };
    this.activeModule = ko.observable(null);
    this.activeModuleInstance = ko.observable(null);
    this.activeSearchPanel = ko.observable(null);
    result = {
      template: '',
      data: {},
      rt: function() {
        return true;
      },
      departureDate: function() {
        return '12.11.2013';
      },
      arrivalDate: function() {
        return '12.12.2013';
      },
      calendarText: 'DOH',
      minimizeCalendar: function() {
        return true;
      },
      calendarHidden: function() {
        return true;
      },
      calendarShadow: function() {
        return true;
      },
      afterRender: function() {}
    };
    this.fakoPanel = ko.observable(result);
    this.panel = ko.computed(function() {
      var am;
      am = _this.activeModuleInstance();
      if (am) {
        result = ko.utils.unwrapObservable(am.panel);
        result = ko.utils.unwrapObservable(result);
        if (result !== null) {
          _this.fakoPanel(result);
          _this.activeSearchPanel(_this.fakoPanel());
          return ko.processAllDeferredBindingUpdates();
        }
      }
    });
    this._view = ko.observable(false);
    this.activeView = ko.computed(function() {
      if (!_this._view()) {
        return 'stub';
      }
      return _this.activeModule() + '-' + _this._view();
    });
    this.in1 = ko.observable(0);
    this.indexMode = ko.computed(function() {
      return _this.in1(_this._view() === 'index');
    });
    this.calendarInitialized = false;
    this.showEventsPicture = ko.computed(function() {
      return _this.activeView() === 'tours-index';
    });
    this.viewData = ko.observable({});
    this.slider = new Slider();
    this.slider.init();
    this.activeModule.subscribe(this.slider.handler);
    this.debugMode = ko.observable(false);
    this.breakdown = ko.observable(false);
  }

  Application.prototype.initCalendar = function() {
    throw "Deprecated";
  };

  Application.prototype.minimizeCalendar = function() {
    if (this.activeSearchPanel()) {
      return this.activeSearchPanel().minimizedCalendar(true);
    }
  };

  Application.prototype.reRenderCalendar = function(elements) {
    var _this = this;
    VoyangaCalendarStandart.init(this.fakoPanel, elements[1]);
    this.fakoPanel.subscribe(function(newPanel) {
      if (newPanel.panels) {
        return _this.activeSearchPanel(_.last(newPanel.panels()));
      }
    });
    if (this.fakoPanel().panels) {
      return this.activeSearchPanel(_.last(this.fakoPanel().panels()));
    }
  };

  Application.prototype.reRenderCalendarStatic = function(elements) {
    var _this = this;
    $('.calenderWindow').css('position', 'static').find('.calendarSlide').css('position', 'static');
    VoyangaCalendarStandart.init(this.fakoPanel, elements[1]);
    this.fakoPanel.subscribe(function(newPanel) {
      if (newPanel.panels) {
        return _this.activeSearchPanel(_.last(newPanel.panels()));
      }
    });
    if (this.fakoPanel().panels) {
      return this.activeSearchPanel(_.last(this.fakoPanel().panels()));
    }
  };

  Application.prototype.reRenderCalendarEvent = function(elements) {
    console.log('rerender calendar');
    $('.calenderWindow').css('position', 'static').find('.calendarSlide').css('position', 'static');
    VoyangaCalendarStandart.init(this.itemsToBuy.activePanel, elements[1]);
    return this.activeSearchPanel(_.last(this.itemsToBuy.activePanel().panels()));
  };

  Application.prototype.render = function(data, view) {
    this.viewData(data);
    this._view(view);
    return $(window).resize();
  };

  Application.prototype.register = function(prefix, module, isDefault) {
    var action, controller, route, _ref,
      _this = this;
    if (isDefault == null) {
      isDefault = false;
    }
    controller = module.controller;
    controller.on("viewChanged", function(view, data) {
      return _this.render(data, view);
    });
    _ref = controller.routes;
    for (route in _ref) {
      action = _ref[route];
      window.voyanga_debug("APP: registreing route", prefix, route, action);
      this.route(prefix + route, prefix, action);
      if (isDefault && route === '') {
        this.route(route, prefix, action);
      }
    }
    return this.on("beforeroute:" + prefix, function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      window.voyanga_debug("APP: routing", args);
      if (this.panel() === void 0 || (prefix !== this.activeModule())) {
        this.minimizeCalendar();
        window.voyanga_debug("APP: switching active module to", prefix);
        this.activeModule(prefix);
        window.voyanga_debug("APP: activating panel", ko.utils.unwrapObservable(module.panel));
        this.activeModuleInstance(module);
        $(window).unbind('resize');
        $(window).resize(module.resize);
        ko.processAllDeferredBindingUpdates();
        return this.toggleGMaps(false);
      }
    });
  };

  Application.prototype.toggleGMaps = function(force) {
    if ((this.activeModule() === 'avia') || (this.activeModule() === 'hotels')) {
      if (force || (this.events && this.events.isRendered)) {
        return this.events.closeEventsPhoto();
      }
    } else {
      if (force || (this.events && this.events.isRendered)) {
        return this.events.closeEventsMaps();
      }
    }
  };

  Application.prototype.run = function() {
    Backbone.history.start();
    this.bindEvents();
    return this.slider.handler(this.activeModule());
  };

  Application.prototype.runWithModule = function(module) {
    Backbone.history.start({
      silent: true
    });
    window.app.navigate('#' + module, {
      replace: true
    });
    this.activeModule(module);
    $(window).unbind('resize');
    $(window).resize(ResizeAvia);
    return $(window).resize();
  };

  Application.prototype.bindEvents = function() {
    var ev;
    ev = [];
    $.each(window.eventsRaw, function(i, el) {
      return ev.push(new Event(el));
    });
    return this.events = new EventSet(ev);
  };

  Application.prototype.bindItemsToBuy = function() {
    var tourTrip;
    tourTrip = new TourTripResultSet(window.tripRaw);
    return this.itemsToBuy = tourTrip;
  };

  Application.prototype.bindItemsToEvent = function() {
    var tourTrip;
    tourTrip = new EventTourResultSet(window.tripRaw, window.eventId);
    return this.itemsToBuy = tourTrip;
  };

  Application.prototype.handle404 = function() {
    return new ErrorPopup('avia500');
  };

  Application.prototype.route = function(route, name, callback) {
    return Backbone.Router.prototype.route.call(this, route, name, function() {
      this.trigger.apply(this, ['beforeroute:' + name].concat(_.toArray(arguments)));
      return callback.apply(this, arguments);
    });
  };

  Application.prototype.contentRendered = function() {
    window.voyanga_debug("APP: Content rendered");
    this.trigger(this.activeModule() + ':contentRendered');
    ResizeFun();
    return WidthMine();
  };

  Application.prototype.mapRendered = function(elem) {
    return $('.slideTours').find('.active').find('.triangle').animate({
      'top': '-16px'
    }, 200);
  };

  Application.prototype.isNotEvent = function() {
    return !this.isEvent();
  };

  Application.prototype.isEvent = function() {
    return this.activeView() === 'tours-index';
  };

  return Application;

})(Backbone.Router);

window.voyanga_debug = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return console.log.apply(console, args);
};
$(function() {
    var app, avia, hotels, tour;
    console.time("App dispatching");
    app = new Application();
    avia = new AviaModule();
    hotels = new HotelsModule();
    tour = new ToursModule();
    window.app = app;
    app.register('tours', tour, true);
    app.register('hotels', hotels);
    app.register('avia', avia);
    app.run();
    console.timeEnd("App dispatching");
    console.time("Rendering");
    ko.applyBindings(app);
    ko.processAllDeferredBindingUpdates();
    return console.timeEnd("Rendering");
});console.log = function () {};
console.error = function () {};
console.warn = function () {};
console.info = function () {};
console.time = function () {};
console.timeEnd = function () {};